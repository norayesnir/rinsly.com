import {
  Fragment,
  computed,
  createElementBlock,
  createRenderer,
  defineComponent,
  getCurrentInstance,
  h,
  inject,
  normalizeStyle,
  onMounted,
  onUnmounted,
  openBlock,
  provide,
  reactive,
  readonly,
  ref,
  shallowRef,
  useSlots,
  watch,
  watchEffect
} from "./chunk-RAKT47ZN.js";
import {
  ACESFilmicToneMapping,
  BufferAttribute,
  Camera,
  Clock,
  Color,
  LoadingManager,
  OrthographicCamera,
  PCFSoftShadowMap,
  PerspectiveCamera,
  REVISION,
  Raycaster,
  SRGBColorSpace,
  Scene,
  TextureLoader,
  Vector2,
  Vector3,
  WebGLRenderer,
  three_module_exports
} from "./chunk-2E65YDO7.js";

// node_modules/@vueuse/shared/index.mjs
import { shallowRef as shallowRef2, watchEffect as watchEffect2, readonly as readonly2, ref as ref2, watch as watch2, customRef, getCurrentScope, onScopeDispose, effectScope, provide as provide2, inject as inject2, isVue3, version, isRef, unref, computed as computed2, reactive as reactive2, toRefs as toRefs$1, toRef as toRef$1, isVue2, set as set$1, getCurrentInstance as getCurrentInstance2, onBeforeMount, nextTick, onBeforeUnmount, onMounted as onMounted2, onUnmounted as onUnmounted2, isReactive } from "vue-demi";
function tryOnScopeDispose(fn) {
  if (getCurrentScope()) {
    onScopeDispose(fn);
    return true;
  }
  return false;
}
function createEventHook() {
  const fns = /* @__PURE__ */ new Set();
  const off = (fn) => {
    fns.delete(fn);
  };
  const on = (fn) => {
    fns.add(fn);
    const offFn = () => off(fn);
    tryOnScopeDispose(offFn);
    return {
      off: offFn
    };
  };
  const trigger = (param) => {
    return Promise.all(Array.from(fns).map((fn) => fn(param)));
  };
  return {
    on,
    off,
    trigger
  };
}
function toValue(r) {
  return typeof r === "function" ? r() : unref(r);
}
var isClient = typeof window !== "undefined" && typeof document !== "undefined";
var toString = Object.prototype.toString;
var isObject = (val) => toString.call(val) === "[object Object]";
var noop = () => {
};
var isIOS = getIsIOS();
function getIsIOS() {
  var _a;
  return isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
}
function cacheStringFunction(fn) {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cacheStringFunction(
  (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
);
var camelizeRE = /-(\w)/g;
var camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
});
function identity(arg) {
  return arg;
}
function objectPick(obj, keys2, omitUndefined = false) {
  return keys2.reduce((n, k) => {
    if (k in obj) {
      if (!omitUndefined || obj[k] !== void 0)
        n[k] = obj[k];
    }
    return n;
  }, {});
}
function toRefs(objectRef, options = {}) {
  if (!isRef(objectRef))
    return toRefs$1(objectRef);
  const result = Array.isArray(objectRef.value) ? Array.from({ length: objectRef.value.length }) : {};
  for (const key in objectRef.value) {
    result[key] = customRef(() => ({
      get() {
        return objectRef.value[key];
      },
      set(v) {
        var _a;
        const replaceRef = (_a = toValue(options.replaceRef)) != null ? _a : true;
        if (replaceRef) {
          if (Array.isArray(objectRef.value)) {
            const copy = [...objectRef.value];
            copy[key] = v;
            objectRef.value = copy;
          } else {
            const newObject = { ...objectRef.value, [key]: v };
            Object.setPrototypeOf(newObject, Object.getPrototypeOf(objectRef.value));
            objectRef.value = newObject;
          }
        } else {
          objectRef.value[key] = v;
        }
      }
    }));
  }
  return result;
}
function tryOnMounted(fn, sync = true) {
  if (getCurrentInstance2())
    onMounted2(fn);
  else if (sync)
    fn();
  else
    nextTick(fn);
}

// node_modules/@vueuse/core/index.mjs
import { isRef as isRef2, ref as ref3, shallowRef as shallowRef3, watchEffect as watchEffect3, computed as computed3, inject as inject3, isVue3 as isVue32, version as version2, defineComponent as defineComponent2, h as h2, TransitionGroup, shallowReactive, Fragment as Fragment2, watch as watch3, getCurrentInstance as getCurrentInstance3, customRef as customRef2, onUpdated, onMounted as onMounted3, readonly as readonly3, nextTick as nextTick2, reactive as reactive3, markRaw, getCurrentScope as getCurrentScope2, isVue2 as isVue22, set, del, isReadonly, onBeforeUpdate } from "vue-demi";
function unrefElement(elRef) {
  var _a;
  const plain = toValue(elRef);
  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;
}
var defaultWindow = isClient ? window : void 0;
var defaultDocument = isClient ? window.document : void 0;
var defaultNavigator = isClient ? window.navigator : void 0;
var defaultLocation = isClient ? window.location : void 0;
function useEventListener(...args) {
  let target;
  let events;
  let listeners;
  let options;
  if (typeof args[0] === "string" || Array.isArray(args[0])) {
    [events, listeners, options] = args;
    target = defaultWindow;
  } else {
    [target, events, listeners, options] = args;
  }
  if (!target)
    return noop;
  if (!Array.isArray(events))
    events = [events];
  if (!Array.isArray(listeners))
    listeners = [listeners];
  const cleanups = [];
  const cleanup = () => {
    cleanups.forEach((fn) => fn());
    cleanups.length = 0;
  };
  const register = (el, event, listener, options2) => {
    el.addEventListener(event, listener, options2);
    return () => el.removeEventListener(event, listener, options2);
  };
  const stopWatch = watch3(
    () => [unrefElement(target), toValue(options)],
    ([el, options2]) => {
      cleanup();
      if (!el)
        return;
      const optionsClone = isObject(options2) ? { ...options2 } : options2;
      cleanups.push(
        ...events.flatMap((event) => {
          return listeners.map((listener) => register(el, event, listener, optionsClone));
        })
      );
    },
    { immediate: true, flush: "post" }
  );
  const stop = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(stop);
  return stop;
}
function useMounted() {
  const isMounted = ref3(false);
  if (getCurrentInstance3()) {
    onMounted3(() => {
      isMounted.value = true;
    });
  }
  return isMounted;
}
function useSupported(callback) {
  const isMounted = useMounted();
  return computed3(() => {
    isMounted.value;
    return Boolean(callback());
  });
}
function useRafFn(fn, options = {}) {
  const {
    immediate = true,
    window: window2 = defaultWindow
  } = options;
  const isActive = ref3(false);
  let previousFrameTimestamp = 0;
  let rafId = null;
  function loop(timestamp2) {
    if (!isActive.value || !window2)
      return;
    const delta = timestamp2 - (previousFrameTimestamp || timestamp2);
    fn({ delta, timestamp: timestamp2 });
    previousFrameTimestamp = timestamp2;
    rafId = window2.requestAnimationFrame(loop);
  }
  function resume() {
    if (!isActive.value && window2) {
      isActive.value = true;
      rafId = window2.requestAnimationFrame(loop);
    }
  }
  function pause() {
    isActive.value = false;
    if (rafId != null && window2) {
      window2.cancelAnimationFrame(rafId);
      rafId = null;
    }
  }
  if (immediate)
    resume();
  tryOnScopeDispose(pause);
  return {
    isActive: readonly3(isActive),
    pause,
    resume
  };
}
function useMediaQuery(query, options = {}) {
  const { window: window2 = defaultWindow } = options;
  const isSupported = useSupported(() => window2 && "matchMedia" in window2 && typeof window2.matchMedia === "function");
  let mediaQuery;
  const matches = ref3(false);
  const handler = (event) => {
    matches.value = event.matches;
  };
  const cleanup = () => {
    if (!mediaQuery)
      return;
    if ("removeEventListener" in mediaQuery)
      mediaQuery.removeEventListener("change", handler);
    else
      mediaQuery.removeListener(handler);
  };
  const stopWatch = watchEffect3(() => {
    if (!isSupported.value)
      return;
    cleanup();
    mediaQuery = window2.matchMedia(toValue(query));
    if ("addEventListener" in mediaQuery)
      mediaQuery.addEventListener("change", handler);
    else
      mediaQuery.addListener(handler);
    matches.value = mediaQuery.matches;
  });
  tryOnScopeDispose(() => {
    stopWatch();
    cleanup();
    mediaQuery = void 0;
  });
  return matches;
}
var _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var globalKey = "__vueuse_ssr_handlers__";
var handlers = getHandlers();
function getHandlers() {
  if (!(globalKey in _global))
    _global[globalKey] = _global[globalKey] || {};
  return _global[globalKey];
}
function useDevicePixelRatio({
  window: window2 = defaultWindow
} = {}) {
  const pixelRatio = ref3(1);
  if (window2) {
    let observe = function() {
      pixelRatio.value = window2.devicePixelRatio;
      cleanup();
      media = window2.matchMedia(`(resolution: ${pixelRatio.value}dppx)`);
      media.addEventListener("change", observe, { once: true });
    }, cleanup = function() {
      media == null ? void 0 : media.removeEventListener("change", observe);
    };
    let media;
    observe();
    tryOnScopeDispose(cleanup);
  }
  return { pixelRatio };
}
function useResizeObserver(target, callback, options = {}) {
  const { window: window2 = defaultWindow, ...observerOptions } = options;
  let observer;
  const isSupported = useSupported(() => window2 && "ResizeObserver" in window2);
  const cleanup = () => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  };
  const targets = computed3(
    () => Array.isArray(target) ? target.map((el) => unrefElement(el)) : [unrefElement(target)]
  );
  const stopWatch = watch3(
    targets,
    (els) => {
      cleanup();
      if (isSupported.value && window2) {
        observer = new ResizeObserver(callback);
        for (const _el of els)
          _el && observer.observe(_el, observerOptions);
      }
    },
    { immediate: true, flush: "post", deep: true }
  );
  const stop = () => {
    cleanup();
    stopWatch();
  };
  tryOnScopeDispose(stop);
  return {
    isSupported,
    stop
  };
}
function useElementBounding(target, options = {}) {
  const {
    reset = true,
    windowResize = true,
    windowScroll = true,
    immediate = true
  } = options;
  const height = ref3(0);
  const bottom = ref3(0);
  const left = ref3(0);
  const right = ref3(0);
  const top = ref3(0);
  const width = ref3(0);
  const x2 = ref3(0);
  const y = ref3(0);
  function update() {
    const el = unrefElement(target);
    if (!el) {
      if (reset) {
        height.value = 0;
        bottom.value = 0;
        left.value = 0;
        right.value = 0;
        top.value = 0;
        width.value = 0;
        x2.value = 0;
        y.value = 0;
      }
      return;
    }
    const rect = el.getBoundingClientRect();
    height.value = rect.height;
    bottom.value = rect.bottom;
    left.value = rect.left;
    right.value = rect.right;
    top.value = rect.top;
    width.value = rect.width;
    x2.value = rect.x;
    y.value = rect.y;
  }
  useResizeObserver(target, update);
  watch3(() => unrefElement(target), (ele) => !ele && update());
  if (windowScroll)
    useEventListener("scroll", update, { capture: true, passive: true });
  if (windowResize)
    useEventListener("resize", update, { passive: true });
  tryOnMounted(() => {
    if (immediate)
      update();
  });
  return {
    height,
    bottom,
    left,
    right,
    top,
    width,
    x: x2,
    y,
    update
  };
}
function useElementSize(target, initialSize = { width: 0, height: 0 }, options = {}) {
  const { window: window2 = defaultWindow, box = "content-box" } = options;
  const isSVG = computed3(() => {
    var _a, _b;
    return (_b = (_a = unrefElement(target)) == null ? void 0 : _a.namespaceURI) == null ? void 0 : _b.includes("svg");
  });
  const width = ref3(initialSize.width);
  const height = ref3(initialSize.height);
  useResizeObserver(
    target,
    ([entry]) => {
      const boxSize = box === "border-box" ? entry.borderBoxSize : box === "content-box" ? entry.contentBoxSize : entry.devicePixelContentBoxSize;
      if (window2 && isSVG.value) {
        const $elem = unrefElement(target);
        if ($elem) {
          const styles = window2.getComputedStyle($elem);
          width.value = Number.parseFloat(styles.width);
          height.value = Number.parseFloat(styles.height);
        }
      } else {
        if (boxSize) {
          const formatBoxSize = Array.isArray(boxSize) ? boxSize : [boxSize];
          width.value = formatBoxSize.reduce((acc, { inlineSize }) => acc + inlineSize, 0);
          height.value = formatBoxSize.reduce((acc, { blockSize }) => acc + blockSize, 0);
        } else {
          width.value = entry.contentRect.width;
          height.value = entry.contentRect.height;
        }
      }
    },
    options
  );
  watch3(
    () => unrefElement(target),
    (ele) => {
      width.value = ele ? initialSize.width : 0;
      height.value = ele ? initialSize.height : 0;
    }
  );
  return {
    width,
    height
  };
}
var defaultState = {
  x: 0,
  y: 0,
  pointerId: 0,
  pressure: 0,
  tiltX: 0,
  tiltY: 0,
  width: 0,
  height: 0,
  twist: 0,
  pointerType: null
};
var keys = Object.keys(defaultState);
function usePointer(options = {}) {
  const {
    target = defaultWindow
  } = options;
  const isInside = ref3(false);
  const state = ref3(options.initialValue || {});
  Object.assign(state.value, defaultState, state.value);
  const handler = (event) => {
    isInside.value = true;
    if (options.pointerTypes && !options.pointerTypes.includes(event.pointerType))
      return;
    state.value = objectPick(event, keys, false);
  };
  if (target) {
    const listenerOptions = { passive: true };
    useEventListener(target, ["pointerdown", "pointermove", "pointerup"], handler, listenerOptions);
    useEventListener(target, "pointerleave", () => isInside.value = false, listenerOptions);
  }
  return {
    ...toRefs(state),
    isInside
  };
}
var DEFAULT_UNITS = [
  { max: 6e4, value: 1e3, name: "second" },
  { max: 276e4, value: 6e4, name: "minute" },
  { max: 72e6, value: 36e5, name: "hour" },
  { max: 5184e5, value: 864e5, name: "day" },
  { max: 24192e5, value: 6048e5, name: "week" },
  { max: 28512e6, value: 2592e6, name: "month" },
  { max: Number.POSITIVE_INFINITY, value: 31536e6, name: "year" }
];
var _TransitionPresets = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
var TransitionPresets = Object.assign({}, { linear: identity }, _TransitionPresets);
function useWindowSize(options = {}) {
  const {
    window: window2 = defaultWindow,
    initialWidth = Number.POSITIVE_INFINITY,
    initialHeight = Number.POSITIVE_INFINITY,
    listenOrientation = true,
    includeScrollbar = true
  } = options;
  const width = ref3(initialWidth);
  const height = ref3(initialHeight);
  const update = () => {
    if (window2) {
      if (includeScrollbar) {
        width.value = window2.innerWidth;
        height.value = window2.innerHeight;
      } else {
        width.value = window2.document.documentElement.clientWidth;
        height.value = window2.document.documentElement.clientHeight;
      }
    }
  };
  update();
  tryOnMounted(update);
  useEventListener("resize", update, { passive: true });
  if (listenOrientation) {
    const matches = useMediaQuery("(orientation: portrait)");
    watch3(matches, () => update());
  }
  return { width, height };
}

// node_modules/@tresjs/core/dist/tres.js
var Ge = ({ sizes: e, scene: n }) => {
  const t = ref([]), r = computed(
    () => t.value[0]
  ), a = (i, c = false) => {
    t.value.some(({ uuid: u }) => u === i.uuid) || (c ? f(i) : t.value.push(i));
  }, o = (i) => {
    t.value = t.value.filter(({ uuid: c }) => c !== i.uuid);
  }, f = (i) => {
    const c = i instanceof Camera ? i : t.value.find((m) => m.uuid === i);
    if (!c)
      return;
    const u = t.value.filter(({ uuid: m }) => m !== c.uuid);
    t.value = [c, ...u];
  };
  return watchEffect(() => {
    e.aspectRatio.value && t.value.forEach((i) => {
      i instanceof PerspectiveCamera && (i.aspect = e.aspectRatio.value), (i instanceof PerspectiveCamera || i instanceof OrthographicCamera) && i.updateProjectionMatrix();
    });
  }), n.userData.tres__registerCamera = a, n.userData.tres__deregisterCamera = o, onUnmounted(() => {
    t.value = [];
  }), {
    camera: r,
    cameras: t,
    registerCamera: a,
    deregisterCamera: o,
    setCameraActive: f
  };
};
var re = createEventHook();
var ne = createEventHook();
var V = createEventHook();
var x = new Clock();
var j = 0;
var H = 0;
var { pause: Ie, resume: We, isActive: $e } = useRafFn(
  () => {
    re.trigger({ delta: j, elapsed: H, clock: x }), ne.trigger({ delta: j, elapsed: H, clock: x }), V.trigger({ delta: j, elapsed: H, clock: x });
  },
  { immediate: false }
);
V.on(() => {
  j = x.getDelta(), H = x.getElapsedTime();
});
var ae = () => ({
  onBeforeLoop: re.on,
  onLoop: ne.on,
  onAfterLoop: V.on,
  pause: Ie,
  resume: We,
  isActive: $e
});
var pt = true;
var X = "[TresJS ▲ ■ ●] ";
function L() {
  function e(r, a) {
    console.error(`${X} ${r}`, a || "");
  }
  function n(r) {
    console.warn(`${X} ${r}`);
  }
  function t(r, a) {
  }
  return {
    logError: e,
    logWarning: n,
    logMessage: t
  };
}
function vt(e) {
  return typeof e == "number" ? [e, e, e] : e instanceof Vector3 ? [e.x, e.y, e.z] : e;
}
function Ne(e) {
  return e instanceof Color ? e : Array.isArray(e) ? new Color(...e) : new Color(e);
}
var oe = (e, n) => {
  for (const t of Object.keys(n))
    n[t] instanceof Object && Object.assign(n[t], oe(e[t], n[t]));
  return Object.assign(e || {}, n), e;
};
var Ve = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
var qe = Ue(Ve);
function Y(e) {
  return e && e.nodeType === 1;
}
function h3(e) {
  return e.replace(/-([a-z])/g, (n, t) => t.toUpperCase());
}
function Ue(e, n) {
  const t = /* @__PURE__ */ Object.create(null), r = e.split(",");
  for (let a = 0; a < r.length; a++)
    t[r[a]] = true;
  return n ? (a) => !!t[a.toLowerCase()] : (a) => !!t[a];
}
var Je = (e, n) => {
  const t = /* @__PURE__ */ new Set(), r = [];
  for (const a of e) {
    const o = n(a);
    t.has(o) || (t.add(o), r.push(a));
  }
  return r;
};
var Q = (e, n) => {
  if (!n)
    return;
  const t = Array.isArray(n) ? n : n.match(/([^[.\]])+/g);
  return t == null ? void 0 : t.reduce((r, a) => r && r[a], e);
};
var Ke = (e, n, t) => {
  const r = Array.isArray(n) ? n : n.match(/([^[.\]])+/g);
  r && r.reduce((a, o, f) => (a[o] === void 0 && (a[o] = {}), f === r.length - 1 && (a[o] = t), a[o]), e);
};
function se(e, n) {
  if (Y(e) && Y(n)) {
    const a = e.attributes, o = n.attributes;
    return a.length !== o.length ? false : Array.from(a).every(({ name: f, value: i }) => n.getAttribute(f) === i);
  }
  if (e === n)
    return true;
  if (e === null || typeof e != "object" || n === null || typeof n != "object")
    return false;
  const t = Object.keys(e), r = Object.keys(n);
  if (t.length !== r.length)
    return false;
  for (const a of t)
    if (!r.includes(a) || !se(e[a], n[a]))
      return false;
  return true;
}
function Xe(e, n) {
  if (!Array.isArray(e) || !Array.isArray(n) || e.length !== n.length)
    return false;
  for (let t = 0; t < e.length; t++)
    if (!se(e[t], n[t]))
      return false;
  return true;
}
var Ye = Number.parseInt(REVISION.replace("dev", ""));
var S = {
  realistic: {
    outputColorSpace: SRGBColorSpace,
    toneMapping: ACESFilmicToneMapping,
    toneMappingExposure: 3,
    shadowMap: {
      enabled: true,
      type: PCFSoftShadowMap
    }
  }
};
function Qe({
  scene: e,
  canvas: n,
  options: t,
  disableRender: r,
  contextParts: { sizes: a, camera: o }
}) {
  const f = computed(() => ({
    alpha: toValue(t.alpha),
    depth: toValue(t.depth),
    canvas: unrefElement(n),
    context: toValue(t.context),
    stencil: toValue(t.stencil),
    antialias: toValue(t.antialias) === void 0 ? true : toValue(t.antialias),
    precision: toValue(t.precision),
    powerPreference: toValue(t.powerPreference),
    premultipliedAlpha: toValue(t.premultipliedAlpha),
    preserveDrawingBuffer: toValue(t.preserveDrawingBuffer),
    logarithmicDepthBuffer: toValue(t.logarithmicDepthBuffer),
    failIfMajorPerformanceCaveat: toValue(t.failIfMajorPerformanceCaveat)
  })), i = shallowRef(new WebGLRenderer(f.value));
  watch(f, () => {
    i.value.dispose(), i.value = new WebGLRenderer(f.value);
  }), watchEffect(() => {
    i.value.setSize(a.width.value, a.height.value);
  });
  const { pixelRatio: c } = useDevicePixelRatio();
  watchEffect(() => {
    i.value.setPixelRatio(c.value);
  });
  const { logError: u } = L(), l = (() => {
    const g = new WebGLRenderer(), w = {
      shadowMap: {
        enabled: g.shadowMap.enabled,
        type: g.shadowMap.type
      },
      toneMapping: g.toneMapping,
      toneMappingExposure: g.toneMappingExposure,
      outputColorSpace: g.outputColorSpace
    };
    return g.dispose(), w;
  })();
  watchEffect(() => {
    const g = toValue(t.preset);
    g && (g in S || u(`Renderer Preset must be one of these: ${Object.keys(S).join(", ")}`), oe(i.value, S[g]));
    const w = (_, A) => {
      const b = toValue(_), T = () => {
        if (g)
          return Q(S[g], A);
      };
      if (b !== void 0)
        return b;
      const d = T();
      return d !== void 0 ? d : Q(l, A);
    }, E = (_, A) => Ke(i.value, A, w(_, A));
    E(t.shadows, "shadowMap.enabled"), E(t.toneMapping, "toneMapping"), E(t.shadowMapType, "shadowMap.type"), Ye < 150 && E(!t.useLegacyLights, "physicallyCorrectLights"), E(t.outputColorSpace, "outputColorSpace"), E(t.toneMappingExposure, "toneMappingExposure");
    const C = w(t.clearColor, "clearColor");
    C && i.value.setClearColor(
      C ? Ne(C) : new Color(0)
      // default clear color is not easily/efficiently retrievable from three
    );
  });
  const { pause: s, resume: v, onLoop: y } = ae();
  return y(() => {
    o.value && !toValue(r) && i.value.render(e, o.value);
  }), v(), onUnmounted(() => {
    s(), i.value.dispose(), i.value.forceContextLoss();
  }), {
    renderer: i
  };
}
var Z = (e) => typeof e == "function";
var ie = (e) => !!e && e.constructor === Array;
function Ze(e) {
  const n = { nodes: {}, materials: {} };
  return e && e.traverse((t) => {
    t.name && (n.nodes[t.name] = t), t.material && !n.materials[t.material.name] && (n.materials[t.material.name] = t.material);
  }), n;
}
async function gt(e, n, t, r, a) {
  const { logError: o } = L(), f = new e();
  a && a(f), t && t(f);
  const c = (Array.isArray(n) ? n : [n]).map(
    (u) => new Promise((m, l) => {
      f.load(
        u,
        (s) => {
          s.scene && Object.assign(s, Ze(s.scene)), m(s);
        },
        r,
        (s) => l(o("[useLoader] - Failed to load resource", s))
      );
    })
  );
  return ie(n) ? await Promise.all(c) : await c[0];
}
async function dt(e) {
  const n = new LoadingManager(), t = new TextureLoader(n), r = (a) => new Promise((o, f) => {
    t.load(
      a,
      (i) => o(i),
      () => null,
      () => {
        f(new Error("[useTextures] - Failed to load texture"));
      }
    );
  });
  if (ie(e)) {
    const a = await Promise.all(e.map((o) => r(o)));
    return e.length > 1 ? a : a[0];
  } else {
    const {
      map: a,
      displacementMap: o,
      normalMap: f,
      roughnessMap: i,
      metalnessMap: c,
      aoMap: u,
      alphaMap: m,
      matcap: l
    } = e;
    return {
      map: a ? await r(a) : null,
      displacementMap: o ? await r(o) : null,
      normalMap: f ? await r(f) : null,
      roughnessMap: i ? await r(i) : null,
      metalnessMap: c ? await r(c) : null,
      aoMap: u ? await r(u) : null,
      alphaMap: m ? await r(m) : null,
      matcap: l ? await r(l) : null
    };
  }
}
var et = (e, { renderer: n, camera: t, raycaster: r }) => {
  const a = computed(() => n.value.domElement), { x: o, y: f } = usePointer({ target: a }), { width: i, height: c, top: u, left: m } = useElementBounding(a), l = ({ x: d, y: M }) => {
    if (a.value)
      return {
        x: (d - m.value) / i.value * 2 - 1,
        y: -((M - u.value) / c.value) * 2 + 1
      };
  }, s = ({ x: d, y: M }) => {
    if (t.value)
      return r.value.setFromCamera(new Vector2(d, M), t.value), r.value.intersectObjects(e.value, false);
  }, v = (d) => {
    const M = l({
      x: (d == null ? void 0 : d.clientX) ?? o.value,
      y: (d == null ? void 0 : d.clientY) ?? f.value
    });
    return M ? s(M) || [] : [];
  }, y = computed(() => v()), g = createEventHook(), w = createEventHook(), E = (d, M) => {
    d.trigger({ event: M, intersects: v(M) });
  }, C = (d) => {
    E(w, d);
  };
  let _;
  const A = (d) => {
    var M;
    _ = (M = v(d)[0]) == null ? void 0 : M.object;
  }, b = (d) => {
    var M;
    d instanceof PointerEvent && _ === ((M = v(d)[0]) == null ? void 0 : M.object) && E(g, d);
  }, T = (d) => w.trigger({ event: d, intersects: [] });
  return a.value.addEventListener("pointerup", b), a.value.addEventListener("pointerdown", A), a.value.addEventListener("pointermove", C), a.value.addEventListener("pointerleave", T), onUnmounted(() => {
    a != null && a.value && (a.value.removeEventListener("pointerup", b), a.value.removeEventListener("pointerdown", A), a.value.removeEventListener("pointermove", C), a.value.removeEventListener("pointerleave", T));
  }), {
    intersects: y,
    onClick: (d) => g.on(d).off,
    onPointerMove: (d) => w.on(d).off
  };
};
function yt() {
  const { logWarning: e } = L();
  function n(r, a, o) {
    let f = null;
    return r.traverse((i) => {
      i[a] === o && (f = i);
    }), f || e(`Child with ${a} '${o}' not found.`), f;
  }
  function t(r, a) {
    return n(r, "name", a);
  }
  return {
    seek: n,
    seekByName: t
  };
}
var tt = ({ scene: e, contextParts: n }) => {
  const t = reactive({
    click: /* @__PURE__ */ new Map(),
    pointerMove: /* @__PURE__ */ new Map(),
    pointerEnter: /* @__PURE__ */ new Map(),
    pointerLeave: /* @__PURE__ */ new Map()
  }), r = ref(/* @__PURE__ */ new Set()), a = (s) => {
    r.value.add(s);
  }, o = (s) => {
    r.value.delete(s);
  }, f = (s) => {
    Object.values(t).forEach((v) => v.delete(s)), o(s);
  }, i = (s) => {
    const { onClick: v, onPointerMove: y, onPointerEnter: g, onPointerLeave: w } = s;
    v && t.click.set(s, v), y && t.pointerMove.set(s, y), g && t.pointerEnter.set(s, g), w && t.pointerLeave.set(s, w);
  };
  e.userData.tres__registerAtPointerEventHandler = i, e.userData.tres__deregisterAtPointerEventHandler = f, e.userData.tres__registerBlockingObjectAtPointerEventHandler = a, e.userData.tres__deregisterBlockingObjectAtPointerEventHandler = o;
  const c = computed(
    () => Je(
      [
        ...Array.from(r.value),
        ...Object.values(t).map((s) => Array.from(s.keys())).flat()
      ],
      ({ uuid: s }) => s
    )
  ), { onClick: u, onPointerMove: m } = et(c, n);
  u(({ intersects: s, event: v }) => {
    var y;
    s.length && ((y = t.click.get(s[0].object)) == null || y(s[0], v));
  });
  let l;
  return m(({ intersects: s, event: v }) => {
    var C, _, A, b;
    const y = (C = s == null ? void 0 : s[0]) == null ? void 0 : C.object, { pointerLeave: g, pointerEnter: w, pointerMove: E } = t;
    l && l !== y && ((_ = g.get(l)) == null || _(l, v)), y && (l !== y && ((A = w.get(y)) == null || A(s[0], v)), (b = E.get(y)) == null || b(s[0], v)), l = y || null;
  }), {
    registerObject: i,
    deregisterObject: f
  };
};
var $ = ref({});
var q = (e) => Object.assign($.value, e);
function rt({
  scene: e,
  canvas: n,
  windowSize: t,
  disableRender: r,
  rendererOptions: a
}) {
  const o = computed(
    () => toValue(t) ? useWindowSize() : useElementSize(toValue(n).parentElement)
  ), f = computed(() => o.value.width.value), i = computed(() => o.value.height.value), c = computed(() => f.value / i.value), u = {
    height: i,
    width: f,
    aspectRatio: c
  }, m = shallowRef(e), {
    camera: l,
    cameras: s,
    registerCamera: v,
    deregisterCamera: y,
    setCameraActive: g
  } = Ge({ sizes: u, scene: e }), { renderer: w } = Qe(
    {
      scene: e,
      canvas: n,
      options: a,
      contextParts: { sizes: u, camera: l },
      disableRender: r
    }
  ), E = {
    sizes: u,
    scene: m,
    camera: l,
    cameras: readonly(s),
    renderer: w,
    raycaster: shallowRef(new Raycaster()),
    controls: ref(null),
    extend: q,
    registerCamera: v,
    setCameraActive: g,
    deregisterCamera: y
  };
  return provide("useTres", E), E;
}
function nt() {
  const e = inject("useTres");
  if (!e)
    throw new Error("useTresContext must be used together with useTresContextProvider");
  return e;
}
var wt = nt;
var G = null;
var p = null;
var { logError: ee } = L();
var at = {
  createElement(e, n, t, r) {
    var f, i;
    if (r || (r = {}), r.args || (r.args = []), e === "template" || qe(e))
      return null;
    let a = e.replace("Tres", ""), o;
    if (e === "primitive") {
      (r == null ? void 0 : r.object) === void 0 && ee("Tres primitives need a prop 'object'");
      const c = r.object;
      a = c.type, o = Object.assign(c, { type: a, attach: r.attach, primitive: true });
    } else {
      const c = $.value[a];
      c || ee(`${a} is not defined on the THREE namespace. Use extend to add it to the catalog.`), o = new c(...r.args);
    }
    return o.isCamera && (r != null && r.position || o.position.set(3, 3, 3), r != null && r.lookAt || o.lookAt(0, 0, 0)), (r == null ? void 0 : r.attach) === void 0 && (o.isMaterial ? o.attach = "material" : o.isBufferGeometry && (o.attach = "geometry")), o.isObject3D && ((f = r == null ? void 0 : r.material) != null && f.isMaterial && (o.userData.tres__materialViaProp = true), (i = r == null ? void 0 : r.geometry) != null && i.isBufferGeometry && (o.userData.tres__geometryViaProp = true)), o.userData = {
      ...o.userData,
      tres__name: a
    }, o;
  },
  insert(e, n) {
    var t, r, a, o, f, i, c, u, m, l;
    if (n && n.isScene && (p = n), (((t = e == null ? void 0 : e.__vnode) == null ? void 0 : t.type) === "TresGroup" || ((r = e == null ? void 0 : e.__vnode) == null ? void 0 : r.type) === "TresObject3D") && n === null && !((o = (a = e == null ? void 0 : e.__vnode) == null ? void 0 : a.ctx) != null && o.asyncResolved)) {
      G = e;
      return;
    } else
      n === null && ((f = e == null ? void 0 : e.__vnode) != null && f.type.includes("Controls") || (i = e == null ? void 0 : e.__vnode) != null && i.type.includes("Helper")) && (G = p);
    if (n || (n = G), e != null && e.isObject3D) {
      if (e != null && e.isCamera) {
        if (!(p != null && p.userData.tres__registerCamera))
          throw "could not find tres__registerCamera on scene's userData";
        (u = p == null ? void 0 : (c = p.userData).tres__registerCamera) == null || u.call(c, e);
      }
      if (e != null && e.onClick || e != null && e.onPointerMove || e != null && e.onPointerEnter || e != null && e.onPointerLeave) {
        if (!(p != null && p.userData.tres__registerAtPointerEventHandler))
          throw "could not find tres__registerAtPointerEventHandler on scene's userData";
        (l = p == null ? void 0 : (m = p.userData).tres__registerAtPointerEventHandler) == null || l.call(m, e);
      }
    }
    e != null && e.isObject3D && (n != null && n.isObject3D) ? (n.add(e), e.dispatchEvent({ type: "added" })) : e != null && e.isFog ? n.fog = e : typeof (e == null ? void 0 : e.attach) == "string" && (e.__previousAttach = e[n == null ? void 0 : n.attach], n && (n[e.attach] = e));
  },
  remove(e) {
    var n, t;
    if (e) {
      if (e.isObject3D) {
        const r = e, a = (u) => {
          var l, s;
          const m = u;
          u.userData.tres__materialViaProp || (l = m.material) == null || l.dispose(), u.userData.tres__geometryViaProp || (s = m.geometry) == null || s.dispose();
        }, o = p == null ? void 0 : p.userData.tres__deregisterAtPointerEventHandler, f = p == null ? void 0 : p.userData.tres__deregisterBlockingObjectAtPointerEventHandler, i = (u) => {
          var m, l;
          if (!f)
            throw "could not find tres__deregisterBlockingObjectAtPointerEventHandler on scene's userData";
          if ((l = p == null ? void 0 : (m = p.userData).tres__deregisterBlockingObjectAtPointerEventHandler) == null || l.call(m, u), !o)
            throw "could not find tres__deregisterAtPointerEventHandler on scene's userData";
          (u != null && u.onClick || u != null && u.onPointerMove || u != null && u.onPointerEnter || u != null && u.onPointerLeave) && (o == null || o(u));
        }, c = (u) => {
          const m = p == null ? void 0 : p.userData.tres__deregisterCamera;
          if (!m)
            throw "could not find tres__deregisterCamera on scene's userData";
          u.isCamera && (m == null || m(u));
        };
        r.traverse((u) => {
          a(u), c(u), i == null || i(u);
        }), a(r), c(r), i == null || i(r);
      }
      (n = e.removeFromParent) == null || n.call(e), (t = e.dispose) == null || t.call(e);
    }
  },
  patchProp(e, n, t, r) {
    var a, o, f, i;
    if (e) {
      let c = e, u = n;
      if (e.isObject3D && u === "blocks-pointer-events") {
        r || r === "" ? (o = p == null ? void 0 : (a = p.userData).tres__registerBlockingObjectAtPointerEventHandler) == null || o.call(a, e) : (i = p == null ? void 0 : (f = p.userData).tres__deregisterBlockingObjectAtPointerEventHandler) == null || i.call(f, e);
        return;
      }
      let m = h3(u), l = c == null ? void 0 : c[m];
      if (u === "args") {
        const v = e, y = t ?? [], g = r ?? [], w = e.userData.tres__name || e.type;
        w && y.length && !Xe(y, g) && (c = Object.assign(v, new $.value[w](...r)));
        return;
      }
      if (c.type === "BufferGeometry") {
        if (u === "args")
          return;
        c.setAttribute(
          h3(u),
          new BufferAttribute(...r)
        );
        return;
      }
      if (u.includes("-") && l === void 0) {
        const v = u.split("-");
        l = v.reduce((y, g) => y[h3(g)], c), u = v.pop(), m = u.toLowerCase(), l != null && l.set || (c = v.reduce((y, g) => y[h3(g)], c));
      }
      let s = r;
      if (s === "" && (s = true), Z(l)) {
        Array.isArray(s) ? e[m](...s) : e[m](s);
        return;
      }
      !(l != null && l.set) && !Z(l) ? c[m] = s : l.constructor === s.constructor && (l != null && l.copy) ? l == null || l.copy(s) : Array.isArray(s) ? l.set(...s) : !l.isColor && l.setScalar ? l.setScalar(s) : l.set(s);
    }
  },
  parentNode(e) {
    return (e == null ? void 0 : e.parent) || null;
  },
  createText: () => void 0,
  createComment: () => void 0,
  setText: () => void 0,
  setElementText: () => void 0,
  nextSibling: () => void 0,
  querySelector: () => void 0,
  setScopeId: () => void 0,
  cloneNode: () => void 0,
  insertStaticContent: () => void 0
};
var { render: ot } = createRenderer(at);
q(three_module_exports);
var st = ["data-scene"];
var it = defineComponent({
  __name: "TresCanvas",
  props: {
    shadows: { type: Boolean, default: void 0 },
    clearColor: {},
    toneMapping: {},
    shadowMapType: {},
    useLegacyLights: { type: Boolean, default: void 0 },
    outputColorSpace: {},
    toneMappingExposure: {},
    camera: {},
    preset: {},
    windowSize: { type: Boolean, default: void 0 },
    disableRender: { type: Boolean, default: void 0 },
    context: {},
    precision: {},
    alpha: { type: Boolean, default: void 0 },
    premultipliedAlpha: { type: Boolean },
    antialias: { type: Boolean, default: void 0 },
    stencil: { type: Boolean, default: void 0 },
    preserveDrawingBuffer: { type: Boolean, default: void 0 },
    powerPreference: {},
    depth: { type: Boolean, default: void 0 },
    logarithmicDepthBuffer: { type: Boolean, default: void 0 },
    failIfMajorPerformanceCaveat: { type: Boolean, default: void 0 }
  },
  setup(e) {
    var m;
    const n = e, { logWarning: t } = L(), r = ref(), a = shallowRef(new Scene());
    ae();
    const o = useSlots(), f = (m = getCurrentInstance()) == null ? void 0 : m.appContext.app, i = (l) => defineComponent({
      setup() {
        var v;
        const s = (v = getCurrentInstance()) == null ? void 0 : v.appContext;
        return s && (s.app = f), provide("useTres", l), provide("extend", q), () => h(Fragment, null, o != null && o.default ? o.default() : []);
      }
    }), c = (l) => {
      const s = i(l);
      ot(h(s), a.value);
    }, u = computed(() => n.disableRender);
    return onMounted(() => {
      const l = r, s = rt({
        scene: a.value,
        canvas: l,
        windowSize: n.windowSize,
        disableRender: u,
        rendererOptions: n
      });
      tt({ scene: a.value, contextParts: s });
      const { registerCamera: v, camera: y, cameras: g, deregisterCamera: w } = s;
      c(s);
      const E = () => {
        const C = new PerspectiveCamera(
          45,
          window.innerWidth / window.innerHeight,
          0.1,
          1e3
        );
        C.position.set(3, 3, 3), C.lookAt(0, 0, 0), v(C);
        const _ = watchEffect(() => {
          g.value.length >= 2 && (C.removeFromParent(), w(C), _ == null || _());
        });
      };
      watch(
        () => n.camera,
        (C, _) => {
          C && v(C), _ && (_.removeFromParent(), w(_));
        },
        {
          immediate: true
        }
      ), y.value || (t(
        "No camera found. Creating a default perspective camera. To have full control over a camera, please add one to the scene."
      ), E());
    }), (l, s) => (openBlock(), createElementBlock("canvas", {
      ref_key: "canvas",
      ref: r,
      "data-scene": a.value.uuid,
      style: normalizeStyle({
        display: "block",
        width: "100%",
        height: "100%",
        position: l.windowSize ? "fixed" : "relative",
        top: 0,
        left: 0,
        pointerEvents: "auto",
        touchAction: "none"
      })
    }, null, 12, st));
  }
});
var ut = [
  "TresCanvas",
  "TresLeches",
  "TresScene"
];
var lt = {
  template: {
    compilerOptions: {
      isCustomElement: (e) => e.startsWith("Tres") && !ut.includes(e) || e === "primitive"
    }
  }
};
var Ct = lt;
var _t = {
  install(e) {
    e.component("TresCanvas", it);
  }
};

export {
  Ge,
  ae,
  pt,
  L,
  vt,
  Ne,
  Qe,
  Ze,
  gt,
  dt,
  et,
  yt,
  tt,
  $,
  q,
  rt,
  nt,
  wt,
  it,
  Ct,
  _t
};
//# sourceMappingURL=chunk-HEBOWBWL.js.map
