import {
  L,
  ae,
  dt,
  gt,
  nt
} from "./chunk-HEBOWBWL.js";
import {
  Fragment,
  computed,
  createBaseVNode,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createVNode,
  defineComponent,
  getCurrentInstance,
  getCurrentScope,
  guardReactiveProps,
  mergeProps,
  nextTick,
  normalizeProps,
  onMounted,
  onScopeDispose,
  onUnmounted,
  openBlock,
  reactive,
  ref,
  renderList,
  renderSlot,
  resolveComponent,
  shallowReactive,
  shallowRef,
  toRefs,
  toValue,
  unref,
  useSlots,
  watch,
  watchEffect,
  withAsyncContext
} from "./chunk-RAKT47ZN.js";
import {
  AmbientLight,
  AnimationClip,
  AnimationMixer,
  Bone,
  Box2,
  Box3,
  BoxGeometry,
  BufferAttribute,
  BufferGeometry,
  ClampToEdgeWrapping,
  Color,
  CubeReflectionMapping,
  CubeTextureLoader,
  Curve,
  CylinderGeometry,
  DataTextureLoader,
  DataUtils,
  DefaultLoadingManager,
  DirectionalLight,
  DoubleSide,
  EquirectangularReflectionMapping,
  Euler,
  EventDispatcher,
  ExtrudeGeometry,
  FileLoader,
  Float32BufferAttribute,
  FloatType,
  FrontSide,
  Group,
  HalfFloatType,
  ImageBitmapLoader,
  InstancedMesh,
  InterleavedBuffer,
  InterleavedBufferAttribute,
  Interpolant,
  InterpolateDiscrete,
  InterpolateLinear,
  Line,
  LineBasicMaterial,
  LineLoop,
  LineSegments,
  LinearFilter,
  LinearMipmapLinearFilter,
  LinearMipmapNearestFilter,
  Loader,
  LoaderUtils,
  MOUSE,
  Material,
  MathUtils,
  Matrix3,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  MeshDepthMaterial,
  MeshLambertMaterial,
  MeshPhongMaterial,
  MeshPhysicalMaterial,
  MeshStandardMaterial,
  MirroredRepeatWrapping,
  NearestFilter,
  NearestMipmapLinearFilter,
  NearestMipmapNearestFilter,
  NumberKeyframeTrack,
  Object3D,
  OctahedronGeometry,
  OrthographicCamera,
  Path,
  PerspectiveCamera,
  PlaneGeometry,
  PointLight,
  Points,
  PointsMaterial,
  PropertyBinding,
  QuadraticBezierCurve3,
  Quaternion,
  QuaternionKeyframeTrack,
  REVISION,
  Raycaster,
  RepeatWrapping,
  SRGBColorSpace,
  ShaderMaterial,
  Shape,
  ShapeGeometry,
  ShapePath,
  ShapeUtils,
  Skeleton,
  SkinnedMesh,
  Sphere,
  SphereGeometry,
  Spherical,
  SpotLight,
  TOUCH,
  Texture,
  TextureLoader,
  TorusGeometry,
  TriangleFanDrawMode,
  TriangleStripDrawMode,
  TrianglesDrawMode,
  Uint16BufferAttribute,
  Vector2,
  Vector3,
  Vector4,
  VectorKeyframeTrack,
  VideoTexture,
  WebGLRenderTarget
} from "./chunk-2E65YDO7.js";
import "./chunk-SSYGV25P.js";

// node_modules/tweakpane/dist/tweakpane.js
function forceCast(v) {
  return v;
}
function isEmpty(value) {
  return value === null || value === void 0;
}
function isObject$1(value) {
  return value !== null && typeof value === "object";
}
function isRecord(value) {
  return value !== null && typeof value === "object";
}
function deepEqualsArray(a1, a2) {
  if (a1.length !== a2.length) {
    return false;
  }
  for (let i = 0; i < a1.length; i++) {
    if (a1[i] !== a2[i]) {
      return false;
    }
  }
  return true;
}
function deepMerge(r1, r2) {
  const keys = Array.from(/* @__PURE__ */ new Set([...Object.keys(r1), ...Object.keys(r2)]));
  return keys.reduce((result, key) => {
    const v1 = r1[key];
    const v2 = r2[key];
    return isRecord(v1) && isRecord(v2) ? Object.assign(Object.assign({}, result), { [key]: deepMerge(v1, v2) }) : Object.assign(Object.assign({}, result), { [key]: key in r2 ? v2 : v1 });
  }, {});
}
function isBinding(value) {
  if (!isObject$1(value)) {
    return false;
  }
  return "target" in value;
}
var CREATE_MESSAGE_MAP = {
  alreadydisposed: () => "View has been already disposed",
  invalidparams: (context) => `Invalid parameters for '${context.name}'`,
  nomatchingcontroller: (context) => `No matching controller for '${context.key}'`,
  nomatchingview: (context) => `No matching view for '${JSON.stringify(context.params)}'`,
  notbindable: () => `Value is not bindable`,
  notcompatible: (context) => `Not compatible with  plugin '${context.id}'`,
  propertynotfound: (context) => `Property '${context.name}' not found`,
  shouldneverhappen: () => "This error should never happen"
};
var TpError = class _TpError {
  static alreadyDisposed() {
    return new _TpError({ type: "alreadydisposed" });
  }
  static notBindable() {
    return new _TpError({
      type: "notbindable"
    });
  }
  static notCompatible(bundleId, id) {
    return new _TpError({
      type: "notcompatible",
      context: {
        id: `${bundleId}.${id}`
      }
    });
  }
  static propertyNotFound(name) {
    return new _TpError({
      type: "propertynotfound",
      context: {
        name
      }
    });
  }
  static shouldNeverHappen() {
    return new _TpError({ type: "shouldneverhappen" });
  }
  constructor(config) {
    var _a2;
    this.message = (_a2 = CREATE_MESSAGE_MAP[config.type](forceCast(config.context))) !== null && _a2 !== void 0 ? _a2 : "Unexpected error";
    this.name = this.constructor.name;
    this.stack = new Error(this.message).stack;
    this.type = config.type;
  }
  toString() {
    return this.message;
  }
};
var BindingTarget = class _BindingTarget {
  constructor(obj, key) {
    this.obj_ = obj;
    this.key = key;
  }
  static isBindable(obj) {
    if (obj === null) {
      return false;
    }
    if (typeof obj !== "object" && typeof obj !== "function") {
      return false;
    }
    return true;
  }
  read() {
    return this.obj_[this.key];
  }
  write(value) {
    this.obj_[this.key] = value;
  }
  writeProperty(name, value) {
    const valueObj = this.read();
    if (!_BindingTarget.isBindable(valueObj)) {
      throw TpError.notBindable();
    }
    if (!(name in valueObj)) {
      throw TpError.propertyNotFound(name);
    }
    valueObj[name] = value;
  }
};
var Emitter = class {
  constructor() {
    this.observers_ = {};
  }
  on(eventName, handler) {
    let observers = this.observers_[eventName];
    if (!observers) {
      observers = this.observers_[eventName] = [];
    }
    observers.push({
      handler
    });
    return this;
  }
  off(eventName, handler) {
    const observers = this.observers_[eventName];
    if (observers) {
      this.observers_[eventName] = observers.filter((observer) => {
        return observer.handler !== handler;
      });
    }
    return this;
  }
  emit(eventName, event) {
    const observers = this.observers_[eventName];
    if (!observers) {
      return;
    }
    observers.forEach((observer) => {
      observer.handler(event);
    });
  }
};
var ComplexValue = class {
  constructor(initialValue, config) {
    var _a2;
    this.constraint_ = config === null || config === void 0 ? void 0 : config.constraint;
    this.equals_ = (_a2 = config === null || config === void 0 ? void 0 : config.equals) !== null && _a2 !== void 0 ? _a2 : (v1, v2) => v1 === v2;
    this.emitter = new Emitter();
    this.rawValue_ = initialValue;
  }
  get constraint() {
    return this.constraint_;
  }
  get rawValue() {
    return this.rawValue_;
  }
  set rawValue(rawValue) {
    this.setRawValue(rawValue, {
      forceEmit: false,
      last: true
    });
  }
  setRawValue(rawValue, options) {
    const opts = options !== null && options !== void 0 ? options : {
      forceEmit: false,
      last: true
    };
    const constrainedValue = this.constraint_ ? this.constraint_.constrain(rawValue) : rawValue;
    const prevValue = this.rawValue_;
    const changed = !this.equals_(prevValue, constrainedValue);
    if (!changed && !opts.forceEmit) {
      return;
    }
    this.emitter.emit("beforechange", {
      sender: this
    });
    this.rawValue_ = constrainedValue;
    this.emitter.emit("change", {
      options: opts,
      previousRawValue: prevValue,
      rawValue: constrainedValue,
      sender: this
    });
  }
};
var PrimitiveValue = class {
  constructor(initialValue) {
    this.emitter = new Emitter();
    this.value_ = initialValue;
  }
  get rawValue() {
    return this.value_;
  }
  set rawValue(value) {
    this.setRawValue(value, {
      forceEmit: false,
      last: true
    });
  }
  setRawValue(value, options) {
    const opts = options !== null && options !== void 0 ? options : {
      forceEmit: false,
      last: true
    };
    const prevValue = this.value_;
    if (prevValue === value && !opts.forceEmit) {
      return;
    }
    this.emitter.emit("beforechange", {
      sender: this
    });
    this.value_ = value;
    this.emitter.emit("change", {
      options: opts,
      previousRawValue: prevValue,
      rawValue: this.value_,
      sender: this
    });
  }
};
var ReadonlyPrimitiveValue = class {
  constructor(value) {
    this.emitter = new Emitter();
    this.onValueBeforeChange_ = this.onValueBeforeChange_.bind(this);
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.value_ = value;
    this.value_.emitter.on("beforechange", this.onValueBeforeChange_);
    this.value_.emitter.on("change", this.onValueChange_);
  }
  get rawValue() {
    return this.value_.rawValue;
  }
  onValueBeforeChange_(ev) {
    this.emitter.emit("beforechange", Object.assign(Object.assign({}, ev), { sender: this }));
  }
  onValueChange_(ev) {
    this.emitter.emit("change", Object.assign(Object.assign({}, ev), { sender: this }));
  }
};
function createValue(initialValue, config) {
  const constraint = config === null || config === void 0 ? void 0 : config.constraint;
  const equals = config === null || config === void 0 ? void 0 : config.equals;
  if (!constraint && !equals) {
    return new PrimitiveValue(initialValue);
  }
  return new ComplexValue(initialValue, config);
}
function createReadonlyValue(value) {
  return [
    new ReadonlyPrimitiveValue(value),
    (rawValue, options) => {
      value.setRawValue(rawValue, options);
    }
  ];
}
var ValueMap = class _ValueMap {
  constructor(valueMap) {
    this.emitter = new Emitter();
    this.valMap_ = valueMap;
    for (const key in this.valMap_) {
      const v = this.valMap_[key];
      v.emitter.on("change", () => {
        this.emitter.emit("change", {
          key,
          sender: this
        });
      });
    }
  }
  static createCore(initialValue) {
    const keys = Object.keys(initialValue);
    return keys.reduce((o, key) => {
      return Object.assign(o, {
        [key]: createValue(initialValue[key])
      });
    }, {});
  }
  static fromObject(initialValue) {
    const core = this.createCore(initialValue);
    return new _ValueMap(core);
  }
  get(key) {
    return this.valMap_[key].rawValue;
  }
  set(key, value) {
    this.valMap_[key].rawValue = value;
  }
  value(key) {
    return this.valMap_[key];
  }
};
var DefiniteRangeConstraint = class {
  constructor(config) {
    this.values = ValueMap.fromObject({
      max: config.max,
      min: config.min
    });
  }
  constrain(value) {
    const max = this.values.get("max");
    const min = this.values.get("min");
    return Math.min(Math.max(value, min), max);
  }
};
var RangeConstraint = class {
  constructor(config) {
    this.values = ValueMap.fromObject({
      max: config.max,
      min: config.min
    });
  }
  constrain(value) {
    const max = this.values.get("max");
    const min = this.values.get("min");
    let result = value;
    if (!isEmpty(min)) {
      result = Math.max(result, min);
    }
    if (!isEmpty(max)) {
      result = Math.min(result, max);
    }
    return result;
  }
};
var StepConstraint = class {
  constructor(step, origin = 0) {
    this.step = step;
    this.origin = origin;
  }
  constrain(value) {
    const o = this.origin % this.step;
    const r = Math.round((value - o) / this.step);
    return o + r * this.step;
  }
};
var NumberLiteralNode = class {
  constructor(text) {
    this.text = text;
  }
  evaluate() {
    return Number(this.text);
  }
  toString() {
    return this.text;
  }
};
var BINARY_OPERATION_MAP = {
  "**": (v1, v2) => Math.pow(v1, v2),
  "*": (v1, v2) => v1 * v2,
  "/": (v1, v2) => v1 / v2,
  "%": (v1, v2) => v1 % v2,
  "+": (v1, v2) => v1 + v2,
  "-": (v1, v2) => v1 - v2,
  "<<": (v1, v2) => v1 << v2,
  ">>": (v1, v2) => v1 >> v2,
  ">>>": (v1, v2) => v1 >>> v2,
  "&": (v1, v2) => v1 & v2,
  "^": (v1, v2) => v1 ^ v2,
  "|": (v1, v2) => v1 | v2
};
var BinaryOperationNode = class {
  constructor(operator, left, right) {
    this.left = left;
    this.operator = operator;
    this.right = right;
  }
  evaluate() {
    const op = BINARY_OPERATION_MAP[this.operator];
    if (!op) {
      throw new Error(`unexpected binary operator: '${this.operator}`);
    }
    return op(this.left.evaluate(), this.right.evaluate());
  }
  toString() {
    return [
      "b(",
      this.left.toString(),
      this.operator,
      this.right.toString(),
      ")"
    ].join(" ");
  }
};
var UNARY_OPERATION_MAP = {
  "+": (v) => v,
  "-": (v) => -v,
  "~": (v) => ~v
};
var UnaryOperationNode = class {
  constructor(operator, expr) {
    this.operator = operator;
    this.expression = expr;
  }
  evaluate() {
    const op = UNARY_OPERATION_MAP[this.operator];
    if (!op) {
      throw new Error(`unexpected unary operator: '${this.operator}`);
    }
    return op(this.expression.evaluate());
  }
  toString() {
    return ["u(", this.operator, this.expression.toString(), ")"].join(" ");
  }
};
function combineReader(parsers) {
  return (text, cursor) => {
    for (let i = 0; i < parsers.length; i++) {
      const result = parsers[i](text, cursor);
      if (result !== "") {
        return result;
      }
    }
    return "";
  };
}
function readWhitespace(text, cursor) {
  var _a2;
  const m = text.substr(cursor).match(/^\s+/);
  return (_a2 = m && m[0]) !== null && _a2 !== void 0 ? _a2 : "";
}
function readNonZeroDigit(text, cursor) {
  const ch = text.substr(cursor, 1);
  return ch.match(/^[1-9]$/) ? ch : "";
}
function readDecimalDigits(text, cursor) {
  var _a2;
  const m = text.substr(cursor).match(/^[0-9]+/);
  return (_a2 = m && m[0]) !== null && _a2 !== void 0 ? _a2 : "";
}
function readSignedInteger(text, cursor) {
  const ds = readDecimalDigits(text, cursor);
  if (ds !== "") {
    return ds;
  }
  const sign = text.substr(cursor, 1);
  cursor += 1;
  if (sign !== "-" && sign !== "+") {
    return "";
  }
  const sds = readDecimalDigits(text, cursor);
  if (sds === "") {
    return "";
  }
  return sign + sds;
}
function readExponentPart(text, cursor) {
  const e = text.substr(cursor, 1);
  cursor += 1;
  if (e.toLowerCase() !== "e") {
    return "";
  }
  const si2 = readSignedInteger(text, cursor);
  if (si2 === "") {
    return "";
  }
  return e + si2;
}
function readDecimalIntegerLiteral(text, cursor) {
  const ch = text.substr(cursor, 1);
  if (ch === "0") {
    return ch;
  }
  const nzd = readNonZeroDigit(text, cursor);
  cursor += nzd.length;
  if (nzd === "") {
    return "";
  }
  return nzd + readDecimalDigits(text, cursor);
}
function readDecimalLiteral1(text, cursor) {
  const dil = readDecimalIntegerLiteral(text, cursor);
  cursor += dil.length;
  if (dil === "") {
    return "";
  }
  const dot = text.substr(cursor, 1);
  cursor += dot.length;
  if (dot !== ".") {
    return "";
  }
  const dds = readDecimalDigits(text, cursor);
  cursor += dds.length;
  return dil + dot + dds + readExponentPart(text, cursor);
}
function readDecimalLiteral2(text, cursor) {
  const dot = text.substr(cursor, 1);
  cursor += dot.length;
  if (dot !== ".") {
    return "";
  }
  const dds = readDecimalDigits(text, cursor);
  cursor += dds.length;
  if (dds === "") {
    return "";
  }
  return dot + dds + readExponentPart(text, cursor);
}
function readDecimalLiteral3(text, cursor) {
  const dil = readDecimalIntegerLiteral(text, cursor);
  cursor += dil.length;
  if (dil === "") {
    return "";
  }
  return dil + readExponentPart(text, cursor);
}
var readDecimalLiteral = combineReader([
  readDecimalLiteral1,
  readDecimalLiteral2,
  readDecimalLiteral3
]);
function parseBinaryDigits(text, cursor) {
  var _a2;
  const m = text.substr(cursor).match(/^[01]+/);
  return (_a2 = m && m[0]) !== null && _a2 !== void 0 ? _a2 : "";
}
function readBinaryIntegerLiteral(text, cursor) {
  const prefix = text.substr(cursor, 2);
  cursor += prefix.length;
  if (prefix.toLowerCase() !== "0b") {
    return "";
  }
  const bds = parseBinaryDigits(text, cursor);
  if (bds === "") {
    return "";
  }
  return prefix + bds;
}
function readOctalDigits(text, cursor) {
  var _a2;
  const m = text.substr(cursor).match(/^[0-7]+/);
  return (_a2 = m && m[0]) !== null && _a2 !== void 0 ? _a2 : "";
}
function readOctalIntegerLiteral(text, cursor) {
  const prefix = text.substr(cursor, 2);
  cursor += prefix.length;
  if (prefix.toLowerCase() !== "0o") {
    return "";
  }
  const ods = readOctalDigits(text, cursor);
  if (ods === "") {
    return "";
  }
  return prefix + ods;
}
function readHexDigits(text, cursor) {
  var _a2;
  const m = text.substr(cursor).match(/^[0-9a-f]+/i);
  return (_a2 = m && m[0]) !== null && _a2 !== void 0 ? _a2 : "";
}
function readHexIntegerLiteral(text, cursor) {
  const prefix = text.substr(cursor, 2);
  cursor += prefix.length;
  if (prefix.toLowerCase() !== "0x") {
    return "";
  }
  const hds = readHexDigits(text, cursor);
  if (hds === "") {
    return "";
  }
  return prefix + hds;
}
var readNonDecimalIntegerLiteral = combineReader([
  readBinaryIntegerLiteral,
  readOctalIntegerLiteral,
  readHexIntegerLiteral
]);
var readNumericLiteral = combineReader([
  readNonDecimalIntegerLiteral,
  readDecimalLiteral
]);
function parseLiteral(text, cursor) {
  const num = readNumericLiteral(text, cursor);
  cursor += num.length;
  if (num === "") {
    return null;
  }
  return {
    evaluable: new NumberLiteralNode(num),
    cursor
  };
}
function parseParenthesizedExpression(text, cursor) {
  const op = text.substr(cursor, 1);
  cursor += op.length;
  if (op !== "(") {
    return null;
  }
  const expr = parseExpression(text, cursor);
  if (!expr) {
    return null;
  }
  cursor = expr.cursor;
  cursor += readWhitespace(text, cursor).length;
  const cl2 = text.substr(cursor, 1);
  cursor += cl2.length;
  if (cl2 !== ")") {
    return null;
  }
  return {
    evaluable: expr.evaluable,
    cursor
  };
}
function parsePrimaryExpression(text, cursor) {
  var _a2;
  return (_a2 = parseLiteral(text, cursor)) !== null && _a2 !== void 0 ? _a2 : parseParenthesizedExpression(text, cursor);
}
function parseUnaryExpression(text, cursor) {
  const expr = parsePrimaryExpression(text, cursor);
  if (expr) {
    return expr;
  }
  const op = text.substr(cursor, 1);
  cursor += op.length;
  if (op !== "+" && op !== "-" && op !== "~") {
    return null;
  }
  const num = parseUnaryExpression(text, cursor);
  if (!num) {
    return null;
  }
  cursor = num.cursor;
  return {
    cursor,
    evaluable: new UnaryOperationNode(op, num.evaluable)
  };
}
function readBinaryOperator(ops, text, cursor) {
  cursor += readWhitespace(text, cursor).length;
  const op = ops.filter((op2) => text.startsWith(op2, cursor))[0];
  if (!op) {
    return null;
  }
  cursor += op.length;
  cursor += readWhitespace(text, cursor).length;
  return {
    cursor,
    operator: op
  };
}
function createBinaryOperationExpressionParser(exprParser, ops) {
  return (text, cursor) => {
    const firstExpr = exprParser(text, cursor);
    if (!firstExpr) {
      return null;
    }
    cursor = firstExpr.cursor;
    let expr = firstExpr.evaluable;
    for (; ; ) {
      const op = readBinaryOperator(ops, text, cursor);
      if (!op) {
        break;
      }
      cursor = op.cursor;
      const nextExpr = exprParser(text, cursor);
      if (!nextExpr) {
        return null;
      }
      cursor = nextExpr.cursor;
      expr = new BinaryOperationNode(op.operator, expr, nextExpr.evaluable);
    }
    return expr ? {
      cursor,
      evaluable: expr
    } : null;
  };
}
var parseBinaryOperationExpression = [
  ["**"],
  ["*", "/", "%"],
  ["+", "-"],
  ["<<", ">>>", ">>"],
  ["&"],
  ["^"],
  ["|"]
].reduce((parser, ops) => {
  return createBinaryOperationExpressionParser(parser, ops);
}, parseUnaryExpression);
function parseExpression(text, cursor) {
  cursor += readWhitespace(text, cursor).length;
  return parseBinaryOperationExpression(text, cursor);
}
function parseEcmaNumberExpression(text) {
  const expr = parseExpression(text, 0);
  if (!expr) {
    return null;
  }
  const cursor = expr.cursor + readWhitespace(text, expr.cursor).length;
  if (cursor !== text.length) {
    return null;
  }
  return expr.evaluable;
}
function parseNumber(text) {
  var _a2;
  const r = parseEcmaNumberExpression(text);
  return (_a2 = r === null || r === void 0 ? void 0 : r.evaluate()) !== null && _a2 !== void 0 ? _a2 : null;
}
function numberFromUnknown(value) {
  if (typeof value === "number") {
    return value;
  }
  if (typeof value === "string") {
    const pv = parseNumber(value);
    if (!isEmpty(pv)) {
      return pv;
    }
  }
  return 0;
}
function numberToString(value) {
  return String(value);
}
function createNumberFormatter(digits) {
  return (value) => {
    return value.toFixed(Math.max(Math.min(digits, 20), 0));
  };
}
function mapRange(value, start1, end1, start2, end2) {
  const p = (value - start1) / (end1 - start1);
  return start2 + p * (end2 - start2);
}
function getDecimalDigits(value) {
  const text = String(value.toFixed(10));
  const frac = text.split(".")[1];
  return frac.replace(/0+$/, "").length;
}
function constrainRange(value, min, max) {
  return Math.min(Math.max(value, min), max);
}
function loopRange(value, max) {
  return (value % max + max) % max;
}
function getSuitableDecimalDigits(params, rawValue) {
  return !isEmpty(params.step) ? getDecimalDigits(params.step) : Math.max(getDecimalDigits(rawValue), 2);
}
function getSuitableKeyScale(params) {
  var _a2;
  return (_a2 = params.step) !== null && _a2 !== void 0 ? _a2 : 1;
}
function getSuitablePointerScale(params, rawValue) {
  var _a2;
  const base = Math.abs((_a2 = params.step) !== null && _a2 !== void 0 ? _a2 : rawValue);
  return base === 0 ? 0.1 : Math.pow(10, Math.floor(Math.log10(base)) - 1);
}
function createStepConstraint(params, initialValue) {
  if (!isEmpty(params.step)) {
    return new StepConstraint(params.step, initialValue);
  }
  return null;
}
function createRangeConstraint(params) {
  if (!isEmpty(params.max) && !isEmpty(params.min)) {
    return new DefiniteRangeConstraint({
      max: params.max,
      min: params.min
    });
  }
  if (!isEmpty(params.max) || !isEmpty(params.min)) {
    return new RangeConstraint({
      max: params.max,
      min: params.min
    });
  }
  return null;
}
function createNumberTextPropsObject(params, initialValue) {
  var _a2, _b, _c2;
  return {
    formatter: (_a2 = params.format) !== null && _a2 !== void 0 ? _a2 : createNumberFormatter(getSuitableDecimalDigits(params, initialValue)),
    keyScale: (_b = params.keyScale) !== null && _b !== void 0 ? _b : getSuitableKeyScale(params),
    pointerScale: (_c2 = params.pointerScale) !== null && _c2 !== void 0 ? _c2 : getSuitablePointerScale(params, initialValue)
  };
}
function createNumberTextInputParamsParser(p) {
  return {
    format: p.optional.function,
    keyScale: p.optional.number,
    max: p.optional.number,
    min: p.optional.number,
    pointerScale: p.optional.number,
    step: p.optional.number
  };
}
function createPointAxis(config) {
  return {
    constraint: config.constraint,
    textProps: ValueMap.fromObject(createNumberTextPropsObject(config.params, config.initialValue))
  };
}
var BladeApi = class {
  constructor(controller) {
    this.controller = controller;
  }
  get element() {
    return this.controller.view.element;
  }
  get disabled() {
    return this.controller.viewProps.get("disabled");
  }
  set disabled(disabled) {
    this.controller.viewProps.set("disabled", disabled);
  }
  get hidden() {
    return this.controller.viewProps.get("hidden");
  }
  set hidden(hidden) {
    this.controller.viewProps.set("hidden", hidden);
  }
  dispose() {
    this.controller.viewProps.set("disposed", true);
  }
  importState(state) {
    return this.controller.importState(state);
  }
  exportState() {
    return this.controller.exportState();
  }
};
var TpEvent = class {
  constructor(target) {
    this.target = target;
  }
};
var TpChangeEvent = class extends TpEvent {
  constructor(target, value, last) {
    super(target);
    this.value = value;
    this.last = last !== null && last !== void 0 ? last : true;
  }
};
var TpFoldEvent = class extends TpEvent {
  constructor(target, expanded) {
    super(target);
    this.expanded = expanded;
  }
};
var TpTabSelectEvent = class extends TpEvent {
  constructor(target, index) {
    super(target);
    this.index = index;
  }
};
var BindingApi = class extends BladeApi {
  constructor(controller) {
    super(controller);
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.emitter_ = new Emitter();
    this.controller.value.emitter.on("change", this.onValueChange_);
  }
  get label() {
    return this.controller.labelController.props.get("label");
  }
  set label(label) {
    this.controller.labelController.props.set("label", label);
  }
  get key() {
    return this.controller.value.binding.target.key;
  }
  get tag() {
    return this.controller.tag;
  }
  set tag(tag) {
    this.controller.tag = tag;
  }
  on(eventName, handler) {
    const bh = handler.bind(this);
    this.emitter_.on(eventName, (ev) => {
      bh(ev);
    });
    return this;
  }
  refresh() {
    this.controller.value.fetch();
  }
  onValueChange_(ev) {
    const value = this.controller.value;
    this.emitter_.emit("change", new TpChangeEvent(this, forceCast(value.binding.target.read()), ev.options.last));
  }
};
var InputBindingValue = class {
  constructor(value, binding) {
    this.onValueBeforeChange_ = this.onValueBeforeChange_.bind(this);
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.binding = binding;
    this.value_ = value;
    this.value_.emitter.on("beforechange", this.onValueBeforeChange_);
    this.value_.emitter.on("change", this.onValueChange_);
    this.emitter = new Emitter();
  }
  get rawValue() {
    return this.value_.rawValue;
  }
  set rawValue(rawValue) {
    this.value_.rawValue = rawValue;
  }
  setRawValue(rawValue, options) {
    this.value_.setRawValue(rawValue, options);
  }
  fetch() {
    this.value_.rawValue = this.binding.read();
  }
  push() {
    this.binding.write(this.value_.rawValue);
  }
  onValueBeforeChange_(ev) {
    this.emitter.emit("beforechange", Object.assign(Object.assign({}, ev), { sender: this }));
  }
  onValueChange_(ev) {
    this.push();
    this.emitter.emit("change", Object.assign(Object.assign({}, ev), { sender: this }));
  }
};
function isInputBindingValue(v) {
  if (!("binding" in v)) {
    return false;
  }
  const b = v["binding"];
  return isBinding(b) && "read" in b && "write" in b;
}
function parseObject(value, keyToParserMap) {
  const keys = Object.keys(keyToParserMap);
  const result = keys.reduce((tmp, key) => {
    if (tmp === void 0) {
      return void 0;
    }
    const parser = keyToParserMap[key];
    const result2 = parser(value[key]);
    return result2.succeeded ? Object.assign(Object.assign({}, tmp), { [key]: result2.value }) : void 0;
  }, {});
  return forceCast(result);
}
function parseArray(value, parseItem) {
  return value.reduce((tmp, item) => {
    if (tmp === void 0) {
      return void 0;
    }
    const result = parseItem(item);
    if (!result.succeeded || result.value === void 0) {
      return void 0;
    }
    return [...tmp, result.value];
  }, []);
}
function isObject(value) {
  if (value === null) {
    return false;
  }
  return typeof value === "object";
}
function createMicroParserBuilder(parse) {
  return (optional) => (v) => {
    if (!optional && v === void 0) {
      return {
        succeeded: false,
        value: void 0
      };
    }
    if (optional && v === void 0) {
      return {
        succeeded: true,
        value: void 0
      };
    }
    const result = parse(v);
    return result !== void 0 ? {
      succeeded: true,
      value: result
    } : {
      succeeded: false,
      value: void 0
    };
  };
}
function createMicroParserBuilders(optional) {
  return {
    custom: (parse) => createMicroParserBuilder(parse)(optional),
    boolean: createMicroParserBuilder((v) => typeof v === "boolean" ? v : void 0)(optional),
    number: createMicroParserBuilder((v) => typeof v === "number" ? v : void 0)(optional),
    string: createMicroParserBuilder((v) => typeof v === "string" ? v : void 0)(optional),
    function: createMicroParserBuilder((v) => typeof v === "function" ? v : void 0)(optional),
    constant: (value) => createMicroParserBuilder((v) => v === value ? value : void 0)(optional),
    raw: createMicroParserBuilder((v) => v)(optional),
    object: (keyToParserMap) => createMicroParserBuilder((v) => {
      if (!isObject(v)) {
        return void 0;
      }
      return parseObject(v, keyToParserMap);
    })(optional),
    array: (itemParser) => createMicroParserBuilder((v) => {
      if (!Array.isArray(v)) {
        return void 0;
      }
      return parseArray(v, itemParser);
    })(optional)
  };
}
var MicroParsers = {
  optional: createMicroParserBuilders(true),
  required: createMicroParserBuilders(false)
};
function parseRecord(value, keyToParserMap) {
  const map = keyToParserMap(MicroParsers);
  const result = MicroParsers.required.object(map)(value);
  return result.succeeded ? result.value : void 0;
}
function importBladeState(state, superImport, parser, callback) {
  if (superImport && !superImport(state)) {
    return false;
  }
  const result = parseRecord(state, parser);
  return result ? callback(result) : false;
}
function exportBladeState(superExport, thisState) {
  var _a2;
  return deepMerge((_a2 = superExport === null || superExport === void 0 ? void 0 : superExport()) !== null && _a2 !== void 0 ? _a2 : {}, thisState);
}
function isValueBladeController(bc2) {
  return "value" in bc2;
}
function isBindingValue(v) {
  if (!isObject$1(v) || !("binding" in v)) {
    return false;
  }
  const b = v.binding;
  return isBinding(b);
}
var SVG_NS = "http://www.w3.org/2000/svg";
function forceReflow(element) {
  element.offsetHeight;
}
function disableTransitionTemporarily(element, callback) {
  const t = element.style.transition;
  element.style.transition = "none";
  callback();
  element.style.transition = t;
}
function supportsTouch(doc) {
  return doc.ontouchstart !== void 0;
}
function getGlobalObject() {
  return globalThis;
}
function getWindowDocument() {
  const globalObj = forceCast(getGlobalObject());
  return globalObj.document;
}
function getCanvasContext(canvasElement) {
  const win = canvasElement.ownerDocument.defaultView;
  if (!win) {
    return null;
  }
  const isBrowser = "document" in win;
  return isBrowser ? canvasElement.getContext("2d", {
    willReadFrequently: true
  }) : null;
}
var ICON_ID_TO_INNER_HTML_MAP = {
  check: '<path d="M2 8l4 4l8 -8"/>',
  dropdown: '<path d="M5 7h6l-3 3 z"/>',
  p2dpad: '<path d="M8 4v8"/><path d="M4 8h8"/><circle cx="12" cy="12" r="1.2"/>'
};
function createSvgIconElement(document2, iconId) {
  const elem = document2.createElementNS(SVG_NS, "svg");
  elem.innerHTML = ICON_ID_TO_INNER_HTML_MAP[iconId];
  return elem;
}
function insertElementAt(parentElement, element, index) {
  parentElement.insertBefore(element, parentElement.children[index]);
}
function removeElement(element) {
  if (element.parentElement) {
    element.parentElement.removeChild(element);
  }
}
function removeChildElements(element) {
  while (element.children.length > 0) {
    element.removeChild(element.children[0]);
  }
}
function removeChildNodes(element) {
  while (element.childNodes.length > 0) {
    element.removeChild(element.childNodes[0]);
  }
}
function findNextTarget(ev) {
  if (ev.relatedTarget) {
    return forceCast(ev.relatedTarget);
  }
  if ("explicitOriginalTarget" in ev) {
    return ev.explicitOriginalTarget;
  }
  return null;
}
function bindValue(value, applyValue) {
  value.emitter.on("change", (ev) => {
    applyValue(ev.rawValue);
  });
  applyValue(value.rawValue);
}
function bindValueMap(valueMap, key, applyValue) {
  bindValue(valueMap.value(key), applyValue);
}
var PREFIX = "tp";
function ClassName(viewName) {
  const fn2 = (opt_elementName, opt_modifier) => {
    return [
      PREFIX,
      "-",
      viewName,
      "v",
      opt_elementName ? `_${opt_elementName}` : "",
      opt_modifier ? `-${opt_modifier}` : ""
    ].join("");
  };
  return fn2;
}
var cn$r = ClassName("lbl");
function createLabelNode(doc, label) {
  const frag = doc.createDocumentFragment();
  const lineNodes = label.split("\n").map((line) => {
    return doc.createTextNode(line);
  });
  lineNodes.forEach((lineNode, index) => {
    if (index > 0) {
      frag.appendChild(doc.createElement("br"));
    }
    frag.appendChild(lineNode);
  });
  return frag;
}
var LabelView = class {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$r());
    config.viewProps.bindClassModifiers(this.element);
    const labelElem = doc.createElement("div");
    labelElem.classList.add(cn$r("l"));
    bindValueMap(config.props, "label", (value) => {
      if (isEmpty(value)) {
        this.element.classList.add(cn$r(void 0, "nol"));
      } else {
        this.element.classList.remove(cn$r(void 0, "nol"));
        removeChildNodes(labelElem);
        labelElem.appendChild(createLabelNode(doc, value));
      }
    });
    this.element.appendChild(labelElem);
    this.labelElement = labelElem;
    const valueElem = doc.createElement("div");
    valueElem.classList.add(cn$r("v"));
    this.element.appendChild(valueElem);
    this.valueElement = valueElem;
  }
};
var LabelController = class {
  constructor(doc, config) {
    this.props = config.props;
    this.valueController = config.valueController;
    this.viewProps = config.valueController.viewProps;
    this.view = new LabelView(doc, {
      props: config.props,
      viewProps: this.viewProps
    });
    this.view.valueElement.appendChild(this.valueController.view.element);
  }
  importProps(state) {
    return importBladeState(state, null, (p) => ({
      label: p.optional.string
    }), (result) => {
      this.props.set("label", result.label);
      return true;
    });
  }
  exportProps() {
    return exportBladeState(null, {
      label: this.props.get("label")
    });
  }
};
function getAllBladePositions() {
  return ["veryfirst", "first", "last", "verylast"];
}
var cn$q = ClassName("");
var POS_TO_CLASS_NAME_MAP = {
  veryfirst: "vfst",
  first: "fst",
  last: "lst",
  verylast: "vlst"
};
var BladeController = class {
  constructor(config) {
    this.parent_ = null;
    this.blade = config.blade;
    this.view = config.view;
    this.viewProps = config.viewProps;
    const elem = this.view.element;
    this.blade.value("positions").emitter.on("change", () => {
      getAllBladePositions().forEach((pos) => {
        elem.classList.remove(cn$q(void 0, POS_TO_CLASS_NAME_MAP[pos]));
      });
      this.blade.get("positions").forEach((pos) => {
        elem.classList.add(cn$q(void 0, POS_TO_CLASS_NAME_MAP[pos]));
      });
    });
    this.viewProps.handleDispose(() => {
      removeElement(elem);
    });
  }
  get parent() {
    return this.parent_;
  }
  set parent(parent) {
    this.parent_ = parent;
    this.viewProps.set("parent", this.parent_ ? this.parent_.viewProps : null);
  }
  importState(state) {
    return importBladeState(state, null, (p) => ({
      disabled: p.required.boolean,
      hidden: p.required.boolean
    }), (result) => {
      this.viewProps.importState(result);
      return true;
    });
  }
  exportState() {
    return exportBladeState(null, Object.assign({}, this.viewProps.exportState()));
  }
};
var LabeledValueBladeController = class extends BladeController {
  constructor(doc, config) {
    if (config.value !== config.valueController.value) {
      throw TpError.shouldNeverHappen();
    }
    const viewProps = config.valueController.viewProps;
    const lc2 = new LabelController(doc, {
      blade: config.blade,
      props: config.props,
      valueController: config.valueController
    });
    super(Object.assign(Object.assign({}, config), { view: new LabelView(doc, {
      props: config.props,
      viewProps
    }), viewProps }));
    this.labelController = lc2;
    this.value = config.value;
    this.valueController = config.valueController;
    this.view.valueElement.appendChild(this.valueController.view.element);
  }
  importState(state) {
    return importBladeState(state, (s) => {
      var _a2, _b, _c2;
      return super.importState(s) && this.labelController.importProps(s) && ((_c2 = (_b = (_a2 = this.valueController).importProps) === null || _b === void 0 ? void 0 : _b.call(_a2, state)) !== null && _c2 !== void 0 ? _c2 : true);
    }, (p) => ({
      value: p.optional.raw
    }), (result) => {
      if (result.value) {
        this.value.rawValue = result.value;
      }
      return true;
    });
  }
  exportState() {
    var _a2, _b, _c2;
    return exportBladeState(() => super.exportState(), Object.assign(Object.assign({ value: this.value.rawValue }, this.labelController.exportProps()), (_c2 = (_b = (_a2 = this.valueController).exportProps) === null || _b === void 0 ? void 0 : _b.call(_a2)) !== null && _c2 !== void 0 ? _c2 : {}));
  }
};
function excludeValue(state) {
  const result = Object.assign({}, state);
  delete result.value;
  return result;
}
var BindingController = class extends LabeledValueBladeController {
  constructor(doc, config) {
    super(doc, config);
    this.tag = config.tag;
  }
  importState(state) {
    return importBladeState(
      state,
      (_s) => super.importState(excludeValue(state)),
      (p) => ({
        tag: p.optional.string
      }),
      (result) => {
        this.tag = result.tag;
        return true;
      }
    );
  }
  exportState() {
    return exportBladeState(() => excludeValue(super.exportState()), {
      binding: {
        key: this.value.binding.target.key,
        value: this.value.binding.target.read()
      },
      tag: this.tag
    });
  }
};
function isBindingController(bc2) {
  return isValueBladeController(bc2) && isBindingValue(bc2.value);
}
var InputBindingController = class extends BindingController {
  importState(state) {
    return importBladeState(state, (s) => super.importState(s), (p) => ({
      binding: p.required.object({
        value: p.required.raw
      })
    }), (result) => {
      this.value.binding.inject(result.binding.value);
      this.value.fetch();
      return true;
    });
  }
};
function isInputBindingController(bc2) {
  return isValueBladeController(bc2) && isInputBindingValue(bc2.value);
}
function fillBuffer(buffer, bufferSize) {
  while (buffer.length < bufferSize) {
    buffer.push(void 0);
  }
}
function initializeBuffer(bufferSize) {
  const buffer = [];
  fillBuffer(buffer, bufferSize);
  return buffer;
}
function createTrimmedBuffer(buffer) {
  const index = buffer.indexOf(void 0);
  return forceCast(index < 0 ? buffer : buffer.slice(0, index));
}
function createPushedBuffer(buffer, newValue) {
  const newBuffer = [...createTrimmedBuffer(buffer), newValue];
  if (newBuffer.length > buffer.length) {
    newBuffer.splice(0, newBuffer.length - buffer.length);
  } else {
    fillBuffer(newBuffer, buffer.length);
  }
  return newBuffer;
}
var MonitorBindingValue = class {
  constructor(config) {
    this.emitter = new Emitter();
    this.onTick_ = this.onTick_.bind(this);
    this.onValueBeforeChange_ = this.onValueBeforeChange_.bind(this);
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.binding = config.binding;
    this.value_ = createValue(initializeBuffer(config.bufferSize));
    this.value_.emitter.on("beforechange", this.onValueBeforeChange_);
    this.value_.emitter.on("change", this.onValueChange_);
    this.ticker = config.ticker;
    this.ticker.emitter.on("tick", this.onTick_);
    this.fetch();
  }
  get rawValue() {
    return this.value_.rawValue;
  }
  set rawValue(rawValue) {
    this.value_.rawValue = rawValue;
  }
  setRawValue(rawValue, options) {
    this.value_.setRawValue(rawValue, options);
  }
  fetch() {
    this.value_.rawValue = createPushedBuffer(this.value_.rawValue, this.binding.read());
  }
  onTick_() {
    this.fetch();
  }
  onValueBeforeChange_(ev) {
    this.emitter.emit("beforechange", Object.assign(Object.assign({}, ev), { sender: this }));
  }
  onValueChange_(ev) {
    this.emitter.emit("change", Object.assign(Object.assign({}, ev), { sender: this }));
  }
};
function isMonitorBindingValue(v) {
  if (!("binding" in v)) {
    return false;
  }
  const b = v["binding"];
  return isBinding(b) && "read" in b && !("write" in b);
}
var MonitorBindingController = class extends BindingController {
  exportState() {
    return exportBladeState(() => super.exportState(), {
      binding: {
        readonly: true
      }
    });
  }
};
function isMonitorBindingController(bc2) {
  return isValueBladeController(bc2) && isMonitorBindingValue(bc2.value);
}
var ButtonApi = class extends BladeApi {
  get label() {
    return this.controller.labelController.props.get("label");
  }
  set label(label) {
    this.controller.labelController.props.set("label", label);
  }
  get title() {
    var _a2;
    return (_a2 = this.controller.buttonController.props.get("title")) !== null && _a2 !== void 0 ? _a2 : "";
  }
  set title(title) {
    this.controller.buttonController.props.set("title", title);
  }
  on(eventName, handler) {
    const bh = handler.bind(this);
    const emitter = this.controller.buttonController.emitter;
    emitter.on(eventName, () => {
      bh(new TpEvent(this));
    });
    return this;
  }
};
function applyClass(elem, className, active) {
  if (active) {
    elem.classList.add(className);
  } else {
    elem.classList.remove(className);
  }
}
function valueToClassName(elem, className) {
  return (value) => {
    applyClass(elem, className, value);
  };
}
function bindValueToTextContent(value, elem) {
  bindValue(value, (text) => {
    elem.textContent = text !== null && text !== void 0 ? text : "";
  });
}
var cn$p = ClassName("btn");
var ButtonView = class {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$p());
    config.viewProps.bindClassModifiers(this.element);
    const buttonElem = doc.createElement("button");
    buttonElem.classList.add(cn$p("b"));
    config.viewProps.bindDisabled(buttonElem);
    this.element.appendChild(buttonElem);
    this.buttonElement = buttonElem;
    const titleElem = doc.createElement("div");
    titleElem.classList.add(cn$p("t"));
    bindValueToTextContent(config.props.value("title"), titleElem);
    this.buttonElement.appendChild(titleElem);
  }
};
var ButtonController = class {
  constructor(doc, config) {
    this.emitter = new Emitter();
    this.onClick_ = this.onClick_.bind(this);
    this.props = config.props;
    this.viewProps = config.viewProps;
    this.view = new ButtonView(doc, {
      props: this.props,
      viewProps: this.viewProps
    });
    this.view.buttonElement.addEventListener("click", this.onClick_);
  }
  importProps(state) {
    return importBladeState(state, null, (p) => ({
      title: p.optional.string
    }), (result) => {
      this.props.set("title", result.title);
      return true;
    });
  }
  exportProps() {
    return exportBladeState(null, {
      title: this.props.get("title")
    });
  }
  onClick_() {
    this.emitter.emit("click", {
      sender: this
    });
  }
};
var ButtonBladeController = class extends BladeController {
  constructor(doc, config) {
    const bc2 = new ButtonController(doc, {
      props: config.buttonProps,
      viewProps: config.viewProps
    });
    const lc2 = new LabelController(doc, {
      blade: config.blade,
      props: config.labelProps,
      valueController: bc2
    });
    super({
      blade: config.blade,
      view: lc2.view,
      viewProps: config.viewProps
    });
    this.buttonController = bc2;
    this.labelController = lc2;
  }
  importState(state) {
    return importBladeState(state, (s) => super.importState(s) && this.buttonController.importProps(s) && this.labelController.importProps(s), () => ({}), () => true);
  }
  exportState() {
    return exportBladeState(() => super.exportState(), Object.assign(Object.assign({}, this.buttonController.exportProps()), this.labelController.exportProps()));
  }
};
var Semver = class {
  constructor(text) {
    const [core, prerelease] = text.split("-");
    const coreComps = core.split(".");
    this.major = parseInt(coreComps[0], 10);
    this.minor = parseInt(coreComps[1], 10);
    this.patch = parseInt(coreComps[2], 10);
    this.prerelease = prerelease !== null && prerelease !== void 0 ? prerelease : null;
  }
  toString() {
    const core = [this.major, this.minor, this.patch].join(".");
    return this.prerelease !== null ? [core, this.prerelease].join("-") : core;
  }
};
var VERSION$1 = new Semver("2.0.1");
function createPlugin(plugin) {
  return Object.assign({ core: VERSION$1 }, plugin);
}
var ButtonBladePlugin = createPlugin({
  id: "button",
  type: "blade",
  accept(params) {
    const result = parseRecord(params, (p) => ({
      title: p.required.string,
      view: p.required.constant("button"),
      label: p.optional.string
    }));
    return result ? { params: result } : null;
  },
  controller(args) {
    return new ButtonBladeController(args.document, {
      blade: args.blade,
      buttonProps: ValueMap.fromObject({
        title: args.params.title
      }),
      labelProps: ValueMap.fromObject({
        label: args.params.label
      }),
      viewProps: args.viewProps
    });
  },
  api(args) {
    if (args.controller instanceof ButtonBladeController) {
      return new ButtonApi(args.controller);
    }
    return null;
  }
});
function addButtonAsBlade(api, params) {
  return api.addBlade(Object.assign(Object.assign({}, params), { view: "button" }));
}
function addFolderAsBlade(api, params) {
  return api.addBlade(Object.assign(Object.assign({}, params), { view: "folder" }));
}
function addTabAsBlade(api, params) {
  return api.addBlade(Object.assign(Object.assign({}, params), { view: "tab" }));
}
function isRefreshable(value) {
  if (!isObject$1(value)) {
    return false;
  }
  return "refresh" in value && typeof value.refresh === "function";
}
function createBindingTarget(obj, key) {
  if (!BindingTarget.isBindable(obj)) {
    throw TpError.notBindable();
  }
  return new BindingTarget(obj, key);
}
var RackApi = class {
  constructor(controller, pool) {
    this.onRackValueChange_ = this.onRackValueChange_.bind(this);
    this.controller_ = controller;
    this.emitter_ = new Emitter();
    this.pool_ = pool;
    const rack = this.controller_.rack;
    rack.emitter.on("valuechange", this.onRackValueChange_);
  }
  get children() {
    return this.controller_.rack.children.map((bc2) => this.pool_.createApi(bc2));
  }
  addBinding(object, key, opt_params) {
    const params = opt_params !== null && opt_params !== void 0 ? opt_params : {};
    const doc = this.controller_.element.ownerDocument;
    const bc2 = this.pool_.createBinding(doc, createBindingTarget(object, key), params);
    const api = this.pool_.createBindingApi(bc2);
    return this.add(api, params.index);
  }
  addFolder(params) {
    return addFolderAsBlade(this, params);
  }
  addButton(params) {
    return addButtonAsBlade(this, params);
  }
  addTab(params) {
    return addTabAsBlade(this, params);
  }
  add(api, opt_index) {
    const bc2 = api.controller;
    this.controller_.rack.add(bc2, opt_index);
    return api;
  }
  remove(api) {
    this.controller_.rack.remove(api.controller);
  }
  addBlade(params) {
    const doc = this.controller_.element.ownerDocument;
    const bc2 = this.pool_.createBlade(doc, params);
    const api = this.pool_.createApi(bc2);
    return this.add(api, params.index);
  }
  on(eventName, handler) {
    const bh = handler.bind(this);
    this.emitter_.on(eventName, (ev) => {
      bh(ev);
    });
    return this;
  }
  refresh() {
    this.children.forEach((c) => {
      if (isRefreshable(c)) {
        c.refresh();
      }
    });
  }
  onRackValueChange_(ev) {
    const bc2 = ev.bladeController;
    const api = this.pool_.createApi(bc2);
    const binding = isBindingValue(bc2.value) ? bc2.value.binding : null;
    this.emitter_.emit("change", new TpChangeEvent(api, binding ? binding.target.read() : bc2.value.rawValue, ev.options.last));
  }
};
var ContainerBladeApi = class extends BladeApi {
  constructor(controller, pool) {
    super(controller);
    this.rackApi_ = new RackApi(controller.rackController, pool);
  }
  refresh() {
    this.rackApi_.refresh();
  }
};
var ContainerBladeController = class extends BladeController {
  constructor(config) {
    super({
      blade: config.blade,
      view: config.view,
      viewProps: config.rackController.viewProps
    });
    this.rackController = config.rackController;
  }
  importState(state) {
    return importBladeState(state, (s) => super.importState(s), (p) => ({
      children: p.required.array(p.required.raw)
    }), (result) => {
      return this.rackController.rack.children.every((c, index) => {
        return c.importState(result.children[index]);
      });
    });
  }
  exportState() {
    return exportBladeState(() => super.exportState(), {
      children: this.rackController.rack.children.map((c) => c.exportState())
    });
  }
};
function isContainerBladeController(bc2) {
  return "rackController" in bc2;
}
var NestedOrderedSet = class {
  constructor(extract) {
    this.emitter = new Emitter();
    this.items_ = [];
    this.cache_ = /* @__PURE__ */ new Set();
    this.onSubListAdd_ = this.onSubListAdd_.bind(this);
    this.onSubListRemove_ = this.onSubListRemove_.bind(this);
    this.extract_ = extract;
  }
  get items() {
    return this.items_;
  }
  allItems() {
    return Array.from(this.cache_);
  }
  find(callback) {
    for (const item of this.allItems()) {
      if (callback(item)) {
        return item;
      }
    }
    return null;
  }
  includes(item) {
    return this.cache_.has(item);
  }
  add(item, opt_index) {
    if (this.includes(item)) {
      throw TpError.shouldNeverHappen();
    }
    const index = opt_index !== void 0 ? opt_index : this.items_.length;
    this.items_.splice(index, 0, item);
    this.cache_.add(item);
    const subList = this.extract_(item);
    if (subList) {
      subList.emitter.on("add", this.onSubListAdd_);
      subList.emitter.on("remove", this.onSubListRemove_);
      subList.allItems().forEach((i) => {
        this.cache_.add(i);
      });
    }
    this.emitter.emit("add", {
      index,
      item,
      root: this,
      target: this
    });
  }
  remove(item) {
    const index = this.items_.indexOf(item);
    if (index < 0) {
      return;
    }
    this.items_.splice(index, 1);
    this.cache_.delete(item);
    const subList = this.extract_(item);
    if (subList) {
      subList.allItems().forEach((i) => {
        this.cache_.delete(i);
      });
      subList.emitter.off("add", this.onSubListAdd_);
      subList.emitter.off("remove", this.onSubListRemove_);
    }
    this.emitter.emit("remove", {
      index,
      item,
      root: this,
      target: this
    });
  }
  onSubListAdd_(ev) {
    this.cache_.add(ev.item);
    this.emitter.emit("add", {
      index: ev.index,
      item: ev.item,
      root: this,
      target: ev.target
    });
  }
  onSubListRemove_(ev) {
    this.cache_.delete(ev.item);
    this.emitter.emit("remove", {
      index: ev.index,
      item: ev.item,
      root: this,
      target: ev.target
    });
  }
};
function findValueBladeController(bcs, v) {
  for (let i = 0; i < bcs.length; i++) {
    const bc2 = bcs[i];
    if (isValueBladeController(bc2) && bc2.value === v) {
      return bc2;
    }
  }
  return null;
}
function findSubBladeControllerSet(bc2) {
  return isContainerBladeController(bc2) ? bc2.rackController.rack["bcSet_"] : null;
}
var Rack = class {
  constructor(config) {
    var _a2, _b;
    this.emitter = new Emitter();
    this.onBladePositionsChange_ = this.onBladePositionsChange_.bind(this);
    this.onSetAdd_ = this.onSetAdd_.bind(this);
    this.onSetRemove_ = this.onSetRemove_.bind(this);
    this.onChildDispose_ = this.onChildDispose_.bind(this);
    this.onChildPositionsChange_ = this.onChildPositionsChange_.bind(this);
    this.onChildValueChange_ = this.onChildValueChange_.bind(this);
    this.onChildViewPropsChange_ = this.onChildViewPropsChange_.bind(this);
    this.onRackLayout_ = this.onRackLayout_.bind(this);
    this.onRackValueChange_ = this.onRackValueChange_.bind(this);
    this.blade_ = (_a2 = config.blade) !== null && _a2 !== void 0 ? _a2 : null;
    (_b = this.blade_) === null || _b === void 0 ? void 0 : _b.value("positions").emitter.on("change", this.onBladePositionsChange_);
    this.viewProps = config.viewProps;
    this.bcSet_ = new NestedOrderedSet(findSubBladeControllerSet);
    this.bcSet_.emitter.on("add", this.onSetAdd_);
    this.bcSet_.emitter.on("remove", this.onSetRemove_);
  }
  get children() {
    return this.bcSet_.items;
  }
  add(bc2, opt_index) {
    var _a2;
    (_a2 = bc2.parent) === null || _a2 === void 0 ? void 0 : _a2.remove(bc2);
    bc2.parent = this;
    this.bcSet_.add(bc2, opt_index);
  }
  remove(bc2) {
    bc2.parent = null;
    this.bcSet_.remove(bc2);
  }
  find(finder) {
    return this.bcSet_.allItems().filter(finder);
  }
  onSetAdd_(ev) {
    this.updatePositions_();
    const root = ev.target === ev.root;
    this.emitter.emit("add", {
      bladeController: ev.item,
      index: ev.index,
      root,
      sender: this
    });
    if (!root) {
      return;
    }
    const bc2 = ev.item;
    bc2.viewProps.emitter.on("change", this.onChildViewPropsChange_);
    bc2.blade.value("positions").emitter.on("change", this.onChildPositionsChange_);
    bc2.viewProps.handleDispose(this.onChildDispose_);
    if (isValueBladeController(bc2)) {
      bc2.value.emitter.on("change", this.onChildValueChange_);
    } else if (isContainerBladeController(bc2)) {
      const rack = bc2.rackController.rack;
      if (rack) {
        const emitter = rack.emitter;
        emitter.on("layout", this.onRackLayout_);
        emitter.on("valuechange", this.onRackValueChange_);
      }
    }
  }
  onSetRemove_(ev) {
    this.updatePositions_();
    const root = ev.target === ev.root;
    this.emitter.emit("remove", {
      bladeController: ev.item,
      root,
      sender: this
    });
    if (!root) {
      return;
    }
    const bc2 = ev.item;
    if (isValueBladeController(bc2)) {
      bc2.value.emitter.off("change", this.onChildValueChange_);
    } else if (isContainerBladeController(bc2)) {
      const rack = bc2.rackController.rack;
      if (rack) {
        const emitter = rack.emitter;
        emitter.off("layout", this.onRackLayout_);
        emitter.off("valuechange", this.onRackValueChange_);
      }
    }
  }
  updatePositions_() {
    const visibleItems = this.bcSet_.items.filter((bc2) => !bc2.viewProps.get("hidden"));
    const firstVisibleItem = visibleItems[0];
    const lastVisibleItem = visibleItems[visibleItems.length - 1];
    this.bcSet_.items.forEach((bc2) => {
      const ps2 = [];
      if (bc2 === firstVisibleItem) {
        ps2.push("first");
        if (!this.blade_ || this.blade_.get("positions").includes("veryfirst")) {
          ps2.push("veryfirst");
        }
      }
      if (bc2 === lastVisibleItem) {
        ps2.push("last");
        if (!this.blade_ || this.blade_.get("positions").includes("verylast")) {
          ps2.push("verylast");
        }
      }
      bc2.blade.set("positions", ps2);
    });
  }
  onChildPositionsChange_() {
    this.updatePositions_();
    this.emitter.emit("layout", {
      sender: this
    });
  }
  onChildViewPropsChange_(_ev) {
    this.updatePositions_();
    this.emitter.emit("layout", {
      sender: this
    });
  }
  onChildDispose_() {
    const disposedUcs = this.bcSet_.items.filter((bc2) => {
      return bc2.viewProps.get("disposed");
    });
    disposedUcs.forEach((bc2) => {
      this.bcSet_.remove(bc2);
    });
  }
  onChildValueChange_(ev) {
    const bc2 = findValueBladeController(this.find(isValueBladeController), ev.sender);
    if (!bc2) {
      throw TpError.alreadyDisposed();
    }
    this.emitter.emit("valuechange", {
      bladeController: bc2,
      options: ev.options,
      sender: this
    });
  }
  onRackLayout_(_) {
    this.updatePositions_();
    this.emitter.emit("layout", {
      sender: this
    });
  }
  onRackValueChange_(ev) {
    this.emitter.emit("valuechange", {
      bladeController: ev.bladeController,
      options: ev.options,
      sender: this
    });
  }
  onBladePositionsChange_() {
    this.updatePositions_();
  }
};
var RackController = class {
  constructor(config) {
    this.onRackAdd_ = this.onRackAdd_.bind(this);
    this.onRackRemove_ = this.onRackRemove_.bind(this);
    this.element = config.element;
    this.viewProps = config.viewProps;
    const rack = new Rack({
      blade: config.root ? void 0 : config.blade,
      viewProps: config.viewProps
    });
    rack.emitter.on("add", this.onRackAdd_);
    rack.emitter.on("remove", this.onRackRemove_);
    this.rack = rack;
    this.viewProps.handleDispose(() => {
      for (let i = this.rack.children.length - 1; i >= 0; i--) {
        const bc2 = this.rack.children[i];
        bc2.viewProps.set("disposed", true);
      }
    });
  }
  onRackAdd_(ev) {
    if (!ev.root) {
      return;
    }
    insertElementAt(this.element, ev.bladeController.view.element, ev.index);
  }
  onRackRemove_(ev) {
    if (!ev.root) {
      return;
    }
    removeElement(ev.bladeController.view.element);
  }
};
function createBlade() {
  return new ValueMap({
    positions: createValue([], {
      equals: deepEqualsArray
    })
  });
}
var Foldable = class _Foldable extends ValueMap {
  constructor(valueMap) {
    super(valueMap);
  }
  static create(expanded) {
    const coreObj = {
      completed: true,
      expanded,
      expandedHeight: null,
      shouldFixHeight: false,
      temporaryExpanded: null
    };
    const core = ValueMap.createCore(coreObj);
    return new _Foldable(core);
  }
  get styleExpanded() {
    var _a2;
    return (_a2 = this.get("temporaryExpanded")) !== null && _a2 !== void 0 ? _a2 : this.get("expanded");
  }
  get styleHeight() {
    if (!this.styleExpanded) {
      return "0";
    }
    const exHeight = this.get("expandedHeight");
    if (this.get("shouldFixHeight") && !isEmpty(exHeight)) {
      return `${exHeight}px`;
    }
    return "auto";
  }
  bindExpandedClass(elem, expandedClassName) {
    const onExpand = () => {
      const expanded = this.styleExpanded;
      if (expanded) {
        elem.classList.add(expandedClassName);
      } else {
        elem.classList.remove(expandedClassName);
      }
    };
    bindValueMap(this, "expanded", onExpand);
    bindValueMap(this, "temporaryExpanded", onExpand);
  }
  cleanUpTransition() {
    this.set("shouldFixHeight", false);
    this.set("expandedHeight", null);
    this.set("completed", true);
  }
};
function computeExpandedFolderHeight(folder, containerElement) {
  let height = 0;
  disableTransitionTemporarily(containerElement, () => {
    folder.set("expandedHeight", null);
    folder.set("temporaryExpanded", true);
    forceReflow(containerElement);
    height = containerElement.clientHeight;
    folder.set("temporaryExpanded", null);
    forceReflow(containerElement);
  });
  return height;
}
function applyHeight(foldable, elem) {
  elem.style.height = foldable.styleHeight;
}
function bindFoldable(foldable, elem) {
  foldable.value("expanded").emitter.on("beforechange", () => {
    foldable.set("completed", false);
    if (isEmpty(foldable.get("expandedHeight"))) {
      const h = computeExpandedFolderHeight(foldable, elem);
      if (h > 0) {
        foldable.set("expandedHeight", h);
      }
    }
    foldable.set("shouldFixHeight", true);
    forceReflow(elem);
  });
  foldable.emitter.on("change", () => {
    applyHeight(foldable, elem);
  });
  applyHeight(foldable, elem);
  elem.addEventListener("transitionend", (ev) => {
    if (ev.propertyName !== "height") {
      return;
    }
    foldable.cleanUpTransition();
  });
}
var FolderApi = class extends ContainerBladeApi {
  constructor(controller, pool) {
    super(controller, pool);
    this.emitter_ = new Emitter();
    this.controller.foldable.value("expanded").emitter.on("change", (ev) => {
      this.emitter_.emit("fold", new TpFoldEvent(this, ev.sender.rawValue));
    });
    this.rackApi_.on("change", (ev) => {
      this.emitter_.emit("change", ev);
    });
  }
  get expanded() {
    return this.controller.foldable.get("expanded");
  }
  set expanded(expanded) {
    this.controller.foldable.set("expanded", expanded);
  }
  get title() {
    return this.controller.props.get("title");
  }
  set title(title) {
    this.controller.props.set("title", title);
  }
  get children() {
    return this.rackApi_.children;
  }
  addBinding(object, key, opt_params) {
    return this.rackApi_.addBinding(object, key, opt_params);
  }
  addFolder(params) {
    return this.rackApi_.addFolder(params);
  }
  addButton(params) {
    return this.rackApi_.addButton(params);
  }
  addTab(params) {
    return this.rackApi_.addTab(params);
  }
  add(api, opt_index) {
    return this.rackApi_.add(api, opt_index);
  }
  remove(api) {
    this.rackApi_.remove(api);
  }
  addBlade(params) {
    return this.rackApi_.addBlade(params);
  }
  on(eventName, handler) {
    const bh = handler.bind(this);
    this.emitter_.on(eventName, (ev) => {
      bh(ev);
    });
    return this;
  }
};
var bladeContainerClassName = ClassName("cnt");
var FolderView = class {
  constructor(doc, config) {
    var _a2;
    this.className_ = ClassName((_a2 = config.viewName) !== null && _a2 !== void 0 ? _a2 : "fld");
    this.element = doc.createElement("div");
    this.element.classList.add(this.className_(), bladeContainerClassName());
    config.viewProps.bindClassModifiers(this.element);
    this.foldable_ = config.foldable;
    this.foldable_.bindExpandedClass(this.element, this.className_(void 0, "expanded"));
    bindValueMap(this.foldable_, "completed", valueToClassName(this.element, this.className_(void 0, "cpl")));
    const buttonElem = doc.createElement("button");
    buttonElem.classList.add(this.className_("b"));
    bindValueMap(config.props, "title", (title) => {
      if (isEmpty(title)) {
        this.element.classList.add(this.className_(void 0, "not"));
      } else {
        this.element.classList.remove(this.className_(void 0, "not"));
      }
    });
    config.viewProps.bindDisabled(buttonElem);
    this.element.appendChild(buttonElem);
    this.buttonElement = buttonElem;
    const indentElem = doc.createElement("div");
    indentElem.classList.add(this.className_("i"));
    this.element.appendChild(indentElem);
    const titleElem = doc.createElement("div");
    titleElem.classList.add(this.className_("t"));
    bindValueToTextContent(config.props.value("title"), titleElem);
    this.buttonElement.appendChild(titleElem);
    this.titleElement = titleElem;
    const markElem = doc.createElement("div");
    markElem.classList.add(this.className_("m"));
    this.buttonElement.appendChild(markElem);
    const containerElem = doc.createElement("div");
    containerElem.classList.add(this.className_("c"));
    this.element.appendChild(containerElem);
    this.containerElement = containerElem;
  }
};
var FolderController = class extends ContainerBladeController {
  constructor(doc, config) {
    var _a2;
    const foldable = Foldable.create((_a2 = config.expanded) !== null && _a2 !== void 0 ? _a2 : true);
    const view = new FolderView(doc, {
      foldable,
      props: config.props,
      viewName: config.root ? "rot" : void 0,
      viewProps: config.viewProps
    });
    super(Object.assign(Object.assign({}, config), { rackController: new RackController({
      blade: config.blade,
      element: view.containerElement,
      root: config.root,
      viewProps: config.viewProps
    }), view }));
    this.onTitleClick_ = this.onTitleClick_.bind(this);
    this.props = config.props;
    this.foldable = foldable;
    bindFoldable(this.foldable, this.view.containerElement);
    this.rackController.rack.emitter.on("add", () => {
      this.foldable.cleanUpTransition();
    });
    this.rackController.rack.emitter.on("remove", () => {
      this.foldable.cleanUpTransition();
    });
    this.view.buttonElement.addEventListener("click", this.onTitleClick_);
  }
  get document() {
    return this.view.element.ownerDocument;
  }
  importState(state) {
    return importBladeState(state, (s) => super.importState(s), (p) => ({
      expanded: p.required.boolean,
      title: p.optional.string
    }), (result) => {
      this.foldable.set("expanded", result.expanded);
      this.props.set("title", result.title);
      return true;
    });
  }
  exportState() {
    return exportBladeState(() => super.exportState(), {
      expanded: this.foldable.get("expanded"),
      title: this.props.get("title")
    });
  }
  onTitleClick_() {
    this.foldable.set("expanded", !this.foldable.get("expanded"));
  }
};
var FolderBladePlugin = createPlugin({
  id: "folder",
  type: "blade",
  accept(params) {
    const result = parseRecord(params, (p) => ({
      title: p.required.string,
      view: p.required.constant("folder"),
      expanded: p.optional.boolean
    }));
    return result ? { params: result } : null;
  },
  controller(args) {
    return new FolderController(args.document, {
      blade: args.blade,
      expanded: args.params.expanded,
      props: ValueMap.fromObject({
        title: args.params.title
      }),
      viewProps: args.viewProps
    });
  },
  api(args) {
    if (!(args.controller instanceof FolderController)) {
      return null;
    }
    return new FolderApi(args.controller, args.pool);
  }
});
var cn$o = ClassName("");
function valueToModifier(elem, modifier) {
  return valueToClassName(elem, cn$o(void 0, modifier));
}
var ViewProps = class _ViewProps extends ValueMap {
  constructor(valueMap) {
    var _a2;
    super(valueMap);
    this.onDisabledChange_ = this.onDisabledChange_.bind(this);
    this.onParentChange_ = this.onParentChange_.bind(this);
    this.onParentGlobalDisabledChange_ = this.onParentGlobalDisabledChange_.bind(this);
    [this.globalDisabled_, this.setGlobalDisabled_] = createReadonlyValue(createValue(this.getGlobalDisabled_()));
    this.value("disabled").emitter.on("change", this.onDisabledChange_);
    this.value("parent").emitter.on("change", this.onParentChange_);
    (_a2 = this.get("parent")) === null || _a2 === void 0 ? void 0 : _a2.globalDisabled.emitter.on("change", this.onParentGlobalDisabledChange_);
  }
  static create(opt_initialValue) {
    var _a2, _b, _c2;
    const initialValue = opt_initialValue !== null && opt_initialValue !== void 0 ? opt_initialValue : {};
    return new _ViewProps(ValueMap.createCore({
      disabled: (_a2 = initialValue.disabled) !== null && _a2 !== void 0 ? _a2 : false,
      disposed: false,
      hidden: (_b = initialValue.hidden) !== null && _b !== void 0 ? _b : false,
      parent: (_c2 = initialValue.parent) !== null && _c2 !== void 0 ? _c2 : null
    }));
  }
  get globalDisabled() {
    return this.globalDisabled_;
  }
  bindClassModifiers(elem) {
    bindValue(this.globalDisabled_, valueToModifier(elem, "disabled"));
    bindValueMap(this, "hidden", valueToModifier(elem, "hidden"));
  }
  bindDisabled(target) {
    bindValue(this.globalDisabled_, (disabled) => {
      target.disabled = disabled;
    });
  }
  bindTabIndex(elem) {
    bindValue(this.globalDisabled_, (disabled) => {
      elem.tabIndex = disabled ? -1 : 0;
    });
  }
  handleDispose(callback) {
    this.value("disposed").emitter.on("change", (disposed) => {
      if (disposed) {
        callback();
      }
    });
  }
  importState(state) {
    this.set("disabled", state.disabled);
    this.set("hidden", state.hidden);
  }
  exportState() {
    return {
      disabled: this.get("disabled"),
      hidden: this.get("hidden")
    };
  }
  getGlobalDisabled_() {
    const parent = this.get("parent");
    const parentDisabled = parent ? parent.globalDisabled.rawValue : false;
    return parentDisabled || this.get("disabled");
  }
  updateGlobalDisabled_() {
    this.setGlobalDisabled_(this.getGlobalDisabled_());
  }
  onDisabledChange_() {
    this.updateGlobalDisabled_();
  }
  onParentGlobalDisabledChange_() {
    this.updateGlobalDisabled_();
  }
  onParentChange_(ev) {
    var _a2;
    const prevParent = ev.previousRawValue;
    prevParent === null || prevParent === void 0 ? void 0 : prevParent.globalDisabled.emitter.off("change", this.onParentGlobalDisabledChange_);
    (_a2 = this.get("parent")) === null || _a2 === void 0 ? void 0 : _a2.globalDisabled.emitter.on("change", this.onParentGlobalDisabledChange_);
    this.updateGlobalDisabled_();
  }
};
var cn$n = ClassName("tbp");
var TabPageView = class {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$n());
    config.viewProps.bindClassModifiers(this.element);
    const containerElem = doc.createElement("div");
    containerElem.classList.add(cn$n("c"));
    this.element.appendChild(containerElem);
    this.containerElement = containerElem;
  }
};
var cn$m = ClassName("tbi");
var TabItemView = class {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$m());
    config.viewProps.bindClassModifiers(this.element);
    bindValueMap(config.props, "selected", (selected) => {
      if (selected) {
        this.element.classList.add(cn$m(void 0, "sel"));
      } else {
        this.element.classList.remove(cn$m(void 0, "sel"));
      }
    });
    const buttonElem = doc.createElement("button");
    buttonElem.classList.add(cn$m("b"));
    config.viewProps.bindDisabled(buttonElem);
    this.element.appendChild(buttonElem);
    this.buttonElement = buttonElem;
    const titleElem = doc.createElement("div");
    titleElem.classList.add(cn$m("t"));
    bindValueToTextContent(config.props.value("title"), titleElem);
    this.buttonElement.appendChild(titleElem);
    this.titleElement = titleElem;
  }
};
var TabItemController = class {
  constructor(doc, config) {
    this.emitter = new Emitter();
    this.onClick_ = this.onClick_.bind(this);
    this.props = config.props;
    this.viewProps = config.viewProps;
    this.view = new TabItemView(doc, {
      props: config.props,
      viewProps: config.viewProps
    });
    this.view.buttonElement.addEventListener("click", this.onClick_);
  }
  onClick_() {
    this.emitter.emit("click", {
      sender: this
    });
  }
};
var TabPageController = class extends ContainerBladeController {
  constructor(doc, config) {
    const view = new TabPageView(doc, {
      viewProps: config.viewProps
    });
    super(Object.assign(Object.assign({}, config), { rackController: new RackController({
      blade: config.blade,
      element: view.containerElement,
      viewProps: config.viewProps
    }), view }));
    this.onItemClick_ = this.onItemClick_.bind(this);
    this.ic_ = new TabItemController(doc, {
      props: config.itemProps,
      viewProps: ViewProps.create()
    });
    this.ic_.emitter.on("click", this.onItemClick_);
    this.props = config.props;
    bindValueMap(this.props, "selected", (selected) => {
      this.itemController.props.set("selected", selected);
      this.viewProps.set("hidden", !selected);
    });
  }
  get itemController() {
    return this.ic_;
  }
  importState(state) {
    return importBladeState(state, (s) => super.importState(s), (p) => ({
      selected: p.required.boolean,
      title: p.required.string
    }), (result) => {
      this.ic_.props.set("selected", result.selected);
      this.ic_.props.set("title", result.title);
      return true;
    });
  }
  exportState() {
    return exportBladeState(() => super.exportState(), {
      selected: this.ic_.props.get("selected"),
      title: this.ic_.props.get("title")
    });
  }
  onItemClick_() {
    this.props.set("selected", true);
  }
};
var TabApi = class extends ContainerBladeApi {
  constructor(controller, pool) {
    super(controller, pool);
    this.emitter_ = new Emitter();
    this.onSelect_ = this.onSelect_.bind(this);
    this.pool_ = pool;
    this.rackApi_.on("change", (ev) => {
      this.emitter_.emit("change", ev);
    });
    this.controller.tab.selectedIndex.emitter.on("change", this.onSelect_);
  }
  get pages() {
    return this.rackApi_.children;
  }
  addPage(params) {
    const doc = this.controller.view.element.ownerDocument;
    const pc = new TabPageController(doc, {
      blade: createBlade(),
      itemProps: ValueMap.fromObject({
        selected: false,
        title: params.title
      }),
      props: ValueMap.fromObject({
        selected: false
      }),
      viewProps: ViewProps.create()
    });
    const papi = this.pool_.createApi(pc);
    return this.rackApi_.add(papi, params.index);
  }
  removePage(index) {
    this.rackApi_.remove(this.rackApi_.children[index]);
  }
  on(eventName, handler) {
    const bh = handler.bind(this);
    this.emitter_.on(eventName, (ev) => {
      bh(ev);
    });
    return this;
  }
  onSelect_(ev) {
    this.emitter_.emit("select", new TpTabSelectEvent(this, ev.rawValue));
  }
};
var TabPageApi = class extends ContainerBladeApi {
  get title() {
    var _a2;
    return (_a2 = this.controller.itemController.props.get("title")) !== null && _a2 !== void 0 ? _a2 : "";
  }
  set title(title) {
    this.controller.itemController.props.set("title", title);
  }
  get selected() {
    return this.controller.props.get("selected");
  }
  set selected(selected) {
    this.controller.props.set("selected", selected);
  }
  get children() {
    return this.rackApi_.children;
  }
  addButton(params) {
    return this.rackApi_.addButton(params);
  }
  addFolder(params) {
    return this.rackApi_.addFolder(params);
  }
  addTab(params) {
    return this.rackApi_.addTab(params);
  }
  add(api, opt_index) {
    this.rackApi_.add(api, opt_index);
  }
  remove(api) {
    this.rackApi_.remove(api);
  }
  addBinding(object, key, opt_params) {
    return this.rackApi_.addBinding(object, key, opt_params);
  }
  addBlade(params) {
    return this.rackApi_.addBlade(params);
  }
};
var INDEX_NOT_SELECTED = -1;
var Tab = class {
  constructor() {
    this.onItemSelectedChange_ = this.onItemSelectedChange_.bind(this);
    this.empty = createValue(true);
    this.selectedIndex = createValue(INDEX_NOT_SELECTED);
    this.items_ = [];
  }
  add(item, opt_index) {
    const index = opt_index !== null && opt_index !== void 0 ? opt_index : this.items_.length;
    this.items_.splice(index, 0, item);
    item.emitter.on("change", this.onItemSelectedChange_);
    this.keepSelection_();
  }
  remove(item) {
    const index = this.items_.indexOf(item);
    if (index < 0) {
      return;
    }
    this.items_.splice(index, 1);
    item.emitter.off("change", this.onItemSelectedChange_);
    this.keepSelection_();
  }
  keepSelection_() {
    if (this.items_.length === 0) {
      this.selectedIndex.rawValue = INDEX_NOT_SELECTED;
      this.empty.rawValue = true;
      return;
    }
    const firstSelIndex = this.items_.findIndex((s) => s.rawValue);
    if (firstSelIndex < 0) {
      this.items_.forEach((s, i) => {
        s.rawValue = i === 0;
      });
      this.selectedIndex.rawValue = 0;
    } else {
      this.items_.forEach((s, i) => {
        s.rawValue = i === firstSelIndex;
      });
      this.selectedIndex.rawValue = firstSelIndex;
    }
    this.empty.rawValue = false;
  }
  onItemSelectedChange_(ev) {
    if (ev.rawValue) {
      const index = this.items_.findIndex((s) => s === ev.sender);
      this.items_.forEach((s, i) => {
        s.rawValue = i === index;
      });
      this.selectedIndex.rawValue = index;
    } else {
      this.keepSelection_();
    }
  }
};
var cn$l = ClassName("tab");
var TabView = class {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$l(), bladeContainerClassName());
    config.viewProps.bindClassModifiers(this.element);
    bindValue(config.empty, valueToClassName(this.element, cn$l(void 0, "nop")));
    const titleElem = doc.createElement("div");
    titleElem.classList.add(cn$l("t"));
    this.element.appendChild(titleElem);
    this.itemsElement = titleElem;
    const indentElem = doc.createElement("div");
    indentElem.classList.add(cn$l("i"));
    this.element.appendChild(indentElem);
    const contentsElem = doc.createElement("div");
    contentsElem.classList.add(cn$l("c"));
    this.element.appendChild(contentsElem);
    this.contentsElement = contentsElem;
  }
};
var TabController = class extends ContainerBladeController {
  constructor(doc, config) {
    const tab = new Tab();
    const view = new TabView(doc, {
      empty: tab.empty,
      viewProps: config.viewProps
    });
    super({
      blade: config.blade,
      rackController: new RackController({
        blade: config.blade,
        element: view.contentsElement,
        viewProps: config.viewProps
      }),
      view
    });
    this.onRackAdd_ = this.onRackAdd_.bind(this);
    this.onRackRemove_ = this.onRackRemove_.bind(this);
    const rack = this.rackController.rack;
    rack.emitter.on("add", this.onRackAdd_);
    rack.emitter.on("remove", this.onRackRemove_);
    this.tab = tab;
  }
  add(pc, opt_index) {
    this.rackController.rack.add(pc, opt_index);
  }
  remove(index) {
    this.rackController.rack.remove(this.rackController.rack.children[index]);
  }
  onRackAdd_(ev) {
    if (!ev.root) {
      return;
    }
    const pc = ev.bladeController;
    insertElementAt(this.view.itemsElement, pc.itemController.view.element, ev.index);
    pc.itemController.viewProps.set("parent", this.viewProps);
    this.tab.add(pc.props.value("selected"));
  }
  onRackRemove_(ev) {
    if (!ev.root) {
      return;
    }
    const pc = ev.bladeController;
    removeElement(pc.itemController.view.element);
    pc.itemController.viewProps.set("parent", null);
    this.tab.remove(pc.props.value("selected"));
  }
};
var TabBladePlugin = createPlugin({
  id: "tab",
  type: "blade",
  accept(params) {
    const result = parseRecord(params, (p) => ({
      pages: p.required.array(p.required.object({ title: p.required.string })),
      view: p.required.constant("tab")
    }));
    if (!result || result.pages.length === 0) {
      return null;
    }
    return { params: result };
  },
  controller(args) {
    const c = new TabController(args.document, {
      blade: args.blade,
      viewProps: args.viewProps
    });
    args.params.pages.forEach((p) => {
      const pc = new TabPageController(args.document, {
        blade: createBlade(),
        itemProps: ValueMap.fromObject({
          selected: false,
          title: p.title
        }),
        props: ValueMap.fromObject({
          selected: false
        }),
        viewProps: ViewProps.create()
      });
      c.add(pc);
    });
    return c;
  },
  api(args) {
    if (args.controller instanceof TabController) {
      return new TabApi(args.controller, args.pool);
    }
    if (args.controller instanceof TabPageController) {
      return new TabPageApi(args.controller, args.pool);
    }
    return null;
  }
});
function createBladeController(plugin, args) {
  const ac2 = plugin.accept(args.params);
  if (!ac2) {
    return null;
  }
  const params = parseRecord(args.params, (p) => ({
    disabled: p.optional.boolean,
    hidden: p.optional.boolean
  }));
  return plugin.controller({
    blade: createBlade(),
    document: args.document,
    params: forceCast(Object.assign(Object.assign({}, ac2.params), { disabled: params === null || params === void 0 ? void 0 : params.disabled, hidden: params === null || params === void 0 ? void 0 : params.hidden })),
    viewProps: ViewProps.create({
      disabled: params === null || params === void 0 ? void 0 : params.disabled,
      hidden: params === null || params === void 0 ? void 0 : params.hidden
    })
  });
}
var ListInputBindingApi = class extends BindingApi {
  get options() {
    return this.controller.valueController.props.get("options");
  }
  set options(options) {
    this.controller.valueController.props.set("options", options);
  }
};
var ManualTicker = class {
  constructor() {
    this.disabled = false;
    this.emitter = new Emitter();
  }
  dispose() {
  }
  tick() {
    if (this.disabled) {
      return;
    }
    this.emitter.emit("tick", {
      sender: this
    });
  }
};
var IntervalTicker = class {
  constructor(doc, interval) {
    this.disabled_ = false;
    this.timerId_ = null;
    this.onTick_ = this.onTick_.bind(this);
    this.doc_ = doc;
    this.emitter = new Emitter();
    this.interval_ = interval;
    this.setTimer_();
  }
  get disabled() {
    return this.disabled_;
  }
  set disabled(inactive) {
    this.disabled_ = inactive;
    if (this.disabled_) {
      this.clearTimer_();
    } else {
      this.setTimer_();
    }
  }
  dispose() {
    this.clearTimer_();
  }
  clearTimer_() {
    if (this.timerId_ === null) {
      return;
    }
    const win = this.doc_.defaultView;
    if (win) {
      win.clearInterval(this.timerId_);
    }
    this.timerId_ = null;
  }
  setTimer_() {
    this.clearTimer_();
    if (this.interval_ <= 0) {
      return;
    }
    const win = this.doc_.defaultView;
    if (win) {
      this.timerId_ = win.setInterval(this.onTick_, this.interval_);
    }
  }
  onTick_() {
    if (this.disabled_) {
      return;
    }
    this.emitter.emit("tick", {
      sender: this
    });
  }
};
var CompositeConstraint = class {
  constructor(constraints) {
    this.constraints = constraints;
  }
  constrain(value) {
    return this.constraints.reduce((result, c) => {
      return c.constrain(result);
    }, value);
  }
};
function findConstraint(c, constraintClass) {
  if (c instanceof constraintClass) {
    return c;
  }
  if (c instanceof CompositeConstraint) {
    const result = c.constraints.reduce((tmpResult, sc2) => {
      if (tmpResult) {
        return tmpResult;
      }
      return sc2 instanceof constraintClass ? sc2 : null;
    }, null);
    if (result) {
      return result;
    }
  }
  return null;
}
var ListConstraint = class {
  constructor(options) {
    this.values = ValueMap.fromObject({
      options
    });
  }
  constrain(value) {
    const opts = this.values.get("options");
    if (opts.length === 0) {
      return value;
    }
    const matched = opts.filter((item) => {
      return item.value === value;
    }).length > 0;
    return matched ? value : opts[0].value;
  }
};
function parseListOptions(value) {
  var _a2;
  const p = MicroParsers;
  if (Array.isArray(value)) {
    return (_a2 = parseRecord({ items: value }, (p2) => ({
      items: p2.required.array(p2.required.object({
        text: p2.required.string,
        value: p2.required.raw
      }))
    }))) === null || _a2 === void 0 ? void 0 : _a2.items;
  }
  if (typeof value === "object") {
    return p.required.raw(value).value;
  }
  return void 0;
}
function normalizeListOptions(options) {
  if (Array.isArray(options)) {
    return options;
  }
  const items = [];
  Object.keys(options).forEach((text) => {
    items.push({ text, value: options[text] });
  });
  return items;
}
function createListConstraint(options) {
  return !isEmpty(options) ? new ListConstraint(normalizeListOptions(forceCast(options))) : null;
}
var cn$k = ClassName("lst");
var ListView = class {
  constructor(doc, config) {
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.props_ = config.props;
    this.element = doc.createElement("div");
    this.element.classList.add(cn$k());
    config.viewProps.bindClassModifiers(this.element);
    const selectElem = doc.createElement("select");
    selectElem.classList.add(cn$k("s"));
    config.viewProps.bindDisabled(selectElem);
    this.element.appendChild(selectElem);
    this.selectElement = selectElem;
    const markElem = doc.createElement("div");
    markElem.classList.add(cn$k("m"));
    markElem.appendChild(createSvgIconElement(doc, "dropdown"));
    this.element.appendChild(markElem);
    config.value.emitter.on("change", this.onValueChange_);
    this.value_ = config.value;
    bindValueMap(this.props_, "options", (opts) => {
      removeChildElements(this.selectElement);
      opts.forEach((item) => {
        const optionElem = doc.createElement("option");
        optionElem.textContent = item.text;
        this.selectElement.appendChild(optionElem);
      });
      this.update_();
    });
  }
  update_() {
    const values = this.props_.get("options").map((o) => o.value);
    this.selectElement.selectedIndex = values.indexOf(this.value_.rawValue);
  }
  onValueChange_() {
    this.update_();
  }
};
var ListController = class {
  constructor(doc, config) {
    this.onSelectChange_ = this.onSelectChange_.bind(this);
    this.props = config.props;
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new ListView(doc, {
      props: this.props,
      value: this.value,
      viewProps: this.viewProps
    });
    this.view.selectElement.addEventListener("change", this.onSelectChange_);
  }
  onSelectChange_(e) {
    const selectElem = forceCast(e.currentTarget);
    this.value.rawValue = this.props.get("options")[selectElem.selectedIndex].value;
  }
  importProps(state) {
    return importBladeState(state, null, (p) => ({
      options: p.required.custom(parseListOptions)
    }), (result) => {
      this.props.set("options", normalizeListOptions(result.options));
      return true;
    });
  }
  exportProps() {
    return exportBladeState(null, {
      options: this.props.get("options")
    });
  }
};
var cn$j = ClassName("pop");
var PopupView = class {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$j());
    config.viewProps.bindClassModifiers(this.element);
    bindValue(config.shows, valueToClassName(this.element, cn$j(void 0, "v")));
  }
};
var PopupController = class {
  constructor(doc, config) {
    this.shows = createValue(false);
    this.viewProps = config.viewProps;
    this.view = new PopupView(doc, {
      shows: this.shows,
      viewProps: this.viewProps
    });
  }
};
var cn$i = ClassName("txt");
var TextView = class {
  constructor(doc, config) {
    this.onChange_ = this.onChange_.bind(this);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$i());
    config.viewProps.bindClassModifiers(this.element);
    this.props_ = config.props;
    this.props_.emitter.on("change", this.onChange_);
    const inputElem = doc.createElement("input");
    inputElem.classList.add(cn$i("i"));
    inputElem.type = "text";
    config.viewProps.bindDisabled(inputElem);
    this.element.appendChild(inputElem);
    this.inputElement = inputElem;
    config.value.emitter.on("change", this.onChange_);
    this.value_ = config.value;
    this.refresh();
  }
  refresh() {
    const formatter = this.props_.get("formatter");
    this.inputElement.value = formatter(this.value_.rawValue);
  }
  onChange_() {
    this.refresh();
  }
};
var TextController = class {
  constructor(doc, config) {
    this.onInputChange_ = this.onInputChange_.bind(this);
    this.parser_ = config.parser;
    this.props = config.props;
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new TextView(doc, {
      props: config.props,
      value: this.value,
      viewProps: this.viewProps
    });
    this.view.inputElement.addEventListener("change", this.onInputChange_);
  }
  onInputChange_(e) {
    const inputElem = forceCast(e.currentTarget);
    const value = inputElem.value;
    const parsedValue = this.parser_(value);
    if (!isEmpty(parsedValue)) {
      this.value.rawValue = parsedValue;
    }
    this.view.refresh();
  }
};
function boolToString(value) {
  return String(value);
}
function boolFromUnknown(value) {
  if (value === "false") {
    return false;
  }
  return !!value;
}
function BooleanFormatter(value) {
  return boolToString(value);
}
function composeParsers(parsers) {
  return (text) => {
    return parsers.reduce((result, parser) => {
      if (result !== null) {
        return result;
      }
      return parser(text);
    }, null);
  };
}
var innerFormatter = createNumberFormatter(0);
function formatPercentage(value) {
  return innerFormatter(value) + "%";
}
function stringFromUnknown(value) {
  return String(value);
}
function formatString(value) {
  return value;
}
function connectValues({ primary, secondary, forward, backward }) {
  let changing = false;
  function preventFeedback(callback) {
    if (changing) {
      return;
    }
    changing = true;
    callback();
    changing = false;
  }
  primary.emitter.on("change", (ev) => {
    preventFeedback(() => {
      secondary.setRawValue(forward(primary.rawValue, secondary.rawValue), ev.options);
    });
  });
  secondary.emitter.on("change", (ev) => {
    preventFeedback(() => {
      primary.setRawValue(backward(primary.rawValue, secondary.rawValue), ev.options);
    });
    preventFeedback(() => {
      secondary.setRawValue(forward(primary.rawValue, secondary.rawValue), ev.options);
    });
  });
  preventFeedback(() => {
    secondary.setRawValue(forward(primary.rawValue, secondary.rawValue), {
      forceEmit: false,
      last: true
    });
  });
}
function getStepForKey(keyScale, keys) {
  const step = keyScale * (keys.altKey ? 0.1 : 1) * (keys.shiftKey ? 10 : 1);
  if (keys.upKey) {
    return +step;
  } else if (keys.downKey) {
    return -step;
  }
  return 0;
}
function getVerticalStepKeys(ev) {
  return {
    altKey: ev.altKey,
    downKey: ev.key === "ArrowDown",
    shiftKey: ev.shiftKey,
    upKey: ev.key === "ArrowUp"
  };
}
function getHorizontalStepKeys(ev) {
  return {
    altKey: ev.altKey,
    downKey: ev.key === "ArrowLeft",
    shiftKey: ev.shiftKey,
    upKey: ev.key === "ArrowRight"
  };
}
function isVerticalArrowKey(key) {
  return key === "ArrowUp" || key === "ArrowDown";
}
function isArrowKey(key) {
  return isVerticalArrowKey(key) || key === "ArrowLeft" || key === "ArrowRight";
}
function computeOffset$1(ev, elem) {
  var _a2, _b;
  const win = elem.ownerDocument.defaultView;
  const rect = elem.getBoundingClientRect();
  return {
    x: ev.pageX - (((_a2 = win && win.scrollX) !== null && _a2 !== void 0 ? _a2 : 0) + rect.left),
    y: ev.pageY - (((_b = win && win.scrollY) !== null && _b !== void 0 ? _b : 0) + rect.top)
  };
}
var PointerHandler = class {
  constructor(element) {
    this.lastTouch_ = null;
    this.onDocumentMouseMove_ = this.onDocumentMouseMove_.bind(this);
    this.onDocumentMouseUp_ = this.onDocumentMouseUp_.bind(this);
    this.onMouseDown_ = this.onMouseDown_.bind(this);
    this.onTouchEnd_ = this.onTouchEnd_.bind(this);
    this.onTouchMove_ = this.onTouchMove_.bind(this);
    this.onTouchStart_ = this.onTouchStart_.bind(this);
    this.elem_ = element;
    this.emitter = new Emitter();
    element.addEventListener("touchstart", this.onTouchStart_, {
      passive: false
    });
    element.addEventListener("touchmove", this.onTouchMove_, {
      passive: true
    });
    element.addEventListener("touchend", this.onTouchEnd_);
    element.addEventListener("mousedown", this.onMouseDown_);
  }
  computePosition_(offset) {
    const rect = this.elem_.getBoundingClientRect();
    return {
      bounds: {
        width: rect.width,
        height: rect.height
      },
      point: offset ? {
        x: offset.x,
        y: offset.y
      } : null
    };
  }
  onMouseDown_(ev) {
    var _a2;
    ev.preventDefault();
    (_a2 = ev.currentTarget) === null || _a2 === void 0 ? void 0 : _a2.focus();
    const doc = this.elem_.ownerDocument;
    doc.addEventListener("mousemove", this.onDocumentMouseMove_);
    doc.addEventListener("mouseup", this.onDocumentMouseUp_);
    this.emitter.emit("down", {
      altKey: ev.altKey,
      data: this.computePosition_(computeOffset$1(ev, this.elem_)),
      sender: this,
      shiftKey: ev.shiftKey
    });
  }
  onDocumentMouseMove_(ev) {
    this.emitter.emit("move", {
      altKey: ev.altKey,
      data: this.computePosition_(computeOffset$1(ev, this.elem_)),
      sender: this,
      shiftKey: ev.shiftKey
    });
  }
  onDocumentMouseUp_(ev) {
    const doc = this.elem_.ownerDocument;
    doc.removeEventListener("mousemove", this.onDocumentMouseMove_);
    doc.removeEventListener("mouseup", this.onDocumentMouseUp_);
    this.emitter.emit("up", {
      altKey: ev.altKey,
      data: this.computePosition_(computeOffset$1(ev, this.elem_)),
      sender: this,
      shiftKey: ev.shiftKey
    });
  }
  onTouchStart_(ev) {
    ev.preventDefault();
    const touch = ev.targetTouches.item(0);
    const rect = this.elem_.getBoundingClientRect();
    this.emitter.emit("down", {
      altKey: ev.altKey,
      data: this.computePosition_(touch ? {
        x: touch.clientX - rect.left,
        y: touch.clientY - rect.top
      } : void 0),
      sender: this,
      shiftKey: ev.shiftKey
    });
    this.lastTouch_ = touch;
  }
  onTouchMove_(ev) {
    const touch = ev.targetTouches.item(0);
    const rect = this.elem_.getBoundingClientRect();
    this.emitter.emit("move", {
      altKey: ev.altKey,
      data: this.computePosition_(touch ? {
        x: touch.clientX - rect.left,
        y: touch.clientY - rect.top
      } : void 0),
      sender: this,
      shiftKey: ev.shiftKey
    });
    this.lastTouch_ = touch;
  }
  onTouchEnd_(ev) {
    var _a2;
    const touch = (_a2 = ev.targetTouches.item(0)) !== null && _a2 !== void 0 ? _a2 : this.lastTouch_;
    const rect = this.elem_.getBoundingClientRect();
    this.emitter.emit("up", {
      altKey: ev.altKey,
      data: this.computePosition_(touch ? {
        x: touch.clientX - rect.left,
        y: touch.clientY - rect.top
      } : void 0),
      sender: this,
      shiftKey: ev.shiftKey
    });
  }
};
var cn$h = ClassName("txt");
var NumberTextView = class {
  constructor(doc, config) {
    this.onChange_ = this.onChange_.bind(this);
    this.props_ = config.props;
    this.props_.emitter.on("change", this.onChange_);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$h(), cn$h(void 0, "num"));
    if (config.arrayPosition) {
      this.element.classList.add(cn$h(void 0, config.arrayPosition));
    }
    config.viewProps.bindClassModifiers(this.element);
    const inputElem = doc.createElement("input");
    inputElem.classList.add(cn$h("i"));
    inputElem.type = "text";
    config.viewProps.bindDisabled(inputElem);
    this.element.appendChild(inputElem);
    this.inputElement = inputElem;
    this.onDraggingChange_ = this.onDraggingChange_.bind(this);
    this.dragging_ = config.dragging;
    this.dragging_.emitter.on("change", this.onDraggingChange_);
    this.element.classList.add(cn$h());
    this.inputElement.classList.add(cn$h("i"));
    const knobElem = doc.createElement("div");
    knobElem.classList.add(cn$h("k"));
    this.element.appendChild(knobElem);
    this.knobElement = knobElem;
    const guideElem = doc.createElementNS(SVG_NS, "svg");
    guideElem.classList.add(cn$h("g"));
    this.knobElement.appendChild(guideElem);
    const bodyElem = doc.createElementNS(SVG_NS, "path");
    bodyElem.classList.add(cn$h("gb"));
    guideElem.appendChild(bodyElem);
    this.guideBodyElem_ = bodyElem;
    const headElem = doc.createElementNS(SVG_NS, "path");
    headElem.classList.add(cn$h("gh"));
    guideElem.appendChild(headElem);
    this.guideHeadElem_ = headElem;
    const tooltipElem = doc.createElement("div");
    tooltipElem.classList.add(ClassName("tt")());
    this.knobElement.appendChild(tooltipElem);
    this.tooltipElem_ = tooltipElem;
    config.value.emitter.on("change", this.onChange_);
    this.value = config.value;
    this.refresh();
  }
  onDraggingChange_(ev) {
    if (ev.rawValue === null) {
      this.element.classList.remove(cn$h(void 0, "drg"));
      return;
    }
    this.element.classList.add(cn$h(void 0, "drg"));
    const x = ev.rawValue / this.props_.get("pointerScale");
    const aox = x + (x > 0 ? -1 : x < 0 ? 1 : 0);
    const adx = constrainRange(-aox, -4, 4);
    this.guideHeadElem_.setAttributeNS(null, "d", [`M ${aox + adx},0 L${aox},4 L${aox + adx},8`, `M ${x},-1 L${x},9`].join(" "));
    this.guideBodyElem_.setAttributeNS(null, "d", `M 0,4 L${x},4`);
    const formatter = this.props_.get("formatter");
    this.tooltipElem_.textContent = formatter(this.value.rawValue);
    this.tooltipElem_.style.left = `${x}px`;
  }
  refresh() {
    const formatter = this.props_.get("formatter");
    this.inputElement.value = formatter(this.value.rawValue);
  }
  onChange_() {
    this.refresh();
  }
};
var NumberTextController = class {
  constructor(doc, config) {
    var _a2;
    this.originRawValue_ = 0;
    this.onInputChange_ = this.onInputChange_.bind(this);
    this.onInputKeyDown_ = this.onInputKeyDown_.bind(this);
    this.onInputKeyUp_ = this.onInputKeyUp_.bind(this);
    this.onPointerDown_ = this.onPointerDown_.bind(this);
    this.onPointerMove_ = this.onPointerMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.parser_ = config.parser;
    this.props = config.props;
    this.sliderProps_ = (_a2 = config.sliderProps) !== null && _a2 !== void 0 ? _a2 : null;
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.dragging_ = createValue(null);
    this.view = new NumberTextView(doc, {
      arrayPosition: config.arrayPosition,
      dragging: this.dragging_,
      props: this.props,
      value: this.value,
      viewProps: this.viewProps
    });
    this.view.inputElement.addEventListener("change", this.onInputChange_);
    this.view.inputElement.addEventListener("keydown", this.onInputKeyDown_);
    this.view.inputElement.addEventListener("keyup", this.onInputKeyUp_);
    const ph = new PointerHandler(this.view.knobElement);
    ph.emitter.on("down", this.onPointerDown_);
    ph.emitter.on("move", this.onPointerMove_);
    ph.emitter.on("up", this.onPointerUp_);
  }
  constrainValue_(value) {
    var _a2, _b;
    const min = (_a2 = this.sliderProps_) === null || _a2 === void 0 ? void 0 : _a2.get("min");
    const max = (_b = this.sliderProps_) === null || _b === void 0 ? void 0 : _b.get("max");
    let v = value;
    if (min !== void 0) {
      v = Math.max(v, min);
    }
    if (max !== void 0) {
      v = Math.min(v, max);
    }
    return v;
  }
  onInputChange_(e) {
    const inputElem = forceCast(e.currentTarget);
    const value = inputElem.value;
    const parsedValue = this.parser_(value);
    if (!isEmpty(parsedValue)) {
      this.value.rawValue = this.constrainValue_(parsedValue);
    }
    this.view.refresh();
  }
  onInputKeyDown_(ev) {
    const step = getStepForKey(this.props.get("keyScale"), getVerticalStepKeys(ev));
    if (step === 0) {
      return;
    }
    this.value.setRawValue(this.constrainValue_(this.value.rawValue + step), {
      forceEmit: false,
      last: false
    });
  }
  onInputKeyUp_(ev) {
    const step = getStepForKey(this.props.get("keyScale"), getVerticalStepKeys(ev));
    if (step === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue, {
      forceEmit: true,
      last: true
    });
  }
  onPointerDown_() {
    this.originRawValue_ = this.value.rawValue;
    this.dragging_.rawValue = 0;
  }
  computeDraggingValue_(data) {
    if (!data.point) {
      return null;
    }
    const dx = data.point.x - data.bounds.width / 2;
    return this.constrainValue_(this.originRawValue_ + dx * this.props.get("pointerScale"));
  }
  onPointerMove_(ev) {
    const v = this.computeDraggingValue_(ev.data);
    if (v === null) {
      return;
    }
    this.value.setRawValue(v, {
      forceEmit: false,
      last: false
    });
    this.dragging_.rawValue = this.value.rawValue - this.originRawValue_;
  }
  onPointerUp_(ev) {
    const v = this.computeDraggingValue_(ev.data);
    if (v === null) {
      return;
    }
    this.value.setRawValue(v, {
      forceEmit: true,
      last: true
    });
    this.dragging_.rawValue = null;
  }
};
var cn$g = ClassName("sld");
var SliderView = class {
  constructor(doc, config) {
    this.onChange_ = this.onChange_.bind(this);
    this.props_ = config.props;
    this.props_.emitter.on("change", this.onChange_);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$g());
    config.viewProps.bindClassModifiers(this.element);
    const trackElem = doc.createElement("div");
    trackElem.classList.add(cn$g("t"));
    config.viewProps.bindTabIndex(trackElem);
    this.element.appendChild(trackElem);
    this.trackElement = trackElem;
    const knobElem = doc.createElement("div");
    knobElem.classList.add(cn$g("k"));
    this.trackElement.appendChild(knobElem);
    this.knobElement = knobElem;
    config.value.emitter.on("change", this.onChange_);
    this.value = config.value;
    this.update_();
  }
  update_() {
    const p = constrainRange(mapRange(this.value.rawValue, this.props_.get("min"), this.props_.get("max"), 0, 100), 0, 100);
    this.knobElement.style.width = `${p}%`;
  }
  onChange_() {
    this.update_();
  }
};
var SliderController = class {
  constructor(doc, config) {
    this.onKeyDown_ = this.onKeyDown_.bind(this);
    this.onKeyUp_ = this.onKeyUp_.bind(this);
    this.onPointerDownOrMove_ = this.onPointerDownOrMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.props = config.props;
    this.view = new SliderView(doc, {
      props: this.props,
      value: this.value,
      viewProps: this.viewProps
    });
    this.ptHandler_ = new PointerHandler(this.view.trackElement);
    this.ptHandler_.emitter.on("down", this.onPointerDownOrMove_);
    this.ptHandler_.emitter.on("move", this.onPointerDownOrMove_);
    this.ptHandler_.emitter.on("up", this.onPointerUp_);
    this.view.trackElement.addEventListener("keydown", this.onKeyDown_);
    this.view.trackElement.addEventListener("keyup", this.onKeyUp_);
  }
  handlePointerEvent_(d, opts) {
    if (!d.point) {
      return;
    }
    this.value.setRawValue(mapRange(constrainRange(d.point.x, 0, d.bounds.width), 0, d.bounds.width, this.props.get("min"), this.props.get("max")), opts);
  }
  onPointerDownOrMove_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false
    });
  }
  onPointerUp_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: true,
      last: true
    });
  }
  onKeyDown_(ev) {
    const step = getStepForKey(this.props.get("keyScale"), getHorizontalStepKeys(ev));
    if (step === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue + step, {
      forceEmit: false,
      last: false
    });
  }
  onKeyUp_(ev) {
    const step = getStepForKey(this.props.get("keyScale"), getHorizontalStepKeys(ev));
    if (step === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue, {
      forceEmit: true,
      last: true
    });
  }
};
var cn$f = ClassName("sldtxt");
var SliderTextView = class {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$f());
    const sliderElem = doc.createElement("div");
    sliderElem.classList.add(cn$f("s"));
    this.sliderView_ = config.sliderView;
    sliderElem.appendChild(this.sliderView_.element);
    this.element.appendChild(sliderElem);
    const textElem = doc.createElement("div");
    textElem.classList.add(cn$f("t"));
    this.textView_ = config.textView;
    textElem.appendChild(this.textView_.element);
    this.element.appendChild(textElem);
  }
};
var SliderTextController = class {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.sliderC_ = new SliderController(doc, {
      props: config.sliderProps,
      value: config.value,
      viewProps: this.viewProps
    });
    this.textC_ = new NumberTextController(doc, {
      parser: config.parser,
      props: config.textProps,
      sliderProps: config.sliderProps,
      value: config.value,
      viewProps: config.viewProps
    });
    this.view = new SliderTextView(doc, {
      sliderView: this.sliderC_.view,
      textView: this.textC_.view
    });
  }
  get sliderController() {
    return this.sliderC_;
  }
  get textController() {
    return this.textC_;
  }
  importProps(state) {
    return importBladeState(state, null, (p) => ({
      max: p.required.number,
      min: p.required.number
    }), (result) => {
      const sliderProps = this.sliderC_.props;
      sliderProps.set("max", result.max);
      sliderProps.set("min", result.min);
      return true;
    });
  }
  exportProps() {
    const sliderProps = this.sliderC_.props;
    return exportBladeState(null, {
      max: sliderProps.get("max"),
      min: sliderProps.get("min")
    });
  }
};
function createSliderTextProps(config) {
  return {
    sliderProps: new ValueMap({
      keyScale: config.keyScale,
      max: config.max,
      min: config.min
    }),
    textProps: new ValueMap({
      formatter: createValue(config.formatter),
      keyScale: config.keyScale,
      pointerScale: createValue(config.pointerScale)
    })
  };
}
var CSS_VAR_MAP = {
  containerUnitSize: "cnt-usz"
};
function getCssVar(key) {
  return `--${CSS_VAR_MAP[key]}`;
}
function createPointDimensionParser(p) {
  return createNumberTextInputParamsParser(p);
}
function parsePointDimensionParams(value) {
  if (!isRecord(value)) {
    return void 0;
  }
  return parseRecord(value, createPointDimensionParser);
}
function createDimensionConstraint(params, initialValue) {
  if (!params) {
    return void 0;
  }
  const constraints = [];
  const cs = createStepConstraint(params, initialValue);
  if (cs) {
    constraints.push(cs);
  }
  const rs2 = createRangeConstraint(params);
  if (rs2) {
    constraints.push(rs2);
  }
  return new CompositeConstraint(constraints);
}
function isCompatible(ver) {
  if (!ver) {
    return false;
  }
  return ver.major === VERSION$1.major;
}
function parsePickerLayout(value) {
  if (value === "inline" || value === "popup") {
    return value;
  }
  return void 0;
}
function writePrimitive(target, value) {
  target.write(value);
}
var cn$e = ClassName("ckb");
var CheckboxView = class {
  constructor(doc, config) {
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$e());
    config.viewProps.bindClassModifiers(this.element);
    const labelElem = doc.createElement("label");
    labelElem.classList.add(cn$e("l"));
    this.element.appendChild(labelElem);
    const inputElem = doc.createElement("input");
    inputElem.classList.add(cn$e("i"));
    inputElem.type = "checkbox";
    labelElem.appendChild(inputElem);
    this.inputElement = inputElem;
    config.viewProps.bindDisabled(this.inputElement);
    const wrapperElem = doc.createElement("div");
    wrapperElem.classList.add(cn$e("w"));
    labelElem.appendChild(wrapperElem);
    const markElem = createSvgIconElement(doc, "check");
    wrapperElem.appendChild(markElem);
    config.value.emitter.on("change", this.onValueChange_);
    this.value = config.value;
    this.update_();
  }
  update_() {
    this.inputElement.checked = this.value.rawValue;
  }
  onValueChange_() {
    this.update_();
  }
};
var CheckboxController = class {
  constructor(doc, config) {
    this.onInputChange_ = this.onInputChange_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new CheckboxView(doc, {
      value: this.value,
      viewProps: this.viewProps
    });
    this.view.inputElement.addEventListener("change", this.onInputChange_);
  }
  onInputChange_(e) {
    const inputElem = forceCast(e.currentTarget);
    this.value.rawValue = inputElem.checked;
  }
};
function createConstraint$6(params) {
  const constraints = [];
  const lc2 = createListConstraint(params.options);
  if (lc2) {
    constraints.push(lc2);
  }
  return new CompositeConstraint(constraints);
}
var BooleanInputPlugin = createPlugin({
  id: "input-bool",
  type: "input",
  accept: (value, params) => {
    if (typeof value !== "boolean") {
      return null;
    }
    const result = parseRecord(params, (p) => ({
      options: p.optional.custom(parseListOptions),
      readonly: p.optional.constant(false)
    }));
    return result ? {
      initialValue: value,
      params: result
    } : null;
  },
  binding: {
    reader: (_args) => boolFromUnknown,
    constraint: (args) => createConstraint$6(args.params),
    writer: (_args) => writePrimitive
  },
  controller: (args) => {
    const doc = args.document;
    const value = args.value;
    const c = args.constraint;
    const lc2 = c && findConstraint(c, ListConstraint);
    if (lc2) {
      return new ListController(doc, {
        props: new ValueMap({
          options: lc2.values.value("options")
        }),
        value,
        viewProps: args.viewProps
      });
    }
    return new CheckboxController(doc, {
      value,
      viewProps: args.viewProps
    });
  },
  api(args) {
    if (typeof args.controller.value.rawValue !== "boolean") {
      return null;
    }
    if (args.controller.valueController instanceof ListController) {
      return new ListInputBindingApi(args.controller);
    }
    return null;
  }
});
var cn$d = ClassName("col");
var ColorView = class {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$d());
    config.foldable.bindExpandedClass(this.element, cn$d(void 0, "expanded"));
    bindValueMap(config.foldable, "completed", valueToClassName(this.element, cn$d(void 0, "cpl")));
    const headElem = doc.createElement("div");
    headElem.classList.add(cn$d("h"));
    this.element.appendChild(headElem);
    const swatchElem = doc.createElement("div");
    swatchElem.classList.add(cn$d("s"));
    headElem.appendChild(swatchElem);
    this.swatchElement = swatchElem;
    const textElem = doc.createElement("div");
    textElem.classList.add(cn$d("t"));
    headElem.appendChild(textElem);
    this.textElement = textElem;
    if (config.pickerLayout === "inline") {
      const pickerElem = doc.createElement("div");
      pickerElem.classList.add(cn$d("p"));
      this.element.appendChild(pickerElem);
      this.pickerElement = pickerElem;
    } else {
      this.pickerElement = null;
    }
  }
};
function rgbToHslInt(r, g, b) {
  const rp = constrainRange(r / 255, 0, 1);
  const gp = constrainRange(g / 255, 0, 1);
  const bp = constrainRange(b / 255, 0, 1);
  const cmax = Math.max(rp, gp, bp);
  const cmin = Math.min(rp, gp, bp);
  const c = cmax - cmin;
  let h = 0;
  let s = 0;
  const l = (cmin + cmax) / 2;
  if (c !== 0) {
    s = c / (1 - Math.abs(cmax + cmin - 1));
    if (rp === cmax) {
      h = (gp - bp) / c;
    } else if (gp === cmax) {
      h = 2 + (bp - rp) / c;
    } else {
      h = 4 + (rp - gp) / c;
    }
    h = h / 6 + (h < 0 ? 1 : 0);
  }
  return [h * 360, s * 100, l * 100];
}
function hslToRgbInt(h, s, l) {
  const hp = (h % 360 + 360) % 360;
  const sp = constrainRange(s / 100, 0, 1);
  const lp = constrainRange(l / 100, 0, 1);
  const c = (1 - Math.abs(2 * lp - 1)) * sp;
  const x = c * (1 - Math.abs(hp / 60 % 2 - 1));
  const m = lp - c / 2;
  let rp, gp, bp;
  if (hp >= 0 && hp < 60) {
    [rp, gp, bp] = [c, x, 0];
  } else if (hp >= 60 && hp < 120) {
    [rp, gp, bp] = [x, c, 0];
  } else if (hp >= 120 && hp < 180) {
    [rp, gp, bp] = [0, c, x];
  } else if (hp >= 180 && hp < 240) {
    [rp, gp, bp] = [0, x, c];
  } else if (hp >= 240 && hp < 300) {
    [rp, gp, bp] = [x, 0, c];
  } else {
    [rp, gp, bp] = [c, 0, x];
  }
  return [(rp + m) * 255, (gp + m) * 255, (bp + m) * 255];
}
function rgbToHsvInt(r, g, b) {
  const rp = constrainRange(r / 255, 0, 1);
  const gp = constrainRange(g / 255, 0, 1);
  const bp = constrainRange(b / 255, 0, 1);
  const cmax = Math.max(rp, gp, bp);
  const cmin = Math.min(rp, gp, bp);
  const d = cmax - cmin;
  let h;
  if (d === 0) {
    h = 0;
  } else if (cmax === rp) {
    h = 60 * (((gp - bp) / d % 6 + 6) % 6);
  } else if (cmax === gp) {
    h = 60 * ((bp - rp) / d + 2);
  } else {
    h = 60 * ((rp - gp) / d + 4);
  }
  const s = cmax === 0 ? 0 : d / cmax;
  const v = cmax;
  return [h, s * 100, v * 100];
}
function hsvToRgbInt(h, s, v) {
  const hp = loopRange(h, 360);
  const sp = constrainRange(s / 100, 0, 1);
  const vp = constrainRange(v / 100, 0, 1);
  const c = vp * sp;
  const x = c * (1 - Math.abs(hp / 60 % 2 - 1));
  const m = vp - c;
  let rp, gp, bp;
  if (hp >= 0 && hp < 60) {
    [rp, gp, bp] = [c, x, 0];
  } else if (hp >= 60 && hp < 120) {
    [rp, gp, bp] = [x, c, 0];
  } else if (hp >= 120 && hp < 180) {
    [rp, gp, bp] = [0, c, x];
  } else if (hp >= 180 && hp < 240) {
    [rp, gp, bp] = [0, x, c];
  } else if (hp >= 240 && hp < 300) {
    [rp, gp, bp] = [x, 0, c];
  } else {
    [rp, gp, bp] = [c, 0, x];
  }
  return [(rp + m) * 255, (gp + m) * 255, (bp + m) * 255];
}
function hslToHsvInt(h, s, l) {
  const sd = l + s * (100 - Math.abs(2 * l - 100)) / (2 * 100);
  return [
    h,
    sd !== 0 ? s * (100 - Math.abs(2 * l - 100)) / sd : 0,
    l + s * (100 - Math.abs(2 * l - 100)) / (2 * 100)
  ];
}
function hsvToHslInt(h, s, v) {
  const sd = 100 - Math.abs(v * (200 - s) / 100 - 100);
  return [h, sd !== 0 ? s * v / sd : 0, v * (200 - s) / (2 * 100)];
}
function removeAlphaComponent(comps) {
  return [comps[0], comps[1], comps[2]];
}
function appendAlphaComponent(comps, alpha) {
  return [comps[0], comps[1], comps[2], alpha];
}
var MODE_CONVERTER_MAP = {
  hsl: {
    hsl: (h, s, l) => [h, s, l],
    hsv: hslToHsvInt,
    rgb: hslToRgbInt
  },
  hsv: {
    hsl: hsvToHslInt,
    hsv: (h, s, v) => [h, s, v],
    rgb: hsvToRgbInt
  },
  rgb: {
    hsl: rgbToHslInt,
    hsv: rgbToHsvInt,
    rgb: (r, g, b) => [r, g, b]
  }
};
function getColorMaxComponents(mode, type) {
  return [
    type === "float" ? 1 : mode === "rgb" ? 255 : 360,
    type === "float" ? 1 : mode === "rgb" ? 255 : 100,
    type === "float" ? 1 : mode === "rgb" ? 255 : 100
  ];
}
function loopHueRange(hue, max) {
  return hue === max ? max : loopRange(hue, max);
}
function constrainColorComponents(components, mode, type) {
  var _a2;
  const ms = getColorMaxComponents(mode, type);
  return [
    mode === "rgb" ? constrainRange(components[0], 0, ms[0]) : loopHueRange(components[0], ms[0]),
    constrainRange(components[1], 0, ms[1]),
    constrainRange(components[2], 0, ms[2]),
    constrainRange((_a2 = components[3]) !== null && _a2 !== void 0 ? _a2 : 1, 0, 1)
  ];
}
function convertColorType(comps, mode, from, to) {
  const fms = getColorMaxComponents(mode, from);
  const tms = getColorMaxComponents(mode, to);
  return comps.map((c, index) => c / fms[index] * tms[index]);
}
function convertColor(components, from, to) {
  const intComps = convertColorType(components, from.mode, from.type, "int");
  const result = MODE_CONVERTER_MAP[from.mode][to.mode](...intComps);
  return convertColorType(result, to.mode, "int", to.type);
}
var IntColor = class _IntColor {
  static black() {
    return new _IntColor([0, 0, 0], "rgb");
  }
  constructor(comps, mode) {
    this.type = "int";
    this.mode = mode;
    this.comps_ = constrainColorComponents(comps, mode, this.type);
  }
  getComponents(opt_mode) {
    return appendAlphaComponent(convertColor(removeAlphaComponent(this.comps_), { mode: this.mode, type: this.type }, { mode: opt_mode !== null && opt_mode !== void 0 ? opt_mode : this.mode, type: this.type }), this.comps_[3]);
  }
  toRgbaObject() {
    const rgbComps = this.getComponents("rgb");
    return {
      r: rgbComps[0],
      g: rgbComps[1],
      b: rgbComps[2],
      a: rgbComps[3]
    };
  }
};
var cn$c = ClassName("colp");
var ColorPickerView = class {
  constructor(doc, config) {
    this.alphaViews_ = null;
    this.element = doc.createElement("div");
    this.element.classList.add(cn$c());
    config.viewProps.bindClassModifiers(this.element);
    const hsvElem = doc.createElement("div");
    hsvElem.classList.add(cn$c("hsv"));
    const svElem = doc.createElement("div");
    svElem.classList.add(cn$c("sv"));
    this.svPaletteView_ = config.svPaletteView;
    svElem.appendChild(this.svPaletteView_.element);
    hsvElem.appendChild(svElem);
    const hElem = doc.createElement("div");
    hElem.classList.add(cn$c("h"));
    this.hPaletteView_ = config.hPaletteView;
    hElem.appendChild(this.hPaletteView_.element);
    hsvElem.appendChild(hElem);
    this.element.appendChild(hsvElem);
    const rgbElem = doc.createElement("div");
    rgbElem.classList.add(cn$c("rgb"));
    this.textsView_ = config.textsView;
    rgbElem.appendChild(this.textsView_.element);
    this.element.appendChild(rgbElem);
    if (config.alphaViews) {
      this.alphaViews_ = {
        palette: config.alphaViews.palette,
        text: config.alphaViews.text
      };
      const aElem = doc.createElement("div");
      aElem.classList.add(cn$c("a"));
      const apElem = doc.createElement("div");
      apElem.classList.add(cn$c("ap"));
      apElem.appendChild(this.alphaViews_.palette.element);
      aElem.appendChild(apElem);
      const atElem = doc.createElement("div");
      atElem.classList.add(cn$c("at"));
      atElem.appendChild(this.alphaViews_.text.element);
      aElem.appendChild(atElem);
      this.element.appendChild(aElem);
    }
  }
  get allFocusableElements() {
    const elems = [
      this.svPaletteView_.element,
      this.hPaletteView_.element,
      this.textsView_.modeSelectElement,
      ...this.textsView_.inputViews.map((v) => v.inputElement)
    ];
    if (this.alphaViews_) {
      elems.push(this.alphaViews_.palette.element, this.alphaViews_.text.inputElement);
    }
    return elems;
  }
};
function parseColorType(value) {
  return value === "int" ? "int" : value === "float" ? "float" : void 0;
}
function parseColorInputParams(params) {
  return parseRecord(params, (p) => ({
    color: p.optional.object({
      alpha: p.optional.boolean,
      type: p.optional.custom(parseColorType)
    }),
    expanded: p.optional.boolean,
    picker: p.optional.custom(parsePickerLayout),
    readonly: p.optional.constant(false)
  }));
}
function getKeyScaleForColor(forAlpha) {
  return forAlpha ? 0.1 : 1;
}
function extractColorType(params) {
  var _a2;
  return (_a2 = params.color) === null || _a2 === void 0 ? void 0 : _a2.type;
}
var FloatColor = class {
  constructor(comps, mode) {
    this.type = "float";
    this.mode = mode;
    this.comps_ = constrainColorComponents(comps, mode, this.type);
  }
  getComponents(opt_mode) {
    return appendAlphaComponent(convertColor(removeAlphaComponent(this.comps_), { mode: this.mode, type: this.type }, { mode: opt_mode !== null && opt_mode !== void 0 ? opt_mode : this.mode, type: this.type }), this.comps_[3]);
  }
  toRgbaObject() {
    const rgbComps = this.getComponents("rgb");
    return {
      r: rgbComps[0],
      g: rgbComps[1],
      b: rgbComps[2],
      a: rgbComps[3]
    };
  }
};
var TYPE_TO_CONSTRUCTOR_MAP = {
  int: (comps, mode) => new IntColor(comps, mode),
  float: (comps, mode) => new FloatColor(comps, mode)
};
function createColor(comps, mode, type) {
  return TYPE_TO_CONSTRUCTOR_MAP[type](comps, mode);
}
function isFloatColor(c) {
  return c.type === "float";
}
function isIntColor(c) {
  return c.type === "int";
}
function convertFloatToInt(cf) {
  const comps = cf.getComponents();
  const ms = getColorMaxComponents(cf.mode, "int");
  return new IntColor([
    Math.round(mapRange(comps[0], 0, 1, 0, ms[0])),
    Math.round(mapRange(comps[1], 0, 1, 0, ms[1])),
    Math.round(mapRange(comps[2], 0, 1, 0, ms[2])),
    comps[3]
  ], cf.mode);
}
function convertIntToFloat(ci) {
  const comps = ci.getComponents();
  const ms = getColorMaxComponents(ci.mode, "int");
  return new FloatColor([
    mapRange(comps[0], 0, ms[0], 0, 1),
    mapRange(comps[1], 0, ms[1], 0, 1),
    mapRange(comps[2], 0, ms[2], 0, 1),
    comps[3]
  ], ci.mode);
}
function mapColorType(c, type) {
  if (c.type === type) {
    return c;
  }
  if (isIntColor(c) && type === "float") {
    return convertIntToFloat(c);
  }
  if (isFloatColor(c) && type === "int") {
    return convertFloatToInt(c);
  }
  throw TpError.shouldNeverHappen();
}
function equalsStringColorFormat(f1, f2) {
  return f1.alpha === f2.alpha && f1.mode === f2.mode && f1.notation === f2.notation && f1.type === f2.type;
}
function parseCssNumberOrPercentage(text, max) {
  const m = text.match(/^(.+)%$/);
  if (!m) {
    return Math.min(parseFloat(text), max);
  }
  return Math.min(parseFloat(m[1]) * 0.01 * max, max);
}
var ANGLE_TO_DEG_MAP = {
  deg: (angle) => angle,
  grad: (angle) => angle * 360 / 400,
  rad: (angle) => angle * 360 / (2 * Math.PI),
  turn: (angle) => angle * 360
};
function parseCssNumberOrAngle(text) {
  const m = text.match(/^([0-9.]+?)(deg|grad|rad|turn)$/);
  if (!m) {
    return parseFloat(text);
  }
  const angle = parseFloat(m[1]);
  const unit = m[2];
  return ANGLE_TO_DEG_MAP[unit](angle);
}
function parseFunctionalRgbColorComponents(text) {
  const m = text.match(/^rgb\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
  if (!m) {
    return null;
  }
  const comps = [
    parseCssNumberOrPercentage(m[1], 255),
    parseCssNumberOrPercentage(m[2], 255),
    parseCssNumberOrPercentage(m[3], 255)
  ];
  if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {
    return null;
  }
  return comps;
}
function parseFunctionalRgbColor(text) {
  const comps = parseFunctionalRgbColorComponents(text);
  return comps ? new IntColor(comps, "rgb") : null;
}
function parseFunctionalRgbaColorComponents(text) {
  const m = text.match(/^rgba\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
  if (!m) {
    return null;
  }
  const comps = [
    parseCssNumberOrPercentage(m[1], 255),
    parseCssNumberOrPercentage(m[2], 255),
    parseCssNumberOrPercentage(m[3], 255),
    parseCssNumberOrPercentage(m[4], 1)
  ];
  if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2]) || isNaN(comps[3])) {
    return null;
  }
  return comps;
}
function parseFunctionalRgbaColor(text) {
  const comps = parseFunctionalRgbaColorComponents(text);
  return comps ? new IntColor(comps, "rgb") : null;
}
function parseFunctionalHslColorComponents(text) {
  const m = text.match(/^hsl\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
  if (!m) {
    return null;
  }
  const comps = [
    parseCssNumberOrAngle(m[1]),
    parseCssNumberOrPercentage(m[2], 100),
    parseCssNumberOrPercentage(m[3], 100)
  ];
  if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {
    return null;
  }
  return comps;
}
function parseFunctionalHslColor(text) {
  const comps = parseFunctionalHslColorComponents(text);
  return comps ? new IntColor(comps, "hsl") : null;
}
function parseHslaColorComponents(text) {
  const m = text.match(/^hsla\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
  if (!m) {
    return null;
  }
  const comps = [
    parseCssNumberOrAngle(m[1]),
    parseCssNumberOrPercentage(m[2], 100),
    parseCssNumberOrPercentage(m[3], 100),
    parseCssNumberOrPercentage(m[4], 1)
  ];
  if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2]) || isNaN(comps[3])) {
    return null;
  }
  return comps;
}
function parseFunctionalHslaColor(text) {
  const comps = parseHslaColorComponents(text);
  return comps ? new IntColor(comps, "hsl") : null;
}
function parseHexRgbColorComponents(text) {
  const mRgb = text.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
  if (mRgb) {
    return [
      parseInt(mRgb[1] + mRgb[1], 16),
      parseInt(mRgb[2] + mRgb[2], 16),
      parseInt(mRgb[3] + mRgb[3], 16)
    ];
  }
  const mRrggbb = text.match(/^(?:#|0x)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
  if (mRrggbb) {
    return [
      parseInt(mRrggbb[1], 16),
      parseInt(mRrggbb[2], 16),
      parseInt(mRrggbb[3], 16)
    ];
  }
  return null;
}
function parseHexRgbColor(text) {
  const comps = parseHexRgbColorComponents(text);
  return comps ? new IntColor(comps, "rgb") : null;
}
function parseHexRgbaColorComponents(text) {
  const mRgb = text.match(/^#?([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
  if (mRgb) {
    return [
      parseInt(mRgb[1] + mRgb[1], 16),
      parseInt(mRgb[2] + mRgb[2], 16),
      parseInt(mRgb[3] + mRgb[3], 16),
      mapRange(parseInt(mRgb[4] + mRgb[4], 16), 0, 255, 0, 1)
    ];
  }
  const mRrggbb = text.match(/^(?:#|0x)?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
  if (mRrggbb) {
    return [
      parseInt(mRrggbb[1], 16),
      parseInt(mRrggbb[2], 16),
      parseInt(mRrggbb[3], 16),
      mapRange(parseInt(mRrggbb[4], 16), 0, 255, 0, 1)
    ];
  }
  return null;
}
function parseHexRgbaColor(text) {
  const comps = parseHexRgbaColorComponents(text);
  return comps ? new IntColor(comps, "rgb") : null;
}
function parseObjectRgbColorComponents(text) {
  const m = text.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);
  if (!m) {
    return null;
  }
  const comps = [
    parseFloat(m[1]),
    parseFloat(m[2]),
    parseFloat(m[3])
  ];
  if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {
    return null;
  }
  return comps;
}
function createObjectRgbColorParser(type) {
  return (text) => {
    const comps = parseObjectRgbColorComponents(text);
    return comps ? createColor(comps, "rgb", type) : null;
  };
}
function parseObjectRgbaColorComponents(text) {
  const m = text.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*a\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);
  if (!m) {
    return null;
  }
  const comps = [
    parseFloat(m[1]),
    parseFloat(m[2]),
    parseFloat(m[3]),
    parseFloat(m[4])
  ];
  if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2]) || isNaN(comps[3])) {
    return null;
  }
  return comps;
}
function createObjectRgbaColorParser(type) {
  return (text) => {
    const comps = parseObjectRgbaColorComponents(text);
    return comps ? createColor(comps, "rgb", type) : null;
  };
}
var PARSER_AND_RESULT = [
  {
    parser: parseHexRgbColorComponents,
    result: {
      alpha: false,
      mode: "rgb",
      notation: "hex"
    }
  },
  {
    parser: parseHexRgbaColorComponents,
    result: {
      alpha: true,
      mode: "rgb",
      notation: "hex"
    }
  },
  {
    parser: parseFunctionalRgbColorComponents,
    result: {
      alpha: false,
      mode: "rgb",
      notation: "func"
    }
  },
  {
    parser: parseFunctionalRgbaColorComponents,
    result: {
      alpha: true,
      mode: "rgb",
      notation: "func"
    }
  },
  {
    parser: parseFunctionalHslColorComponents,
    result: {
      alpha: false,
      mode: "hsl",
      notation: "func"
    }
  },
  {
    parser: parseHslaColorComponents,
    result: {
      alpha: true,
      mode: "hsl",
      notation: "func"
    }
  },
  {
    parser: parseObjectRgbColorComponents,
    result: {
      alpha: false,
      mode: "rgb",
      notation: "object"
    }
  },
  {
    parser: parseObjectRgbaColorComponents,
    result: {
      alpha: true,
      mode: "rgb",
      notation: "object"
    }
  }
];
function detectStringColor(text) {
  return PARSER_AND_RESULT.reduce((prev, { parser, result: detection }) => {
    if (prev) {
      return prev;
    }
    return parser(text) ? detection : null;
  }, null);
}
function detectStringColorFormat(text, type = "int") {
  const r = detectStringColor(text);
  if (!r) {
    return null;
  }
  if (r.notation === "hex" && type !== "float") {
    return Object.assign(Object.assign({}, r), { type: "int" });
  }
  if (r.notation === "func") {
    return Object.assign(Object.assign({}, r), { type });
  }
  return null;
}
function createColorStringParser(type) {
  const parsers = [
    parseHexRgbColor,
    parseHexRgbaColor,
    parseFunctionalRgbColor,
    parseFunctionalRgbaColor,
    parseFunctionalHslColor,
    parseFunctionalHslaColor
  ];
  if (type === "int") {
    parsers.push(createObjectRgbColorParser("int"), createObjectRgbaColorParser("int"));
  }
  if (type === "float") {
    parsers.push(createObjectRgbColorParser("float"), createObjectRgbaColorParser("float"));
  }
  const parser = composeParsers(parsers);
  return (text) => {
    const result = parser(text);
    return result ? mapColorType(result, type) : null;
  };
}
function readIntColorString(value) {
  const parser = createColorStringParser("int");
  if (typeof value !== "string") {
    return IntColor.black();
  }
  const result = parser(value);
  return result !== null && result !== void 0 ? result : IntColor.black();
}
function zerofill(comp) {
  const hex = constrainRange(Math.floor(comp), 0, 255).toString(16);
  return hex.length === 1 ? `0${hex}` : hex;
}
function colorToHexRgbString(value, prefix = "#") {
  const hexes = removeAlphaComponent(value.getComponents("rgb")).map(zerofill).join("");
  return `${prefix}${hexes}`;
}
function colorToHexRgbaString(value, prefix = "#") {
  const rgbaComps = value.getComponents("rgb");
  const hexes = [rgbaComps[0], rgbaComps[1], rgbaComps[2], rgbaComps[3] * 255].map(zerofill).join("");
  return `${prefix}${hexes}`;
}
function colorToFunctionalRgbString(value) {
  const formatter = createNumberFormatter(0);
  const ci = mapColorType(value, "int");
  const comps = removeAlphaComponent(ci.getComponents("rgb")).map((comp) => formatter(comp));
  return `rgb(${comps.join(", ")})`;
}
function colorToFunctionalRgbaString(value) {
  const aFormatter = createNumberFormatter(2);
  const rgbFormatter = createNumberFormatter(0);
  const ci = mapColorType(value, "int");
  const comps = ci.getComponents("rgb").map((comp, index) => {
    const formatter = index === 3 ? aFormatter : rgbFormatter;
    return formatter(comp);
  });
  return `rgba(${comps.join(", ")})`;
}
function colorToFunctionalHslString(value) {
  const formatters = [
    createNumberFormatter(0),
    formatPercentage,
    formatPercentage
  ];
  const ci = mapColorType(value, "int");
  const comps = removeAlphaComponent(ci.getComponents("hsl")).map((comp, index) => formatters[index](comp));
  return `hsl(${comps.join(", ")})`;
}
function colorToFunctionalHslaString(value) {
  const formatters = [
    createNumberFormatter(0),
    formatPercentage,
    formatPercentage,
    createNumberFormatter(2)
  ];
  const ci = mapColorType(value, "int");
  const comps = ci.getComponents("hsl").map((comp, index) => formatters[index](comp));
  return `hsla(${comps.join(", ")})`;
}
function colorToObjectRgbString(value, type) {
  const formatter = createNumberFormatter(type === "float" ? 2 : 0);
  const names = ["r", "g", "b"];
  const cc2 = mapColorType(value, type);
  const comps = removeAlphaComponent(cc2.getComponents("rgb")).map((comp, index) => `${names[index]}: ${formatter(comp)}`);
  return `{${comps.join(", ")}}`;
}
function createObjectRgbColorFormatter(type) {
  return (value) => colorToObjectRgbString(value, type);
}
function colorToObjectRgbaString(value, type) {
  const aFormatter = createNumberFormatter(2);
  const rgbFormatter = createNumberFormatter(type === "float" ? 2 : 0);
  const names = ["r", "g", "b", "a"];
  const cc2 = mapColorType(value, type);
  const comps = cc2.getComponents("rgb").map((comp, index) => {
    const formatter = index === 3 ? aFormatter : rgbFormatter;
    return `${names[index]}: ${formatter(comp)}`;
  });
  return `{${comps.join(", ")}}`;
}
function createObjectRgbaColorFormatter(type) {
  return (value) => colorToObjectRgbaString(value, type);
}
var FORMAT_AND_STRINGIFIERS = [
  {
    format: {
      alpha: false,
      mode: "rgb",
      notation: "hex",
      type: "int"
    },
    stringifier: colorToHexRgbString
  },
  {
    format: {
      alpha: true,
      mode: "rgb",
      notation: "hex",
      type: "int"
    },
    stringifier: colorToHexRgbaString
  },
  {
    format: {
      alpha: false,
      mode: "rgb",
      notation: "func",
      type: "int"
    },
    stringifier: colorToFunctionalRgbString
  },
  {
    format: {
      alpha: true,
      mode: "rgb",
      notation: "func",
      type: "int"
    },
    stringifier: colorToFunctionalRgbaString
  },
  {
    format: {
      alpha: false,
      mode: "hsl",
      notation: "func",
      type: "int"
    },
    stringifier: colorToFunctionalHslString
  },
  {
    format: {
      alpha: true,
      mode: "hsl",
      notation: "func",
      type: "int"
    },
    stringifier: colorToFunctionalHslaString
  },
  ...["int", "float"].reduce((prev, type) => {
    return [
      ...prev,
      {
        format: {
          alpha: false,
          mode: "rgb",
          notation: "object",
          type
        },
        stringifier: createObjectRgbColorFormatter(type)
      },
      {
        format: {
          alpha: true,
          mode: "rgb",
          notation: "object",
          type
        },
        stringifier: createObjectRgbaColorFormatter(type)
      }
    ];
  }, [])
];
function findColorStringifier(format) {
  return FORMAT_AND_STRINGIFIERS.reduce((prev, fas) => {
    if (prev) {
      return prev;
    }
    return equalsStringColorFormat(fas.format, format) ? fas.stringifier : null;
  }, null);
}
var cn$b = ClassName("apl");
var APaletteView = class {
  constructor(doc, config) {
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.value = config.value;
    this.value.emitter.on("change", this.onValueChange_);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$b());
    config.viewProps.bindClassModifiers(this.element);
    config.viewProps.bindTabIndex(this.element);
    const barElem = doc.createElement("div");
    barElem.classList.add(cn$b("b"));
    this.element.appendChild(barElem);
    const colorElem = doc.createElement("div");
    colorElem.classList.add(cn$b("c"));
    barElem.appendChild(colorElem);
    this.colorElem_ = colorElem;
    const markerElem = doc.createElement("div");
    markerElem.classList.add(cn$b("m"));
    this.element.appendChild(markerElem);
    this.markerElem_ = markerElem;
    const previewElem = doc.createElement("div");
    previewElem.classList.add(cn$b("p"));
    this.markerElem_.appendChild(previewElem);
    this.previewElem_ = previewElem;
    this.update_();
  }
  update_() {
    const c = this.value.rawValue;
    const rgbaComps = c.getComponents("rgb");
    const leftColor = new IntColor([rgbaComps[0], rgbaComps[1], rgbaComps[2], 0], "rgb");
    const rightColor = new IntColor([rgbaComps[0], rgbaComps[1], rgbaComps[2], 255], "rgb");
    const gradientComps = [
      "to right",
      colorToFunctionalRgbaString(leftColor),
      colorToFunctionalRgbaString(rightColor)
    ];
    this.colorElem_.style.background = `linear-gradient(${gradientComps.join(",")})`;
    this.previewElem_.style.backgroundColor = colorToFunctionalRgbaString(c);
    const left = mapRange(rgbaComps[3], 0, 1, 0, 100);
    this.markerElem_.style.left = `${left}%`;
  }
  onValueChange_() {
    this.update_();
  }
};
var APaletteController = class {
  constructor(doc, config) {
    this.onKeyDown_ = this.onKeyDown_.bind(this);
    this.onKeyUp_ = this.onKeyUp_.bind(this);
    this.onPointerDown_ = this.onPointerDown_.bind(this);
    this.onPointerMove_ = this.onPointerMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new APaletteView(doc, {
      value: this.value,
      viewProps: this.viewProps
    });
    this.ptHandler_ = new PointerHandler(this.view.element);
    this.ptHandler_.emitter.on("down", this.onPointerDown_);
    this.ptHandler_.emitter.on("move", this.onPointerMove_);
    this.ptHandler_.emitter.on("up", this.onPointerUp_);
    this.view.element.addEventListener("keydown", this.onKeyDown_);
    this.view.element.addEventListener("keyup", this.onKeyUp_);
  }
  handlePointerEvent_(d, opts) {
    if (!d.point) {
      return;
    }
    const alpha = d.point.x / d.bounds.width;
    const c = this.value.rawValue;
    const [h, s, v] = c.getComponents("hsv");
    this.value.setRawValue(new IntColor([h, s, v, alpha], "hsv"), opts);
  }
  onPointerDown_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false
    });
  }
  onPointerMove_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false
    });
  }
  onPointerUp_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: true,
      last: true
    });
  }
  onKeyDown_(ev) {
    const step = getStepForKey(getKeyScaleForColor(true), getHorizontalStepKeys(ev));
    if (step === 0) {
      return;
    }
    const c = this.value.rawValue;
    const [h, s, v, a] = c.getComponents("hsv");
    this.value.setRawValue(new IntColor([h, s, v, a + step], "hsv"), {
      forceEmit: false,
      last: false
    });
  }
  onKeyUp_(ev) {
    const step = getStepForKey(getKeyScaleForColor(true), getHorizontalStepKeys(ev));
    if (step === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue, {
      forceEmit: true,
      last: true
    });
  }
};
var cn$a = ClassName("coltxt");
function createModeSelectElement(doc) {
  const selectElem = doc.createElement("select");
  const items = [
    { text: "RGB", value: "rgb" },
    { text: "HSL", value: "hsl" },
    { text: "HSV", value: "hsv" },
    { text: "HEX", value: "hex" }
  ];
  selectElem.appendChild(items.reduce((frag, item) => {
    const optElem = doc.createElement("option");
    optElem.textContent = item.text;
    optElem.value = item.value;
    frag.appendChild(optElem);
    return frag;
  }, doc.createDocumentFragment()));
  return selectElem;
}
var ColorTextsView = class {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$a());
    config.viewProps.bindClassModifiers(this.element);
    const modeElem = doc.createElement("div");
    modeElem.classList.add(cn$a("m"));
    this.modeElem_ = createModeSelectElement(doc);
    this.modeElem_.classList.add(cn$a("ms"));
    modeElem.appendChild(this.modeSelectElement);
    config.viewProps.bindDisabled(this.modeElem_);
    const modeMarkerElem = doc.createElement("div");
    modeMarkerElem.classList.add(cn$a("mm"));
    modeMarkerElem.appendChild(createSvgIconElement(doc, "dropdown"));
    modeElem.appendChild(modeMarkerElem);
    this.element.appendChild(modeElem);
    const inputsElem = doc.createElement("div");
    inputsElem.classList.add(cn$a("w"));
    this.element.appendChild(inputsElem);
    this.inputsElem_ = inputsElem;
    this.inputViews_ = config.inputViews;
    this.applyInputViews_();
    bindValue(config.mode, (mode) => {
      this.modeElem_.value = mode;
    });
  }
  get modeSelectElement() {
    return this.modeElem_;
  }
  get inputViews() {
    return this.inputViews_;
  }
  set inputViews(inputViews) {
    this.inputViews_ = inputViews;
    this.applyInputViews_();
  }
  applyInputViews_() {
    removeChildElements(this.inputsElem_);
    const doc = this.element.ownerDocument;
    this.inputViews_.forEach((v) => {
      const compElem = doc.createElement("div");
      compElem.classList.add(cn$a("c"));
      compElem.appendChild(v.element);
      this.inputsElem_.appendChild(compElem);
    });
  }
};
function createFormatter$2(type) {
  return createNumberFormatter(type === "float" ? 2 : 0);
}
function createConstraint$5(mode, type, index) {
  const max = getColorMaxComponents(mode, type)[index];
  return new DefiniteRangeConstraint({
    min: 0,
    max
  });
}
function createComponentController(doc, config, index) {
  return new NumberTextController(doc, {
    arrayPosition: index === 0 ? "fst" : index === 3 - 1 ? "lst" : "mid",
    parser: config.parser,
    props: ValueMap.fromObject({
      formatter: createFormatter$2(config.colorType),
      keyScale: getKeyScaleForColor(false),
      pointerScale: config.colorType === "float" ? 0.01 : 1
    }),
    value: createValue(0, {
      constraint: createConstraint$5(config.colorMode, config.colorType, index)
    }),
    viewProps: config.viewProps
  });
}
function createComponentControllers(doc, config) {
  const cc2 = {
    colorMode: config.colorMode,
    colorType: config.colorType,
    parser: parseNumber,
    viewProps: config.viewProps
  };
  return [0, 1, 2].map((i) => {
    const c = createComponentController(doc, cc2, i);
    connectValues({
      primary: config.value,
      secondary: c.value,
      forward(p) {
        const mc = mapColorType(p, config.colorType);
        return mc.getComponents(config.colorMode)[i];
      },
      backward(p, s) {
        const pickedMode = config.colorMode;
        const mc = mapColorType(p, config.colorType);
        const comps = mc.getComponents(pickedMode);
        comps[i] = s;
        const c2 = createColor(appendAlphaComponent(removeAlphaComponent(comps), comps[3]), pickedMode, config.colorType);
        return mapColorType(c2, "int");
      }
    });
    return c;
  });
}
function createHexController(doc, config) {
  const c = new TextController(doc, {
    parser: createColorStringParser("int"),
    props: ValueMap.fromObject({
      formatter: colorToHexRgbString
    }),
    value: createValue(IntColor.black()),
    viewProps: config.viewProps
  });
  connectValues({
    primary: config.value,
    secondary: c.value,
    forward: (p) => new IntColor(removeAlphaComponent(p.getComponents()), p.mode),
    backward: (p, s) => new IntColor(appendAlphaComponent(removeAlphaComponent(s.getComponents(p.mode)), p.getComponents()[3]), p.mode)
  });
  return [c];
}
function isColorMode(mode) {
  return mode !== "hex";
}
var ColorTextsController = class {
  constructor(doc, config) {
    this.onModeSelectChange_ = this.onModeSelectChange_.bind(this);
    this.colorType_ = config.colorType;
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.colorMode = createValue(this.value.rawValue.mode);
    this.ccs_ = this.createComponentControllers_(doc);
    this.view = new ColorTextsView(doc, {
      mode: this.colorMode,
      inputViews: [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view],
      viewProps: this.viewProps
    });
    this.view.modeSelectElement.addEventListener("change", this.onModeSelectChange_);
  }
  createComponentControllers_(doc) {
    const mode = this.colorMode.rawValue;
    if (isColorMode(mode)) {
      return createComponentControllers(doc, {
        colorMode: mode,
        colorType: this.colorType_,
        value: this.value,
        viewProps: this.viewProps
      });
    }
    return createHexController(doc, {
      value: this.value,
      viewProps: this.viewProps
    });
  }
  onModeSelectChange_(ev) {
    const selectElem = ev.currentTarget;
    this.colorMode.rawValue = selectElem.value;
    this.ccs_ = this.createComponentControllers_(this.view.element.ownerDocument);
    this.view.inputViews = this.ccs_.map((cc2) => cc2.view);
  }
};
var cn$9 = ClassName("hpl");
var HPaletteView = class {
  constructor(doc, config) {
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.value = config.value;
    this.value.emitter.on("change", this.onValueChange_);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$9());
    config.viewProps.bindClassModifiers(this.element);
    config.viewProps.bindTabIndex(this.element);
    const colorElem = doc.createElement("div");
    colorElem.classList.add(cn$9("c"));
    this.element.appendChild(colorElem);
    const markerElem = doc.createElement("div");
    markerElem.classList.add(cn$9("m"));
    this.element.appendChild(markerElem);
    this.markerElem_ = markerElem;
    this.update_();
  }
  update_() {
    const c = this.value.rawValue;
    const [h] = c.getComponents("hsv");
    this.markerElem_.style.backgroundColor = colorToFunctionalRgbString(new IntColor([h, 100, 100], "hsv"));
    const left = mapRange(h, 0, 360, 0, 100);
    this.markerElem_.style.left = `${left}%`;
  }
  onValueChange_() {
    this.update_();
  }
};
var HPaletteController = class {
  constructor(doc, config) {
    this.onKeyDown_ = this.onKeyDown_.bind(this);
    this.onKeyUp_ = this.onKeyUp_.bind(this);
    this.onPointerDown_ = this.onPointerDown_.bind(this);
    this.onPointerMove_ = this.onPointerMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new HPaletteView(doc, {
      value: this.value,
      viewProps: this.viewProps
    });
    this.ptHandler_ = new PointerHandler(this.view.element);
    this.ptHandler_.emitter.on("down", this.onPointerDown_);
    this.ptHandler_.emitter.on("move", this.onPointerMove_);
    this.ptHandler_.emitter.on("up", this.onPointerUp_);
    this.view.element.addEventListener("keydown", this.onKeyDown_);
    this.view.element.addEventListener("keyup", this.onKeyUp_);
  }
  handlePointerEvent_(d, opts) {
    if (!d.point) {
      return;
    }
    const hue = mapRange(constrainRange(d.point.x, 0, d.bounds.width), 0, d.bounds.width, 0, 360);
    const c = this.value.rawValue;
    const [, s, v, a] = c.getComponents("hsv");
    this.value.setRawValue(new IntColor([hue, s, v, a], "hsv"), opts);
  }
  onPointerDown_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false
    });
  }
  onPointerMove_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false
    });
  }
  onPointerUp_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: true,
      last: true
    });
  }
  onKeyDown_(ev) {
    const step = getStepForKey(getKeyScaleForColor(false), getHorizontalStepKeys(ev));
    if (step === 0) {
      return;
    }
    const c = this.value.rawValue;
    const [h, s, v, a] = c.getComponents("hsv");
    this.value.setRawValue(new IntColor([h + step, s, v, a], "hsv"), {
      forceEmit: false,
      last: false
    });
  }
  onKeyUp_(ev) {
    const step = getStepForKey(getKeyScaleForColor(false), getHorizontalStepKeys(ev));
    if (step === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue, {
      forceEmit: true,
      last: true
    });
  }
};
var cn$8 = ClassName("svp");
var CANVAS_RESOL = 64;
var SvPaletteView = class {
  constructor(doc, config) {
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.value = config.value;
    this.value.emitter.on("change", this.onValueChange_);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$8());
    config.viewProps.bindClassModifiers(this.element);
    config.viewProps.bindTabIndex(this.element);
    const canvasElem = doc.createElement("canvas");
    canvasElem.height = CANVAS_RESOL;
    canvasElem.width = CANVAS_RESOL;
    canvasElem.classList.add(cn$8("c"));
    this.element.appendChild(canvasElem);
    this.canvasElement = canvasElem;
    const markerElem = doc.createElement("div");
    markerElem.classList.add(cn$8("m"));
    this.element.appendChild(markerElem);
    this.markerElem_ = markerElem;
    this.update_();
  }
  update_() {
    const ctx = getCanvasContext(this.canvasElement);
    if (!ctx) {
      return;
    }
    const c = this.value.rawValue;
    const hsvComps = c.getComponents("hsv");
    const width = this.canvasElement.width;
    const height = this.canvasElement.height;
    const imgData = ctx.getImageData(0, 0, width, height);
    const data = imgData.data;
    for (let iy = 0; iy < height; iy++) {
      for (let ix = 0; ix < width; ix++) {
        const s = mapRange(ix, 0, width, 0, 100);
        const v = mapRange(iy, 0, height, 100, 0);
        const rgbComps = hsvToRgbInt(hsvComps[0], s, v);
        const i = (iy * width + ix) * 4;
        data[i] = rgbComps[0];
        data[i + 1] = rgbComps[1];
        data[i + 2] = rgbComps[2];
        data[i + 3] = 255;
      }
    }
    ctx.putImageData(imgData, 0, 0);
    const left = mapRange(hsvComps[1], 0, 100, 0, 100);
    this.markerElem_.style.left = `${left}%`;
    const top = mapRange(hsvComps[2], 0, 100, 100, 0);
    this.markerElem_.style.top = `${top}%`;
  }
  onValueChange_() {
    this.update_();
  }
};
var SvPaletteController = class {
  constructor(doc, config) {
    this.onKeyDown_ = this.onKeyDown_.bind(this);
    this.onKeyUp_ = this.onKeyUp_.bind(this);
    this.onPointerDown_ = this.onPointerDown_.bind(this);
    this.onPointerMove_ = this.onPointerMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new SvPaletteView(doc, {
      value: this.value,
      viewProps: this.viewProps
    });
    this.ptHandler_ = new PointerHandler(this.view.element);
    this.ptHandler_.emitter.on("down", this.onPointerDown_);
    this.ptHandler_.emitter.on("move", this.onPointerMove_);
    this.ptHandler_.emitter.on("up", this.onPointerUp_);
    this.view.element.addEventListener("keydown", this.onKeyDown_);
    this.view.element.addEventListener("keyup", this.onKeyUp_);
  }
  handlePointerEvent_(d, opts) {
    if (!d.point) {
      return;
    }
    const saturation = mapRange(d.point.x, 0, d.bounds.width, 0, 100);
    const value = mapRange(d.point.y, 0, d.bounds.height, 100, 0);
    const [h, , , a] = this.value.rawValue.getComponents("hsv");
    this.value.setRawValue(new IntColor([h, saturation, value, a], "hsv"), opts);
  }
  onPointerDown_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false
    });
  }
  onPointerMove_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false
    });
  }
  onPointerUp_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: true,
      last: true
    });
  }
  onKeyDown_(ev) {
    if (isArrowKey(ev.key)) {
      ev.preventDefault();
    }
    const [h, s, v, a] = this.value.rawValue.getComponents("hsv");
    const keyScale = getKeyScaleForColor(false);
    const ds = getStepForKey(keyScale, getHorizontalStepKeys(ev));
    const dv = getStepForKey(keyScale, getVerticalStepKeys(ev));
    if (ds === 0 && dv === 0) {
      return;
    }
    this.value.setRawValue(new IntColor([h, s + ds, v + dv, a], "hsv"), {
      forceEmit: false,
      last: false
    });
  }
  onKeyUp_(ev) {
    const keyScale = getKeyScaleForColor(false);
    const ds = getStepForKey(keyScale, getHorizontalStepKeys(ev));
    const dv = getStepForKey(keyScale, getVerticalStepKeys(ev));
    if (ds === 0 && dv === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue, {
      forceEmit: true,
      last: true
    });
  }
};
var ColorPickerController = class {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.hPaletteC_ = new HPaletteController(doc, {
      value: this.value,
      viewProps: this.viewProps
    });
    this.svPaletteC_ = new SvPaletteController(doc, {
      value: this.value,
      viewProps: this.viewProps
    });
    this.alphaIcs_ = config.supportsAlpha ? {
      palette: new APaletteController(doc, {
        value: this.value,
        viewProps: this.viewProps
      }),
      text: new NumberTextController(doc, {
        parser: parseNumber,
        props: ValueMap.fromObject({
          pointerScale: 0.01,
          keyScale: 0.1,
          formatter: createNumberFormatter(2)
        }),
        value: createValue(0, {
          constraint: new DefiniteRangeConstraint({ min: 0, max: 1 })
        }),
        viewProps: this.viewProps
      })
    } : null;
    if (this.alphaIcs_) {
      connectValues({
        primary: this.value,
        secondary: this.alphaIcs_.text.value,
        forward: (p) => p.getComponents()[3],
        backward: (p, s) => {
          const comps = p.getComponents();
          comps[3] = s;
          return new IntColor(comps, p.mode);
        }
      });
    }
    this.textsC_ = new ColorTextsController(doc, {
      colorType: config.colorType,
      value: this.value,
      viewProps: this.viewProps
    });
    this.view = new ColorPickerView(doc, {
      alphaViews: this.alphaIcs_ ? {
        palette: this.alphaIcs_.palette.view,
        text: this.alphaIcs_.text.view
      } : null,
      hPaletteView: this.hPaletteC_.view,
      supportsAlpha: config.supportsAlpha,
      svPaletteView: this.svPaletteC_.view,
      textsView: this.textsC_.view,
      viewProps: this.viewProps
    });
  }
  get textsController() {
    return this.textsC_;
  }
};
var cn$7 = ClassName("colsw");
var ColorSwatchView = class {
  constructor(doc, config) {
    this.onValueChange_ = this.onValueChange_.bind(this);
    config.value.emitter.on("change", this.onValueChange_);
    this.value = config.value;
    this.element = doc.createElement("div");
    this.element.classList.add(cn$7());
    config.viewProps.bindClassModifiers(this.element);
    const swatchElem = doc.createElement("div");
    swatchElem.classList.add(cn$7("sw"));
    this.element.appendChild(swatchElem);
    this.swatchElem_ = swatchElem;
    const buttonElem = doc.createElement("button");
    buttonElem.classList.add(cn$7("b"));
    config.viewProps.bindDisabled(buttonElem);
    this.element.appendChild(buttonElem);
    this.buttonElement = buttonElem;
    this.update_();
  }
  update_() {
    const value = this.value.rawValue;
    this.swatchElem_.style.backgroundColor = colorToHexRgbaString(value);
  }
  onValueChange_() {
    this.update_();
  }
};
var ColorSwatchController = class {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new ColorSwatchView(doc, {
      value: this.value,
      viewProps: this.viewProps
    });
  }
};
var ColorController = class {
  constructor(doc, config) {
    this.onButtonBlur_ = this.onButtonBlur_.bind(this);
    this.onButtonClick_ = this.onButtonClick_.bind(this);
    this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this);
    this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.foldable_ = Foldable.create(config.expanded);
    this.swatchC_ = new ColorSwatchController(doc, {
      value: this.value,
      viewProps: this.viewProps
    });
    const buttonElem = this.swatchC_.view.buttonElement;
    buttonElem.addEventListener("blur", this.onButtonBlur_);
    buttonElem.addEventListener("click", this.onButtonClick_);
    this.textC_ = new TextController(doc, {
      parser: config.parser,
      props: ValueMap.fromObject({
        formatter: config.formatter
      }),
      value: this.value,
      viewProps: this.viewProps
    });
    this.view = new ColorView(doc, {
      foldable: this.foldable_,
      pickerLayout: config.pickerLayout
    });
    this.view.swatchElement.appendChild(this.swatchC_.view.element);
    this.view.textElement.appendChild(this.textC_.view.element);
    this.popC_ = config.pickerLayout === "popup" ? new PopupController(doc, {
      viewProps: this.viewProps
    }) : null;
    const pickerC = new ColorPickerController(doc, {
      colorType: config.colorType,
      supportsAlpha: config.supportsAlpha,
      value: this.value,
      viewProps: this.viewProps
    });
    pickerC.view.allFocusableElements.forEach((elem) => {
      elem.addEventListener("blur", this.onPopupChildBlur_);
      elem.addEventListener("keydown", this.onPopupChildKeydown_);
    });
    this.pickerC_ = pickerC;
    if (this.popC_) {
      this.view.element.appendChild(this.popC_.view.element);
      this.popC_.view.element.appendChild(pickerC.view.element);
      connectValues({
        primary: this.foldable_.value("expanded"),
        secondary: this.popC_.shows,
        forward: (p) => p,
        backward: (_, s) => s
      });
    } else if (this.view.pickerElement) {
      this.view.pickerElement.appendChild(this.pickerC_.view.element);
      bindFoldable(this.foldable_, this.view.pickerElement);
    }
  }
  get textController() {
    return this.textC_;
  }
  onButtonBlur_(e) {
    if (!this.popC_) {
      return;
    }
    const elem = this.view.element;
    const nextTarget = forceCast(e.relatedTarget);
    if (!nextTarget || !elem.contains(nextTarget)) {
      this.popC_.shows.rawValue = false;
    }
  }
  onButtonClick_() {
    this.foldable_.set("expanded", !this.foldable_.get("expanded"));
    if (this.foldable_.get("expanded")) {
      this.pickerC_.view.allFocusableElements[0].focus();
    }
  }
  onPopupChildBlur_(ev) {
    if (!this.popC_) {
      return;
    }
    const elem = this.popC_.view.element;
    const nextTarget = findNextTarget(ev);
    if (nextTarget && elem.contains(nextTarget)) {
      return;
    }
    if (nextTarget && nextTarget === this.swatchC_.view.buttonElement && !supportsTouch(elem.ownerDocument)) {
      return;
    }
    this.popC_.shows.rawValue = false;
  }
  onPopupChildKeydown_(ev) {
    if (this.popC_) {
      if (ev.key === "Escape") {
        this.popC_.shows.rawValue = false;
      }
    } else if (this.view.pickerElement) {
      if (ev.key === "Escape") {
        this.swatchC_.view.buttonElement.focus();
      }
    }
  }
};
function colorToRgbNumber(value) {
  return removeAlphaComponent(value.getComponents("rgb")).reduce((result, comp) => {
    return result << 8 | Math.floor(comp) & 255;
  }, 0);
}
function colorToRgbaNumber(value) {
  return value.getComponents("rgb").reduce((result, comp, index) => {
    const hex = Math.floor(index === 3 ? comp * 255 : comp) & 255;
    return result << 8 | hex;
  }, 0) >>> 0;
}
function numberToRgbColor(num) {
  return new IntColor([num >> 16 & 255, num >> 8 & 255, num & 255], "rgb");
}
function numberToRgbaColor(num) {
  return new IntColor([
    num >> 24 & 255,
    num >> 16 & 255,
    num >> 8 & 255,
    mapRange(num & 255, 0, 255, 0, 1)
  ], "rgb");
}
function colorFromRgbNumber(value) {
  if (typeof value !== "number") {
    return IntColor.black();
  }
  return numberToRgbColor(value);
}
function colorFromRgbaNumber(value) {
  if (typeof value !== "number") {
    return IntColor.black();
  }
  return numberToRgbaColor(value);
}
function isRgbColorComponent(obj, key) {
  if (typeof obj !== "object" || isEmpty(obj)) {
    return false;
  }
  return key in obj && typeof obj[key] === "number";
}
function isRgbColorObject(obj) {
  return isRgbColorComponent(obj, "r") && isRgbColorComponent(obj, "g") && isRgbColorComponent(obj, "b");
}
function isRgbaColorObject(obj) {
  return isRgbColorObject(obj) && isRgbColorComponent(obj, "a");
}
function isColorObject(obj) {
  return isRgbColorObject(obj);
}
function equalsColor(v1, v2) {
  if (v1.mode !== v2.mode) {
    return false;
  }
  if (v1.type !== v2.type) {
    return false;
  }
  const comps1 = v1.getComponents();
  const comps2 = v2.getComponents();
  for (let i = 0; i < comps1.length; i++) {
    if (comps1[i] !== comps2[i]) {
      return false;
    }
  }
  return true;
}
function createColorComponentsFromRgbObject(obj) {
  return "a" in obj ? [obj.r, obj.g, obj.b, obj.a] : [obj.r, obj.g, obj.b];
}
function createColorStringWriter(format) {
  const stringify = findColorStringifier(format);
  return stringify ? (target, value) => {
    writePrimitive(target, stringify(value));
  } : null;
}
function createColorNumberWriter(supportsAlpha) {
  const colorToNumber = supportsAlpha ? colorToRgbaNumber : colorToRgbNumber;
  return (target, value) => {
    writePrimitive(target, colorToNumber(value));
  };
}
function writeRgbaColorObject(target, value, type) {
  const cc2 = mapColorType(value, type);
  const obj = cc2.toRgbaObject();
  target.writeProperty("r", obj.r);
  target.writeProperty("g", obj.g);
  target.writeProperty("b", obj.b);
  target.writeProperty("a", obj.a);
}
function writeRgbColorObject(target, value, type) {
  const cc2 = mapColorType(value, type);
  const obj = cc2.toRgbaObject();
  target.writeProperty("r", obj.r);
  target.writeProperty("g", obj.g);
  target.writeProperty("b", obj.b);
}
function createColorObjectWriter(supportsAlpha, type) {
  return (target, inValue) => {
    if (supportsAlpha) {
      writeRgbaColorObject(target, inValue, type);
    } else {
      writeRgbColorObject(target, inValue, type);
    }
  };
}
function shouldSupportAlpha$1(inputParams) {
  var _a2;
  if ((_a2 = inputParams === null || inputParams === void 0 ? void 0 : inputParams.color) === null || _a2 === void 0 ? void 0 : _a2.alpha) {
    return true;
  }
  return false;
}
function createFormatter$1(supportsAlpha) {
  return supportsAlpha ? (v) => colorToHexRgbaString(v, "0x") : (v) => colorToHexRgbString(v, "0x");
}
function isForColor(params) {
  if ("color" in params) {
    return true;
  }
  if (params.view === "color") {
    return true;
  }
  return false;
}
var NumberColorInputPlugin = createPlugin({
  id: "input-color-number",
  type: "input",
  accept: (value, params) => {
    if (typeof value !== "number") {
      return null;
    }
    if (!isForColor(params)) {
      return null;
    }
    const result = parseColorInputParams(params);
    return result ? {
      initialValue: value,
      params: Object.assign(Object.assign({}, result), { supportsAlpha: shouldSupportAlpha$1(params) })
    } : null;
  },
  binding: {
    reader: (args) => {
      return args.params.supportsAlpha ? colorFromRgbaNumber : colorFromRgbNumber;
    },
    equals: equalsColor,
    writer: (args) => {
      return createColorNumberWriter(args.params.supportsAlpha);
    }
  },
  controller: (args) => {
    var _a2, _b;
    return new ColorController(args.document, {
      colorType: "int",
      expanded: (_a2 = args.params.expanded) !== null && _a2 !== void 0 ? _a2 : false,
      formatter: createFormatter$1(args.params.supportsAlpha),
      parser: createColorStringParser("int"),
      pickerLayout: (_b = args.params.picker) !== null && _b !== void 0 ? _b : "popup",
      supportsAlpha: args.params.supportsAlpha,
      value: args.value,
      viewProps: args.viewProps
    });
  }
});
function colorFromObject(value, type) {
  if (!isColorObject(value)) {
    return mapColorType(IntColor.black(), type);
  }
  if (type === "int") {
    const comps = createColorComponentsFromRgbObject(value);
    return new IntColor(comps, "rgb");
  }
  if (type === "float") {
    const comps = createColorComponentsFromRgbObject(value);
    return new FloatColor(comps, "rgb");
  }
  return mapColorType(IntColor.black(), "int");
}
function shouldSupportAlpha(initialValue) {
  return isRgbaColorObject(initialValue);
}
function createColorObjectBindingReader(type) {
  return (value) => {
    const c = colorFromObject(value, type);
    return mapColorType(c, "int");
  };
}
function createColorObjectFormatter(supportsAlpha, type) {
  return (value) => {
    if (supportsAlpha) {
      return colorToObjectRgbaString(value, type);
    }
    return colorToObjectRgbString(value, type);
  };
}
var ObjectColorInputPlugin = createPlugin({
  id: "input-color-object",
  type: "input",
  accept: (value, params) => {
    var _a2;
    if (!isColorObject(value)) {
      return null;
    }
    const result = parseColorInputParams(params);
    return result ? {
      initialValue: value,
      params: Object.assign(Object.assign({}, result), { colorType: (_a2 = extractColorType(params)) !== null && _a2 !== void 0 ? _a2 : "int" })
    } : null;
  },
  binding: {
    reader: (args) => createColorObjectBindingReader(args.params.colorType),
    equals: equalsColor,
    writer: (args) => createColorObjectWriter(shouldSupportAlpha(args.initialValue), args.params.colorType)
  },
  controller: (args) => {
    var _a2, _b;
    const supportsAlpha = isRgbaColorObject(args.initialValue);
    return new ColorController(args.document, {
      colorType: args.params.colorType,
      expanded: (_a2 = args.params.expanded) !== null && _a2 !== void 0 ? _a2 : false,
      formatter: createColorObjectFormatter(supportsAlpha, args.params.colorType),
      parser: createColorStringParser("int"),
      pickerLayout: (_b = args.params.picker) !== null && _b !== void 0 ? _b : "popup",
      supportsAlpha,
      value: args.value,
      viewProps: args.viewProps
    });
  }
});
var StringColorInputPlugin = createPlugin({
  id: "input-color-string",
  type: "input",
  accept: (value, params) => {
    if (typeof value !== "string") {
      return null;
    }
    if (params.view === "text") {
      return null;
    }
    const format = detectStringColorFormat(value, extractColorType(params));
    if (!format) {
      return null;
    }
    const stringifier = findColorStringifier(format);
    if (!stringifier) {
      return null;
    }
    const result = parseColorInputParams(params);
    return result ? {
      initialValue: value,
      params: Object.assign(Object.assign({}, result), { format, stringifier })
    } : null;
  },
  binding: {
    reader: () => readIntColorString,
    equals: equalsColor,
    writer: (args) => {
      const writer = createColorStringWriter(args.params.format);
      if (!writer) {
        throw TpError.notBindable();
      }
      return writer;
    }
  },
  controller: (args) => {
    var _a2, _b;
    return new ColorController(args.document, {
      colorType: args.params.format.type,
      expanded: (_a2 = args.params.expanded) !== null && _a2 !== void 0 ? _a2 : false,
      formatter: args.params.stringifier,
      parser: createColorStringParser("int"),
      pickerLayout: (_b = args.params.picker) !== null && _b !== void 0 ? _b : "popup",
      supportsAlpha: args.params.format.alpha,
      value: args.value,
      viewProps: args.viewProps
    });
  }
});
var PointNdConstraint = class {
  constructor(config) {
    this.components = config.components;
    this.asm_ = config.assembly;
  }
  constrain(value) {
    const comps = this.asm_.toComponents(value).map((comp, index) => {
      var _a2, _b;
      return (_b = (_a2 = this.components[index]) === null || _a2 === void 0 ? void 0 : _a2.constrain(comp)) !== null && _b !== void 0 ? _b : comp;
    });
    return this.asm_.fromComponents(comps);
  }
};
var cn$6 = ClassName("pndtxt");
var PointNdTextView = class {
  constructor(doc, config) {
    this.textViews = config.textViews;
    this.element = doc.createElement("div");
    this.element.classList.add(cn$6());
    this.textViews.forEach((v) => {
      const axisElem = doc.createElement("div");
      axisElem.classList.add(cn$6("a"));
      axisElem.appendChild(v.element);
      this.element.appendChild(axisElem);
    });
  }
};
function createAxisController(doc, config, index) {
  return new NumberTextController(doc, {
    arrayPosition: index === 0 ? "fst" : index === config.axes.length - 1 ? "lst" : "mid",
    parser: config.parser,
    props: config.axes[index].textProps,
    value: createValue(0, {
      constraint: config.axes[index].constraint
    }),
    viewProps: config.viewProps
  });
}
var PointNdTextController = class {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.acs_ = config.axes.map((_, index) => createAxisController(doc, config, index));
    this.acs_.forEach((c, index) => {
      connectValues({
        primary: this.value,
        secondary: c.value,
        forward: (p) => config.assembly.toComponents(p)[index],
        backward: (p, s) => {
          const comps = config.assembly.toComponents(p);
          comps[index] = s;
          return config.assembly.fromComponents(comps);
        }
      });
    });
    this.view = new PointNdTextView(doc, {
      textViews: this.acs_.map((ac2) => ac2.view)
    });
  }
  get textControllers() {
    return this.acs_;
  }
};
var SliderInputBindingApi = class extends BindingApi {
  get max() {
    return this.controller.valueController.sliderController.props.get("max");
  }
  set max(max) {
    this.controller.valueController.sliderController.props.set("max", max);
  }
  get min() {
    return this.controller.valueController.sliderController.props.get("min");
  }
  set min(max) {
    this.controller.valueController.sliderController.props.set("min", max);
  }
};
function createConstraint$4(params, initialValue) {
  const constraints = [];
  const sc2 = createStepConstraint(params, initialValue);
  if (sc2) {
    constraints.push(sc2);
  }
  const rc2 = createRangeConstraint(params);
  if (rc2) {
    constraints.push(rc2);
  }
  const lc2 = createListConstraint(params.options);
  if (lc2) {
    constraints.push(lc2);
  }
  return new CompositeConstraint(constraints);
}
var NumberInputPlugin = createPlugin({
  id: "input-number",
  type: "input",
  accept: (value, params) => {
    if (typeof value !== "number") {
      return null;
    }
    const result = parseRecord(params, (p) => Object.assign(Object.assign({}, createNumberTextInputParamsParser(p)), { options: p.optional.custom(parseListOptions), readonly: p.optional.constant(false) }));
    return result ? {
      initialValue: value,
      params: result
    } : null;
  },
  binding: {
    reader: (_args) => numberFromUnknown,
    constraint: (args) => createConstraint$4(args.params, args.initialValue),
    writer: (_args) => writePrimitive
  },
  controller: (args) => {
    const value = args.value;
    const c = args.constraint;
    const lc2 = c && findConstraint(c, ListConstraint);
    if (lc2) {
      return new ListController(args.document, {
        props: new ValueMap({
          options: lc2.values.value("options")
        }),
        value,
        viewProps: args.viewProps
      });
    }
    const textPropsObj = createNumberTextPropsObject(args.params, value.rawValue);
    const drc = c && findConstraint(c, DefiniteRangeConstraint);
    if (drc) {
      return new SliderTextController(args.document, Object.assign(Object.assign({}, createSliderTextProps(Object.assign(Object.assign({}, textPropsObj), { keyScale: createValue(textPropsObj.keyScale), max: drc.values.value("max"), min: drc.values.value("min") }))), { parser: parseNumber, value, viewProps: args.viewProps }));
    }
    return new NumberTextController(args.document, {
      parser: parseNumber,
      props: ValueMap.fromObject(textPropsObj),
      value,
      viewProps: args.viewProps
    });
  },
  api(args) {
    if (typeof args.controller.value.rawValue !== "number") {
      return null;
    }
    if (args.controller.valueController instanceof SliderTextController) {
      return new SliderInputBindingApi(args.controller);
    }
    if (args.controller.valueController instanceof ListController) {
      return new ListInputBindingApi(args.controller);
    }
    return null;
  }
});
var Point2d = class {
  constructor(x = 0, y = 0) {
    this.x = x;
    this.y = y;
  }
  getComponents() {
    return [this.x, this.y];
  }
  static isObject(obj) {
    if (isEmpty(obj)) {
      return false;
    }
    const x = obj.x;
    const y = obj.y;
    if (typeof x !== "number" || typeof y !== "number") {
      return false;
    }
    return true;
  }
  static equals(v1, v2) {
    return v1.x === v2.x && v1.y === v2.y;
  }
  toObject() {
    return {
      x: this.x,
      y: this.y
    };
  }
};
var Point2dAssembly = {
  toComponents: (p) => p.getComponents(),
  fromComponents: (comps) => new Point2d(...comps)
};
var cn$5 = ClassName("p2d");
var Point2dView = class {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$5());
    config.viewProps.bindClassModifiers(this.element);
    bindValue(config.expanded, valueToClassName(this.element, cn$5(void 0, "expanded")));
    const headElem = doc.createElement("div");
    headElem.classList.add(cn$5("h"));
    this.element.appendChild(headElem);
    const buttonElem = doc.createElement("button");
    buttonElem.classList.add(cn$5("b"));
    buttonElem.appendChild(createSvgIconElement(doc, "p2dpad"));
    config.viewProps.bindDisabled(buttonElem);
    headElem.appendChild(buttonElem);
    this.buttonElement = buttonElem;
    const textElem = doc.createElement("div");
    textElem.classList.add(cn$5("t"));
    headElem.appendChild(textElem);
    this.textElement = textElem;
    if (config.pickerLayout === "inline") {
      const pickerElem = doc.createElement("div");
      pickerElem.classList.add(cn$5("p"));
      this.element.appendChild(pickerElem);
      this.pickerElement = pickerElem;
    } else {
      this.pickerElement = null;
    }
  }
};
var cn$4 = ClassName("p2dp");
var Point2dPickerView = class {
  constructor(doc, config) {
    this.onFoldableChange_ = this.onFoldableChange_.bind(this);
    this.onPropsChange_ = this.onPropsChange_.bind(this);
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.props_ = config.props;
    this.props_.emitter.on("change", this.onPropsChange_);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$4());
    if (config.layout === "popup") {
      this.element.classList.add(cn$4(void 0, "p"));
    }
    config.viewProps.bindClassModifiers(this.element);
    const padElem = doc.createElement("div");
    padElem.classList.add(cn$4("p"));
    config.viewProps.bindTabIndex(padElem);
    this.element.appendChild(padElem);
    this.padElement = padElem;
    const svgElem = doc.createElementNS(SVG_NS, "svg");
    svgElem.classList.add(cn$4("g"));
    this.padElement.appendChild(svgElem);
    this.svgElem_ = svgElem;
    const xAxisElem = doc.createElementNS(SVG_NS, "line");
    xAxisElem.classList.add(cn$4("ax"));
    xAxisElem.setAttributeNS(null, "x1", "0");
    xAxisElem.setAttributeNS(null, "y1", "50%");
    xAxisElem.setAttributeNS(null, "x2", "100%");
    xAxisElem.setAttributeNS(null, "y2", "50%");
    this.svgElem_.appendChild(xAxisElem);
    const yAxisElem = doc.createElementNS(SVG_NS, "line");
    yAxisElem.classList.add(cn$4("ax"));
    yAxisElem.setAttributeNS(null, "x1", "50%");
    yAxisElem.setAttributeNS(null, "y1", "0");
    yAxisElem.setAttributeNS(null, "x2", "50%");
    yAxisElem.setAttributeNS(null, "y2", "100%");
    this.svgElem_.appendChild(yAxisElem);
    const lineElem = doc.createElementNS(SVG_NS, "line");
    lineElem.classList.add(cn$4("l"));
    lineElem.setAttributeNS(null, "x1", "50%");
    lineElem.setAttributeNS(null, "y1", "50%");
    this.svgElem_.appendChild(lineElem);
    this.lineElem_ = lineElem;
    const markerElem = doc.createElement("div");
    markerElem.classList.add(cn$4("m"));
    this.padElement.appendChild(markerElem);
    this.markerElem_ = markerElem;
    config.value.emitter.on("change", this.onValueChange_);
    this.value = config.value;
    this.update_();
  }
  get allFocusableElements() {
    return [this.padElement];
  }
  update_() {
    const [x, y] = this.value.rawValue.getComponents();
    const max = this.props_.get("max");
    const px = mapRange(x, -max, +max, 0, 100);
    const py = mapRange(y, -max, +max, 0, 100);
    const ipy = this.props_.get("invertsY") ? 100 - py : py;
    this.lineElem_.setAttributeNS(null, "x2", `${px}%`);
    this.lineElem_.setAttributeNS(null, "y2", `${ipy}%`);
    this.markerElem_.style.left = `${px}%`;
    this.markerElem_.style.top = `${ipy}%`;
  }
  onValueChange_() {
    this.update_();
  }
  onPropsChange_() {
    this.update_();
  }
  onFoldableChange_() {
    this.update_();
  }
};
function computeOffset(ev, keyScales, invertsY) {
  return [
    getStepForKey(keyScales[0], getHorizontalStepKeys(ev)),
    getStepForKey(keyScales[1], getVerticalStepKeys(ev)) * (invertsY ? 1 : -1)
  ];
}
var Point2dPickerController = class {
  constructor(doc, config) {
    this.onPadKeyDown_ = this.onPadKeyDown_.bind(this);
    this.onPadKeyUp_ = this.onPadKeyUp_.bind(this);
    this.onPointerDown_ = this.onPointerDown_.bind(this);
    this.onPointerMove_ = this.onPointerMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.props = config.props;
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new Point2dPickerView(doc, {
      layout: config.layout,
      props: this.props,
      value: this.value,
      viewProps: this.viewProps
    });
    this.ptHandler_ = new PointerHandler(this.view.padElement);
    this.ptHandler_.emitter.on("down", this.onPointerDown_);
    this.ptHandler_.emitter.on("move", this.onPointerMove_);
    this.ptHandler_.emitter.on("up", this.onPointerUp_);
    this.view.padElement.addEventListener("keydown", this.onPadKeyDown_);
    this.view.padElement.addEventListener("keyup", this.onPadKeyUp_);
  }
  handlePointerEvent_(d, opts) {
    if (!d.point) {
      return;
    }
    const max = this.props.get("max");
    const px = mapRange(d.point.x, 0, d.bounds.width, -max, +max);
    const py = mapRange(this.props.get("invertsY") ? d.bounds.height - d.point.y : d.point.y, 0, d.bounds.height, -max, +max);
    this.value.setRawValue(new Point2d(px, py), opts);
  }
  onPointerDown_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false
    });
  }
  onPointerMove_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false
    });
  }
  onPointerUp_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: true,
      last: true
    });
  }
  onPadKeyDown_(ev) {
    if (isArrowKey(ev.key)) {
      ev.preventDefault();
    }
    const [dx, dy] = computeOffset(ev, [this.props.get("xKeyScale"), this.props.get("yKeyScale")], this.props.get("invertsY"));
    if (dx === 0 && dy === 0) {
      return;
    }
    this.value.setRawValue(new Point2d(this.value.rawValue.x + dx, this.value.rawValue.y + dy), {
      forceEmit: false,
      last: false
    });
  }
  onPadKeyUp_(ev) {
    const [dx, dy] = computeOffset(ev, [this.props.get("xKeyScale"), this.props.get("yKeyScale")], this.props.get("invertsY"));
    if (dx === 0 && dy === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue, {
      forceEmit: true,
      last: true
    });
  }
};
var Point2dController = class {
  constructor(doc, config) {
    var _a2, _b;
    this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this);
    this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this);
    this.onPadButtonBlur_ = this.onPadButtonBlur_.bind(this);
    this.onPadButtonClick_ = this.onPadButtonClick_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.foldable_ = Foldable.create(config.expanded);
    this.popC_ = config.pickerLayout === "popup" ? new PopupController(doc, {
      viewProps: this.viewProps
    }) : null;
    const padC = new Point2dPickerController(doc, {
      layout: config.pickerLayout,
      props: new ValueMap({
        invertsY: createValue(config.invertsY),
        max: createValue(config.max),
        xKeyScale: config.axes[0].textProps.value("keyScale"),
        yKeyScale: config.axes[1].textProps.value("keyScale")
      }),
      value: this.value,
      viewProps: this.viewProps
    });
    padC.view.allFocusableElements.forEach((elem) => {
      elem.addEventListener("blur", this.onPopupChildBlur_);
      elem.addEventListener("keydown", this.onPopupChildKeydown_);
    });
    this.pickerC_ = padC;
    this.textC_ = new PointNdTextController(doc, {
      assembly: Point2dAssembly,
      axes: config.axes,
      parser: config.parser,
      value: this.value,
      viewProps: this.viewProps
    });
    this.view = new Point2dView(doc, {
      expanded: this.foldable_.value("expanded"),
      pickerLayout: config.pickerLayout,
      viewProps: this.viewProps
    });
    this.view.textElement.appendChild(this.textC_.view.element);
    (_a2 = this.view.buttonElement) === null || _a2 === void 0 ? void 0 : _a2.addEventListener("blur", this.onPadButtonBlur_);
    (_b = this.view.buttonElement) === null || _b === void 0 ? void 0 : _b.addEventListener("click", this.onPadButtonClick_);
    if (this.popC_) {
      this.view.element.appendChild(this.popC_.view.element);
      this.popC_.view.element.appendChild(this.pickerC_.view.element);
      connectValues({
        primary: this.foldable_.value("expanded"),
        secondary: this.popC_.shows,
        forward: (p) => p,
        backward: (_, s) => s
      });
    } else if (this.view.pickerElement) {
      this.view.pickerElement.appendChild(this.pickerC_.view.element);
      bindFoldable(this.foldable_, this.view.pickerElement);
    }
  }
  get textController() {
    return this.textC_;
  }
  onPadButtonBlur_(e) {
    if (!this.popC_) {
      return;
    }
    const elem = this.view.element;
    const nextTarget = forceCast(e.relatedTarget);
    if (!nextTarget || !elem.contains(nextTarget)) {
      this.popC_.shows.rawValue = false;
    }
  }
  onPadButtonClick_() {
    this.foldable_.set("expanded", !this.foldable_.get("expanded"));
    if (this.foldable_.get("expanded")) {
      this.pickerC_.view.allFocusableElements[0].focus();
    }
  }
  onPopupChildBlur_(ev) {
    if (!this.popC_) {
      return;
    }
    const elem = this.popC_.view.element;
    const nextTarget = findNextTarget(ev);
    if (nextTarget && elem.contains(nextTarget)) {
      return;
    }
    if (nextTarget && nextTarget === this.view.buttonElement && !supportsTouch(elem.ownerDocument)) {
      return;
    }
    this.popC_.shows.rawValue = false;
  }
  onPopupChildKeydown_(ev) {
    if (this.popC_) {
      if (ev.key === "Escape") {
        this.popC_.shows.rawValue = false;
      }
    } else if (this.view.pickerElement) {
      if (ev.key === "Escape") {
        this.view.buttonElement.focus();
      }
    }
  }
};
function point2dFromUnknown(value) {
  return Point2d.isObject(value) ? new Point2d(value.x, value.y) : new Point2d();
}
function writePoint2d(target, value) {
  target.writeProperty("x", value.x);
  target.writeProperty("y", value.y);
}
function createConstraint$3(params, initialValue) {
  return new PointNdConstraint({
    assembly: Point2dAssembly,
    components: [
      createDimensionConstraint(Object.assign(Object.assign({}, params), params.x), initialValue.x),
      createDimensionConstraint(Object.assign(Object.assign({}, params), params.y), initialValue.y)
    ]
  });
}
function getSuitableMaxDimensionValue(params, rawValue) {
  var _a2, _b;
  if (!isEmpty(params.min) || !isEmpty(params.max)) {
    return Math.max(Math.abs((_a2 = params.min) !== null && _a2 !== void 0 ? _a2 : 0), Math.abs((_b = params.max) !== null && _b !== void 0 ? _b : 0));
  }
  const step = getSuitableKeyScale(params);
  return Math.max(Math.abs(step) * 10, Math.abs(rawValue) * 10);
}
function getSuitableMax(params, initialValue) {
  var _a2, _b;
  const xr2 = getSuitableMaxDimensionValue(deepMerge(params, (_a2 = params.x) !== null && _a2 !== void 0 ? _a2 : {}), initialValue.x);
  const yr2 = getSuitableMaxDimensionValue(deepMerge(params, (_b = params.y) !== null && _b !== void 0 ? _b : {}), initialValue.y);
  return Math.max(xr2, yr2);
}
function shouldInvertY(params) {
  if (!("y" in params)) {
    return false;
  }
  const yParams = params.y;
  if (!yParams) {
    return false;
  }
  return "inverted" in yParams ? !!yParams.inverted : false;
}
var Point2dInputPlugin = createPlugin({
  id: "input-point2d",
  type: "input",
  accept: (value, params) => {
    if (!Point2d.isObject(value)) {
      return null;
    }
    const result = parseRecord(params, (p) => Object.assign(Object.assign({}, createPointDimensionParser(p)), { expanded: p.optional.boolean, picker: p.optional.custom(parsePickerLayout), readonly: p.optional.constant(false), x: p.optional.custom(parsePointDimensionParams), y: p.optional.object(Object.assign(Object.assign({}, createPointDimensionParser(p)), { inverted: p.optional.boolean })) }));
    return result ? {
      initialValue: value,
      params: result
    } : null;
  },
  binding: {
    reader: () => point2dFromUnknown,
    constraint: (args) => createConstraint$3(args.params, args.initialValue),
    equals: Point2d.equals,
    writer: () => writePoint2d
  },
  controller: (args) => {
    var _a2, _b;
    const doc = args.document;
    const value = args.value;
    const c = args.constraint;
    const dParams = [args.params.x, args.params.y];
    return new Point2dController(doc, {
      axes: value.rawValue.getComponents().map((comp, i) => {
        var _a3;
        return createPointAxis({
          constraint: c.components[i],
          initialValue: comp,
          params: deepMerge(args.params, (_a3 = dParams[i]) !== null && _a3 !== void 0 ? _a3 : {})
        });
      }),
      expanded: (_a2 = args.params.expanded) !== null && _a2 !== void 0 ? _a2 : false,
      invertsY: shouldInvertY(args.params),
      max: getSuitableMax(args.params, value.rawValue),
      parser: parseNumber,
      pickerLayout: (_b = args.params.picker) !== null && _b !== void 0 ? _b : "popup",
      value,
      viewProps: args.viewProps
    });
  }
});
var Point3d = class {
  constructor(x = 0, y = 0, z = 0) {
    this.x = x;
    this.y = y;
    this.z = z;
  }
  getComponents() {
    return [this.x, this.y, this.z];
  }
  static isObject(obj) {
    if (isEmpty(obj)) {
      return false;
    }
    const x = obj.x;
    const y = obj.y;
    const z = obj.z;
    if (typeof x !== "number" || typeof y !== "number" || typeof z !== "number") {
      return false;
    }
    return true;
  }
  static equals(v1, v2) {
    return v1.x === v2.x && v1.y === v2.y && v1.z === v2.z;
  }
  toObject() {
    return {
      x: this.x,
      y: this.y,
      z: this.z
    };
  }
};
var Point3dAssembly = {
  toComponents: (p) => p.getComponents(),
  fromComponents: (comps) => new Point3d(...comps)
};
function point3dFromUnknown(value) {
  return Point3d.isObject(value) ? new Point3d(value.x, value.y, value.z) : new Point3d();
}
function writePoint3d(target, value) {
  target.writeProperty("x", value.x);
  target.writeProperty("y", value.y);
  target.writeProperty("z", value.z);
}
function createConstraint$2(params, initialValue) {
  return new PointNdConstraint({
    assembly: Point3dAssembly,
    components: [
      createDimensionConstraint(Object.assign(Object.assign({}, params), params.x), initialValue.x),
      createDimensionConstraint(Object.assign(Object.assign({}, params), params.y), initialValue.y),
      createDimensionConstraint(Object.assign(Object.assign({}, params), params.z), initialValue.z)
    ]
  });
}
var Point3dInputPlugin = createPlugin({
  id: "input-point3d",
  type: "input",
  accept: (value, params) => {
    if (!Point3d.isObject(value)) {
      return null;
    }
    const result = parseRecord(params, (p) => Object.assign(Object.assign({}, createPointDimensionParser(p)), { readonly: p.optional.constant(false), x: p.optional.custom(parsePointDimensionParams), y: p.optional.custom(parsePointDimensionParams), z: p.optional.custom(parsePointDimensionParams) }));
    return result ? {
      initialValue: value,
      params: result
    } : null;
  },
  binding: {
    reader: (_args) => point3dFromUnknown,
    constraint: (args) => createConstraint$2(args.params, args.initialValue),
    equals: Point3d.equals,
    writer: (_args) => writePoint3d
  },
  controller: (args) => {
    const value = args.value;
    const c = args.constraint;
    const dParams = [args.params.x, args.params.y, args.params.z];
    return new PointNdTextController(args.document, {
      assembly: Point3dAssembly,
      axes: value.rawValue.getComponents().map((comp, i) => {
        var _a2;
        return createPointAxis({
          constraint: c.components[i],
          initialValue: comp,
          params: deepMerge(args.params, (_a2 = dParams[i]) !== null && _a2 !== void 0 ? _a2 : {})
        });
      }),
      parser: parseNumber,
      value,
      viewProps: args.viewProps
    });
  }
});
var Point4d = class {
  constructor(x = 0, y = 0, z = 0, w = 0) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
  }
  getComponents() {
    return [this.x, this.y, this.z, this.w];
  }
  static isObject(obj) {
    if (isEmpty(obj)) {
      return false;
    }
    const x = obj.x;
    const y = obj.y;
    const z = obj.z;
    const w = obj.w;
    if (typeof x !== "number" || typeof y !== "number" || typeof z !== "number" || typeof w !== "number") {
      return false;
    }
    return true;
  }
  static equals(v1, v2) {
    return v1.x === v2.x && v1.y === v2.y && v1.z === v2.z && v1.w === v2.w;
  }
  toObject() {
    return {
      x: this.x,
      y: this.y,
      z: this.z,
      w: this.w
    };
  }
};
var Point4dAssembly = {
  toComponents: (p) => p.getComponents(),
  fromComponents: (comps) => new Point4d(...comps)
};
function point4dFromUnknown(value) {
  return Point4d.isObject(value) ? new Point4d(value.x, value.y, value.z, value.w) : new Point4d();
}
function writePoint4d(target, value) {
  target.writeProperty("x", value.x);
  target.writeProperty("y", value.y);
  target.writeProperty("z", value.z);
  target.writeProperty("w", value.w);
}
function createConstraint$1(params, initialValue) {
  return new PointNdConstraint({
    assembly: Point4dAssembly,
    components: [
      createDimensionConstraint(Object.assign(Object.assign({}, params), params.x), initialValue.x),
      createDimensionConstraint(Object.assign(Object.assign({}, params), params.y), initialValue.y),
      createDimensionConstraint(Object.assign(Object.assign({}, params), params.z), initialValue.z),
      createDimensionConstraint(Object.assign(Object.assign({}, params), params.w), initialValue.w)
    ]
  });
}
var Point4dInputPlugin = createPlugin({
  id: "input-point4d",
  type: "input",
  accept: (value, params) => {
    if (!Point4d.isObject(value)) {
      return null;
    }
    const result = parseRecord(params, (p) => Object.assign(Object.assign({}, createPointDimensionParser(p)), { readonly: p.optional.constant(false), w: p.optional.custom(parsePointDimensionParams), x: p.optional.custom(parsePointDimensionParams), y: p.optional.custom(parsePointDimensionParams), z: p.optional.custom(parsePointDimensionParams) }));
    return result ? {
      initialValue: value,
      params: result
    } : null;
  },
  binding: {
    reader: (_args) => point4dFromUnknown,
    constraint: (args) => createConstraint$1(args.params, args.initialValue),
    equals: Point4d.equals,
    writer: (_args) => writePoint4d
  },
  controller: (args) => {
    const value = args.value;
    const c = args.constraint;
    const dParams = [
      args.params.x,
      args.params.y,
      args.params.z,
      args.params.w
    ];
    return new PointNdTextController(args.document, {
      assembly: Point4dAssembly,
      axes: value.rawValue.getComponents().map((comp, i) => {
        var _a2;
        return createPointAxis({
          constraint: c.components[i],
          initialValue: comp,
          params: deepMerge(args.params, (_a2 = dParams[i]) !== null && _a2 !== void 0 ? _a2 : {})
        });
      }),
      parser: parseNumber,
      value,
      viewProps: args.viewProps
    });
  }
});
function createConstraint(params) {
  const constraints = [];
  const lc2 = createListConstraint(params.options);
  if (lc2) {
    constraints.push(lc2);
  }
  return new CompositeConstraint(constraints);
}
var StringInputPlugin = createPlugin({
  id: "input-string",
  type: "input",
  accept: (value, params) => {
    if (typeof value !== "string") {
      return null;
    }
    const result = parseRecord(params, (p) => ({
      readonly: p.optional.constant(false),
      options: p.optional.custom(parseListOptions)
    }));
    return result ? {
      initialValue: value,
      params: result
    } : null;
  },
  binding: {
    reader: (_args) => stringFromUnknown,
    constraint: (args) => createConstraint(args.params),
    writer: (_args) => writePrimitive
  },
  controller: (args) => {
    const doc = args.document;
    const value = args.value;
    const c = args.constraint;
    const lc2 = c && findConstraint(c, ListConstraint);
    if (lc2) {
      return new ListController(doc, {
        props: new ValueMap({
          options: lc2.values.value("options")
        }),
        value,
        viewProps: args.viewProps
      });
    }
    return new TextController(doc, {
      parser: (v) => v,
      props: ValueMap.fromObject({
        formatter: formatString
      }),
      value,
      viewProps: args.viewProps
    });
  },
  api(args) {
    if (typeof args.controller.value.rawValue !== "string") {
      return null;
    }
    if (args.controller.valueController instanceof ListController) {
      return new ListInputBindingApi(args.controller);
    }
    return null;
  }
});
var Constants = {
  monitor: {
    defaultInterval: 200,
    defaultRows: 3
  }
};
var cn$3 = ClassName("mll");
var MultiLogView = class {
  constructor(doc, config) {
    this.onValueUpdate_ = this.onValueUpdate_.bind(this);
    this.formatter_ = config.formatter;
    this.element = doc.createElement("div");
    this.element.classList.add(cn$3());
    config.viewProps.bindClassModifiers(this.element);
    const textareaElem = doc.createElement("textarea");
    textareaElem.classList.add(cn$3("i"));
    textareaElem.style.height = `calc(var(${getCssVar("containerUnitSize")}) * ${config.rows})`;
    textareaElem.readOnly = true;
    config.viewProps.bindDisabled(textareaElem);
    this.element.appendChild(textareaElem);
    this.textareaElem_ = textareaElem;
    config.value.emitter.on("change", this.onValueUpdate_);
    this.value = config.value;
    this.update_();
  }
  update_() {
    const elem = this.textareaElem_;
    const shouldScroll = elem.scrollTop === elem.scrollHeight - elem.clientHeight;
    const lines = [];
    this.value.rawValue.forEach((value) => {
      if (value !== void 0) {
        lines.push(this.formatter_(value));
      }
    });
    elem.textContent = lines.join("\n");
    if (shouldScroll) {
      elem.scrollTop = elem.scrollHeight;
    }
  }
  onValueUpdate_() {
    this.update_();
  }
};
var MultiLogController = class {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new MultiLogView(doc, {
      formatter: config.formatter,
      rows: config.rows,
      value: this.value,
      viewProps: this.viewProps
    });
  }
};
var cn$2 = ClassName("sgl");
var SingleLogView = class {
  constructor(doc, config) {
    this.onValueUpdate_ = this.onValueUpdate_.bind(this);
    this.formatter_ = config.formatter;
    this.element = doc.createElement("div");
    this.element.classList.add(cn$2());
    config.viewProps.bindClassModifiers(this.element);
    const inputElem = doc.createElement("input");
    inputElem.classList.add(cn$2("i"));
    inputElem.readOnly = true;
    inputElem.type = "text";
    config.viewProps.bindDisabled(inputElem);
    this.element.appendChild(inputElem);
    this.inputElement = inputElem;
    config.value.emitter.on("change", this.onValueUpdate_);
    this.value = config.value;
    this.update_();
  }
  update_() {
    const values = this.value.rawValue;
    const lastValue = values[values.length - 1];
    this.inputElement.value = lastValue !== void 0 ? this.formatter_(lastValue) : "";
  }
  onValueUpdate_() {
    this.update_();
  }
};
var SingleLogController = class {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new SingleLogView(doc, {
      formatter: config.formatter,
      value: this.value,
      viewProps: this.viewProps
    });
  }
};
var BooleanMonitorPlugin = createPlugin({
  id: "monitor-bool",
  type: "monitor",
  accept: (value, params) => {
    if (typeof value !== "boolean") {
      return null;
    }
    const result = parseRecord(params, (p) => ({
      readonly: p.required.constant(true),
      rows: p.optional.number
    }));
    return result ? {
      initialValue: value,
      params: result
    } : null;
  },
  binding: {
    reader: (_args) => boolFromUnknown
  },
  controller: (args) => {
    var _a2;
    if (args.value.rawValue.length === 1) {
      return new SingleLogController(args.document, {
        formatter: BooleanFormatter,
        value: args.value,
        viewProps: args.viewProps
      });
    }
    return new MultiLogController(args.document, {
      formatter: BooleanFormatter,
      rows: (_a2 = args.params.rows) !== null && _a2 !== void 0 ? _a2 : Constants.monitor.defaultRows,
      value: args.value,
      viewProps: args.viewProps
    });
  }
});
var GraphLogMonitorBindingApi = class extends BindingApi {
  get max() {
    return this.controller.valueController.props.get("max");
  }
  set max(max) {
    this.controller.valueController.props.set("max", max);
  }
  get min() {
    return this.controller.valueController.props.get("min");
  }
  set min(min) {
    this.controller.valueController.props.set("min", min);
  }
};
var cn$1 = ClassName("grl");
var GraphLogView = class {
  constructor(doc, config) {
    this.onCursorChange_ = this.onCursorChange_.bind(this);
    this.onValueUpdate_ = this.onValueUpdate_.bind(this);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$1());
    config.viewProps.bindClassModifiers(this.element);
    this.formatter_ = config.formatter;
    this.props_ = config.props;
    this.cursor_ = config.cursor;
    this.cursor_.emitter.on("change", this.onCursorChange_);
    const svgElem = doc.createElementNS(SVG_NS, "svg");
    svgElem.classList.add(cn$1("g"));
    svgElem.style.height = `calc(var(${getCssVar("containerUnitSize")}) * ${config.rows})`;
    this.element.appendChild(svgElem);
    this.svgElem_ = svgElem;
    const lineElem = doc.createElementNS(SVG_NS, "polyline");
    this.svgElem_.appendChild(lineElem);
    this.lineElem_ = lineElem;
    const tooltipElem = doc.createElement("div");
    tooltipElem.classList.add(cn$1("t"), ClassName("tt")());
    this.element.appendChild(tooltipElem);
    this.tooltipElem_ = tooltipElem;
    config.value.emitter.on("change", this.onValueUpdate_);
    this.value = config.value;
    this.update_();
  }
  get graphElement() {
    return this.svgElem_;
  }
  update_() {
    const bounds = this.svgElem_.getBoundingClientRect();
    const maxIndex = this.value.rawValue.length - 1;
    const min = this.props_.get("min");
    const max = this.props_.get("max");
    const points = [];
    this.value.rawValue.forEach((v, index) => {
      if (v === void 0) {
        return;
      }
      const x = mapRange(index, 0, maxIndex, 0, bounds.width);
      const y = mapRange(v, min, max, bounds.height, 0);
      points.push([x, y].join(","));
    });
    this.lineElem_.setAttributeNS(null, "points", points.join(" "));
    const tooltipElem = this.tooltipElem_;
    const value = this.value.rawValue[this.cursor_.rawValue];
    if (value === void 0) {
      tooltipElem.classList.remove(cn$1("t", "a"));
      return;
    }
    const tx = mapRange(this.cursor_.rawValue, 0, maxIndex, 0, bounds.width);
    const ty = mapRange(value, min, max, bounds.height, 0);
    tooltipElem.style.left = `${tx}px`;
    tooltipElem.style.top = `${ty}px`;
    tooltipElem.textContent = `${this.formatter_(value)}`;
    if (!tooltipElem.classList.contains(cn$1("t", "a"))) {
      tooltipElem.classList.add(cn$1("t", "a"), cn$1("t", "in"));
      forceReflow(tooltipElem);
      tooltipElem.classList.remove(cn$1("t", "in"));
    }
  }
  onValueUpdate_() {
    this.update_();
  }
  onCursorChange_() {
    this.update_();
  }
};
var GraphLogController = class {
  constructor(doc, config) {
    this.onGraphMouseMove_ = this.onGraphMouseMove_.bind(this);
    this.onGraphMouseLeave_ = this.onGraphMouseLeave_.bind(this);
    this.onGraphPointerDown_ = this.onGraphPointerDown_.bind(this);
    this.onGraphPointerMove_ = this.onGraphPointerMove_.bind(this);
    this.onGraphPointerUp_ = this.onGraphPointerUp_.bind(this);
    this.props = config.props;
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.cursor_ = createValue(-1);
    this.view = new GraphLogView(doc, {
      cursor: this.cursor_,
      formatter: config.formatter,
      rows: config.rows,
      props: this.props,
      value: this.value,
      viewProps: this.viewProps
    });
    if (!supportsTouch(doc)) {
      this.view.element.addEventListener("mousemove", this.onGraphMouseMove_);
      this.view.element.addEventListener("mouseleave", this.onGraphMouseLeave_);
    } else {
      const ph = new PointerHandler(this.view.element);
      ph.emitter.on("down", this.onGraphPointerDown_);
      ph.emitter.on("move", this.onGraphPointerMove_);
      ph.emitter.on("up", this.onGraphPointerUp_);
    }
  }
  importProps(state) {
    return importBladeState(state, null, (p) => ({
      max: p.required.number,
      min: p.required.number
    }), (result) => {
      this.props.set("max", result.max);
      this.props.set("min", result.min);
      return true;
    });
  }
  exportProps() {
    return exportBladeState(null, {
      max: this.props.get("max"),
      min: this.props.get("min")
    });
  }
  onGraphMouseLeave_() {
    this.cursor_.rawValue = -1;
  }
  onGraphMouseMove_(ev) {
    const bounds = this.view.element.getBoundingClientRect();
    this.cursor_.rawValue = Math.floor(mapRange(ev.offsetX, 0, bounds.width, 0, this.value.rawValue.length));
  }
  onGraphPointerDown_(ev) {
    this.onGraphPointerMove_(ev);
  }
  onGraphPointerMove_(ev) {
    if (!ev.data.point) {
      this.cursor_.rawValue = -1;
      return;
    }
    this.cursor_.rawValue = Math.floor(mapRange(ev.data.point.x, 0, ev.data.bounds.width, 0, this.value.rawValue.length));
  }
  onGraphPointerUp_() {
    this.cursor_.rawValue = -1;
  }
};
function createFormatter(params) {
  return !isEmpty(params.format) ? params.format : createNumberFormatter(2);
}
function createTextMonitor(args) {
  var _a2;
  if (args.value.rawValue.length === 1) {
    return new SingleLogController(args.document, {
      formatter: createFormatter(args.params),
      value: args.value,
      viewProps: args.viewProps
    });
  }
  return new MultiLogController(args.document, {
    formatter: createFormatter(args.params),
    rows: (_a2 = args.params.rows) !== null && _a2 !== void 0 ? _a2 : Constants.monitor.defaultRows,
    value: args.value,
    viewProps: args.viewProps
  });
}
function createGraphMonitor(args) {
  var _a2, _b, _c2;
  return new GraphLogController(args.document, {
    formatter: createFormatter(args.params),
    rows: (_a2 = args.params.rows) !== null && _a2 !== void 0 ? _a2 : Constants.monitor.defaultRows,
    props: ValueMap.fromObject({
      max: (_b = args.params.max) !== null && _b !== void 0 ? _b : 100,
      min: (_c2 = args.params.min) !== null && _c2 !== void 0 ? _c2 : 0
    }),
    value: args.value,
    viewProps: args.viewProps
  });
}
function shouldShowGraph(params) {
  return params.view === "graph";
}
var NumberMonitorPlugin = createPlugin({
  id: "monitor-number",
  type: "monitor",
  accept: (value, params) => {
    if (typeof value !== "number") {
      return null;
    }
    const result = parseRecord(params, (p) => ({
      format: p.optional.function,
      max: p.optional.number,
      min: p.optional.number,
      readonly: p.required.constant(true),
      rows: p.optional.number,
      view: p.optional.string
    }));
    return result ? {
      initialValue: value,
      params: result
    } : null;
  },
  binding: {
    defaultBufferSize: (params) => shouldShowGraph(params) ? 64 : 1,
    reader: (_args) => numberFromUnknown
  },
  controller: (args) => {
    if (shouldShowGraph(args.params)) {
      return createGraphMonitor(args);
    }
    return createTextMonitor(args);
  },
  api: (args) => {
    if (args.controller.valueController instanceof GraphLogController) {
      return new GraphLogMonitorBindingApi(args.controller);
    }
    return null;
  }
});
var StringMonitorPlugin = createPlugin({
  id: "monitor-string",
  type: "monitor",
  accept: (value, params) => {
    if (typeof value !== "string") {
      return null;
    }
    const result = parseRecord(params, (p) => ({
      multiline: p.optional.boolean,
      readonly: p.required.constant(true),
      rows: p.optional.number
    }));
    return result ? {
      initialValue: value,
      params: result
    } : null;
  },
  binding: {
    reader: (_args) => stringFromUnknown
  },
  controller: (args) => {
    var _a2;
    const value = args.value;
    const multiline = value.rawValue.length > 1 || args.params.multiline;
    if (multiline) {
      return new MultiLogController(args.document, {
        formatter: formatString,
        rows: (_a2 = args.params.rows) !== null && _a2 !== void 0 ? _a2 : Constants.monitor.defaultRows,
        value,
        viewProps: args.viewProps
      });
    }
    return new SingleLogController(args.document, {
      formatter: formatString,
      value,
      viewProps: args.viewProps
    });
  }
});
var BladeApiCache = class {
  constructor() {
    this.map_ = /* @__PURE__ */ new Map();
  }
  get(bc2) {
    var _a2;
    return (_a2 = this.map_.get(bc2)) !== null && _a2 !== void 0 ? _a2 : null;
  }
  has(bc2) {
    return this.map_.has(bc2);
  }
  add(bc2, api) {
    this.map_.set(bc2, api);
    bc2.viewProps.handleDispose(() => {
      this.map_.delete(bc2);
    });
    return api;
  }
};
var ReadWriteBinding = class {
  constructor(config) {
    this.target = config.target;
    this.reader_ = config.reader;
    this.writer_ = config.writer;
  }
  read() {
    return this.reader_(this.target.read());
  }
  write(value) {
    this.writer_(this.target, value);
  }
  inject(value) {
    this.write(this.reader_(value));
  }
};
function createInputBindingController(plugin, args) {
  var _a2;
  const result = plugin.accept(args.target.read(), args.params);
  if (isEmpty(result)) {
    return null;
  }
  const valueArgs = {
    target: args.target,
    initialValue: result.initialValue,
    params: result.params
  };
  const params = parseRecord(args.params, (p) => ({
    disabled: p.optional.boolean,
    hidden: p.optional.boolean,
    label: p.optional.string,
    tag: p.optional.string
  }));
  const reader = plugin.binding.reader(valueArgs);
  const constraint = plugin.binding.constraint ? plugin.binding.constraint(valueArgs) : void 0;
  const binding = new ReadWriteBinding({
    reader,
    target: args.target,
    writer: plugin.binding.writer(valueArgs)
  });
  const value = new InputBindingValue(createValue(reader(result.initialValue), {
    constraint,
    equals: plugin.binding.equals
  }), binding);
  const controller = plugin.controller({
    constraint,
    document: args.document,
    initialValue: result.initialValue,
    params: result.params,
    value,
    viewProps: ViewProps.create({
      disabled: params === null || params === void 0 ? void 0 : params.disabled,
      hidden: params === null || params === void 0 ? void 0 : params.hidden
    })
  });
  return new InputBindingController(args.document, {
    blade: createBlade(),
    props: ValueMap.fromObject({
      label: "label" in args.params ? (_a2 = params === null || params === void 0 ? void 0 : params.label) !== null && _a2 !== void 0 ? _a2 : null : args.target.key
    }),
    tag: params === null || params === void 0 ? void 0 : params.tag,
    value,
    valueController: controller
  });
}
var ReadonlyBinding = class {
  constructor(config) {
    this.target = config.target;
    this.reader_ = config.reader;
  }
  read() {
    return this.reader_(this.target.read());
  }
};
function createTicker(document2, interval) {
  return interval === 0 ? new ManualTicker() : new IntervalTicker(document2, interval !== null && interval !== void 0 ? interval : Constants.monitor.defaultInterval);
}
function createMonitorBindingController(plugin, args) {
  var _a2, _b, _c2;
  const result = plugin.accept(args.target.read(), args.params);
  if (isEmpty(result)) {
    return null;
  }
  const bindingArgs = {
    target: args.target,
    initialValue: result.initialValue,
    params: result.params
  };
  const params = parseRecord(args.params, (p) => ({
    bufferSize: p.optional.number,
    disabled: p.optional.boolean,
    hidden: p.optional.boolean,
    interval: p.optional.number,
    label: p.optional.string
  }));
  const reader = plugin.binding.reader(bindingArgs);
  const bufferSize = (_b = (_a2 = params === null || params === void 0 ? void 0 : params.bufferSize) !== null && _a2 !== void 0 ? _a2 : plugin.binding.defaultBufferSize && plugin.binding.defaultBufferSize(result.params)) !== null && _b !== void 0 ? _b : 1;
  const value = new MonitorBindingValue({
    binding: new ReadonlyBinding({
      reader,
      target: args.target
    }),
    bufferSize,
    ticker: createTicker(args.document, params === null || params === void 0 ? void 0 : params.interval)
  });
  const controller = plugin.controller({
    document: args.document,
    params: result.params,
    value,
    viewProps: ViewProps.create({
      disabled: params === null || params === void 0 ? void 0 : params.disabled,
      hidden: params === null || params === void 0 ? void 0 : params.hidden
    })
  });
  controller.viewProps.bindDisabled(value.ticker);
  controller.viewProps.handleDispose(() => {
    value.ticker.dispose();
  });
  return new MonitorBindingController(args.document, {
    blade: createBlade(),
    props: ValueMap.fromObject({
      label: "label" in args.params ? (_c2 = params === null || params === void 0 ? void 0 : params.label) !== null && _c2 !== void 0 ? _c2 : null : args.target.key
    }),
    value,
    valueController: controller
  });
}
var PluginPool = class {
  constructor(apiCache) {
    this.pluginsMap_ = {
      blades: [],
      inputs: [],
      monitors: []
    };
    this.apiCache_ = apiCache;
  }
  getAll() {
    return [
      ...this.pluginsMap_.blades,
      ...this.pluginsMap_.inputs,
      ...this.pluginsMap_.monitors
    ];
  }
  register(bundleId, r) {
    if (!isCompatible(r.core)) {
      throw TpError.notCompatible(bundleId, r.id);
    }
    if (r.type === "blade") {
      this.pluginsMap_.blades.unshift(r);
    } else if (r.type === "input") {
      this.pluginsMap_.inputs.unshift(r);
    } else if (r.type === "monitor") {
      this.pluginsMap_.monitors.unshift(r);
    }
  }
  createInput_(document2, target, params) {
    return this.pluginsMap_.inputs.reduce((result, plugin) => result !== null && result !== void 0 ? result : createInputBindingController(plugin, {
      document: document2,
      target,
      params
    }), null);
  }
  createMonitor_(document2, target, params) {
    return this.pluginsMap_.monitors.reduce((result, plugin) => result !== null && result !== void 0 ? result : createMonitorBindingController(plugin, {
      document: document2,
      params,
      target
    }), null);
  }
  createBinding(doc, target, params) {
    const initialValue = target.read();
    if (isEmpty(initialValue)) {
      throw new TpError({
        context: {
          key: target.key
        },
        type: "nomatchingcontroller"
      });
    }
    const ic2 = this.createInput_(doc, target, params);
    if (ic2) {
      return ic2;
    }
    const mc = this.createMonitor_(doc, target, params);
    if (mc) {
      return mc;
    }
    throw new TpError({
      context: {
        key: target.key
      },
      type: "nomatchingcontroller"
    });
  }
  createBlade(document2, params) {
    const bc2 = this.pluginsMap_.blades.reduce((result, plugin) => result !== null && result !== void 0 ? result : createBladeController(plugin, {
      document: document2,
      params
    }), null);
    if (!bc2) {
      throw new TpError({
        type: "nomatchingview",
        context: {
          params
        }
      });
    }
    return bc2;
  }
  createInputBindingApi_(bc2) {
    const api = this.pluginsMap_.inputs.reduce((result, plugin) => {
      var _a2, _b;
      if (result) {
        return result;
      }
      return (_b = (_a2 = plugin.api) === null || _a2 === void 0 ? void 0 : _a2.call(plugin, {
        controller: bc2
      })) !== null && _b !== void 0 ? _b : null;
    }, null);
    return this.apiCache_.add(bc2, api !== null && api !== void 0 ? api : new BindingApi(bc2));
  }
  createMonitorBindingApi_(bc2) {
    const api = this.pluginsMap_.monitors.reduce((result, plugin) => {
      var _a2, _b;
      if (result) {
        return result;
      }
      return (_b = (_a2 = plugin.api) === null || _a2 === void 0 ? void 0 : _a2.call(plugin, {
        controller: bc2
      })) !== null && _b !== void 0 ? _b : null;
    }, null);
    return this.apiCache_.add(bc2, api !== null && api !== void 0 ? api : new BindingApi(bc2));
  }
  createBindingApi(bc2) {
    if (this.apiCache_.has(bc2)) {
      return this.apiCache_.get(bc2);
    }
    if (isInputBindingController(bc2)) {
      return this.createInputBindingApi_(bc2);
    }
    if (isMonitorBindingController(bc2)) {
      return this.createMonitorBindingApi_(bc2);
    }
    throw TpError.shouldNeverHappen();
  }
  createApi(bc2) {
    if (this.apiCache_.has(bc2)) {
      return this.apiCache_.get(bc2);
    }
    if (isBindingController(bc2)) {
      return this.createBindingApi(bc2);
    }
    const api = this.pluginsMap_.blades.reduce((result, plugin) => result !== null && result !== void 0 ? result : plugin.api({
      controller: bc2,
      pool: this
    }), null);
    if (!api) {
      throw TpError.shouldNeverHappen();
    }
    return this.apiCache_.add(bc2, api);
  }
};
var sharedCache = new BladeApiCache();
function createDefaultPluginPool() {
  const pool = new PluginPool(sharedCache);
  [
    Point2dInputPlugin,
    Point3dInputPlugin,
    Point4dInputPlugin,
    StringInputPlugin,
    NumberInputPlugin,
    StringColorInputPlugin,
    ObjectColorInputPlugin,
    NumberColorInputPlugin,
    BooleanInputPlugin,
    BooleanMonitorPlugin,
    StringMonitorPlugin,
    NumberMonitorPlugin,
    ButtonBladePlugin,
    FolderBladePlugin,
    TabBladePlugin
  ].forEach((p) => {
    pool.register("core", p);
  });
  return pool;
}
var ListBladeApi = class extends BladeApi {
  /**
   * @hidden
   */
  constructor(controller) {
    super(controller);
    this.emitter_ = new Emitter();
    this.controller.value.emitter.on("change", (ev) => {
      this.emitter_.emit("change", new TpChangeEvent(this, ev.rawValue));
    });
  }
  get label() {
    return this.controller.labelController.props.get("label");
  }
  set label(label) {
    this.controller.labelController.props.set("label", label);
  }
  get options() {
    return this.controller.valueController.props.get("options");
  }
  set options(options) {
    this.controller.valueController.props.set("options", options);
  }
  get value() {
    return this.controller.value.rawValue;
  }
  set value(value) {
    this.controller.value.rawValue = value;
  }
  on(eventName, handler) {
    const bh = handler.bind(this);
    this.emitter_.on(eventName, (ev) => {
      bh(ev);
    });
    return this;
  }
};
var SeparatorBladeApi = class extends BladeApi {
};
var SliderBladeApi = class extends BladeApi {
  /**
   * @hidden
   */
  constructor(controller) {
    super(controller);
    this.emitter_ = new Emitter();
    this.controller.value.emitter.on("change", (ev) => {
      this.emitter_.emit("change", new TpChangeEvent(this, ev.rawValue));
    });
  }
  get label() {
    return this.controller.labelController.props.get("label");
  }
  set label(label) {
    this.controller.labelController.props.set("label", label);
  }
  get max() {
    return this.controller.valueController.sliderController.props.get("max");
  }
  set max(max) {
    this.controller.valueController.sliderController.props.set("max", max);
  }
  get min() {
    return this.controller.valueController.sliderController.props.get("min");
  }
  set min(min) {
    this.controller.valueController.sliderController.props.set("min", min);
  }
  get value() {
    return this.controller.value.rawValue;
  }
  set value(value) {
    this.controller.value.rawValue = value;
  }
  on(eventName, handler) {
    const bh = handler.bind(this);
    this.emitter_.on(eventName, (ev) => {
      bh(ev);
    });
    return this;
  }
};
var TextBladeApi = class extends BladeApi {
  /**
   * @hidden
   */
  constructor(controller) {
    super(controller);
    this.emitter_ = new Emitter();
    this.controller.value.emitter.on("change", (ev) => {
      this.emitter_.emit("change", new TpChangeEvent(this, ev.rawValue));
    });
  }
  get label() {
    return this.controller.labelController.props.get("label");
  }
  set label(label) {
    this.controller.labelController.props.set("label", label);
  }
  get formatter() {
    return this.controller.valueController.props.get("formatter");
  }
  set formatter(formatter) {
    this.controller.valueController.props.set("formatter", formatter);
  }
  get value() {
    return this.controller.value.rawValue;
  }
  set value(value) {
    this.controller.value.rawValue = value;
  }
  on(eventName, handler) {
    const bh = handler.bind(this);
    this.emitter_.on(eventName, (ev) => {
      bh(ev);
    });
    return this;
  }
};
var ListBladePlugin = function() {
  return {
    id: "list",
    type: "blade",
    core: VERSION$1,
    accept(params) {
      const result = parseRecord(params, (p) => ({
        options: p.required.custom(parseListOptions),
        value: p.required.raw,
        view: p.required.constant("list"),
        label: p.optional.string
      }));
      return result ? { params: result } : null;
    },
    controller(args) {
      const lc2 = new ListConstraint(normalizeListOptions(args.params.options));
      const value = createValue(args.params.value, {
        constraint: lc2
      });
      const ic2 = new ListController(args.document, {
        props: new ValueMap({
          options: lc2.values.value("options")
        }),
        value,
        viewProps: args.viewProps
      });
      return new LabeledValueBladeController(args.document, {
        blade: args.blade,
        props: ValueMap.fromObject({
          label: args.params.label
        }),
        value,
        valueController: ic2
      });
    },
    api(args) {
      if (!(args.controller instanceof LabeledValueBladeController)) {
        return null;
      }
      if (!(args.controller.valueController instanceof ListController)) {
        return null;
      }
      return new ListBladeApi(args.controller);
    }
  };
}();
var RootApi = class extends FolderApi {
  /**
   * @hidden
   */
  constructor(controller, pool) {
    super(controller, pool);
  }
  get element() {
    return this.controller.view.element;
  }
};
var RootController = class extends FolderController {
  constructor(doc, config) {
    super(doc, {
      expanded: config.expanded,
      blade: config.blade,
      props: config.props,
      root: true,
      viewProps: config.viewProps
    });
  }
};
var cn = ClassName("spr");
var SeparatorView = class {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn());
    config.viewProps.bindClassModifiers(this.element);
    const hrElem = doc.createElement("hr");
    hrElem.classList.add(cn("r"));
    this.element.appendChild(hrElem);
  }
};
var SeparatorController = class extends BladeController {
  /**
   * @hidden
   */
  constructor(doc, config) {
    super(Object.assign(Object.assign({}, config), { view: new SeparatorView(doc, {
      viewProps: config.viewProps
    }) }));
  }
};
var SeparatorBladePlugin = {
  id: "separator",
  type: "blade",
  core: VERSION$1,
  accept(params) {
    const result = parseRecord(params, (p) => ({
      view: p.required.constant("separator")
    }));
    return result ? { params: result } : null;
  },
  controller(args) {
    return new SeparatorController(args.document, {
      blade: args.blade,
      viewProps: args.viewProps
    });
  },
  api(args) {
    if (!(args.controller instanceof SeparatorController)) {
      return null;
    }
    return new SeparatorBladeApi(args.controller);
  }
};
var SliderBladePlugin = {
  id: "slider",
  type: "blade",
  core: VERSION$1,
  accept(params) {
    const result = parseRecord(params, (p) => ({
      max: p.required.number,
      min: p.required.number,
      view: p.required.constant("slider"),
      format: p.optional.function,
      label: p.optional.string,
      value: p.optional.number
    }));
    return result ? { params: result } : null;
  },
  controller(args) {
    var _a2, _b;
    const initialValue = (_a2 = args.params.value) !== null && _a2 !== void 0 ? _a2 : 0;
    const drc = new DefiniteRangeConstraint({
      max: args.params.max,
      min: args.params.min
    });
    const v = createValue(initialValue, {
      constraint: drc
    });
    const vc2 = new SliderTextController(args.document, Object.assign(Object.assign({}, createSliderTextProps({
      formatter: (_b = args.params.format) !== null && _b !== void 0 ? _b : numberToString,
      keyScale: createValue(1),
      max: drc.values.value("max"),
      min: drc.values.value("min"),
      pointerScale: getSuitablePointerScale(args.params, initialValue)
    })), { parser: parseNumber, value: v, viewProps: args.viewProps }));
    return new LabeledValueBladeController(args.document, {
      blade: args.blade,
      props: ValueMap.fromObject({
        label: args.params.label
      }),
      value: v,
      valueController: vc2
    });
  },
  api(args) {
    if (!(args.controller instanceof LabeledValueBladeController)) {
      return null;
    }
    if (!(args.controller.valueController instanceof SliderTextController)) {
      return null;
    }
    return new SliderBladeApi(args.controller);
  }
};
var TextBladePlugin = function() {
  return {
    id: "text",
    type: "blade",
    core: VERSION$1,
    accept(params) {
      const result = parseRecord(params, (p) => ({
        parse: p.required.function,
        value: p.required.raw,
        view: p.required.constant("text"),
        format: p.optional.function,
        label: p.optional.string
      }));
      return result ? { params: result } : null;
    },
    controller(args) {
      var _a2;
      const v = createValue(args.params.value);
      const ic2 = new TextController(args.document, {
        parser: args.params.parse,
        props: ValueMap.fromObject({
          formatter: (_a2 = args.params.format) !== null && _a2 !== void 0 ? _a2 : (v2) => String(v2)
        }),
        value: v,
        viewProps: args.viewProps
      });
      return new LabeledValueBladeController(args.document, {
        blade: args.blade,
        props: ValueMap.fromObject({
          label: args.params.label
        }),
        value: v,
        valueController: ic2
      });
    },
    api(args) {
      if (!(args.controller instanceof LabeledValueBladeController)) {
        return null;
      }
      if (!(args.controller.valueController instanceof TextController)) {
        return null;
      }
      return new TextBladeApi(args.controller);
    }
  };
}();
function createDefaultWrapperElement(doc) {
  const elem = doc.createElement("div");
  elem.classList.add(ClassName("dfw")());
  if (doc.body) {
    doc.body.appendChild(elem);
  }
  return elem;
}
function embedStyle(doc, id, css) {
  if (doc.querySelector(`style[data-tp-style=${id}]`)) {
    return;
  }
  const styleElem = doc.createElement("style");
  styleElem.dataset.tpStyle = id;
  styleElem.textContent = css;
  doc.head.appendChild(styleElem);
}
var Pane = class extends RootApi {
  constructor(opt_config) {
    var _a2, _b;
    const config = opt_config !== null && opt_config !== void 0 ? opt_config : {};
    const doc = (_a2 = config.document) !== null && _a2 !== void 0 ? _a2 : getWindowDocument();
    const pool = createDefaultPluginPool();
    const rootController = new RootController(doc, {
      expanded: config.expanded,
      blade: createBlade(),
      props: ValueMap.fromObject({
        title: config.title
      }),
      viewProps: ViewProps.create()
    });
    super(rootController, pool);
    this.pool_ = pool;
    this.containerElem_ = (_b = config.container) !== null && _b !== void 0 ? _b : createDefaultWrapperElement(doc);
    this.containerElem_.appendChild(this.element);
    this.doc_ = doc;
    this.usesDefaultWrapper_ = !config.container;
    this.setUpDefaultPlugins_();
  }
  get document() {
    if (!this.doc_) {
      throw TpError.alreadyDisposed();
    }
    return this.doc_;
  }
  dispose() {
    const containerElem = this.containerElem_;
    if (!containerElem) {
      throw TpError.alreadyDisposed();
    }
    if (this.usesDefaultWrapper_) {
      const parentElem = containerElem.parentElement;
      if (parentElem) {
        parentElem.removeChild(containerElem);
      }
    }
    this.containerElem_ = null;
    this.doc_ = null;
    super.dispose();
  }
  registerPlugin(bundle) {
    if (bundle.css) {
      embedStyle(this.document, `plugin-${bundle.id}`, bundle.css);
    }
    const plugins = "plugin" in bundle ? [bundle.plugin] : "plugins" in bundle ? bundle.plugins : [];
    plugins.forEach((p) => {
      this.pool_.register(bundle.id, p);
    });
  }
  setUpDefaultPlugins_() {
    this.registerPlugin({
      id: "default",
      // NOTE: This string literal will be replaced with the default CSS by Rollup at the compilation time
      css: '.tp-tbiv_b,.tp-coltxtv_ms,.tp-colswv_b,.tp-ckbv_i,.tp-sglv_i,.tp-mllv_i,.tp-grlv_g,.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw,.tp-rotv_b,.tp-fldv_b,.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{background-color:var(--btn-bg);border-radius:var(--bld-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--cnt-usz);line-height:var(--cnt-usz);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-p2dv_b:hover,.tp-btnv_b:hover,.tp-lstv_s:hover{background-color:var(--btn-bg-h)}.tp-p2dv_b:focus,.tp-btnv_b:focus,.tp-lstv_s:focus{background-color:var(--btn-bg-f)}.tp-p2dv_b:active,.tp-btnv_b:active,.tp-lstv_s:active{background-color:var(--btn-bg-a)}.tp-p2dv_b:disabled,.tp-btnv_b:disabled,.tp-lstv_s:disabled{opacity:.5}.tp-rotv_c>.tp-cntv.tp-v-lst,.tp-tbpv_c>.tp-cntv.tp-v-lst,.tp-fldv_c>.tp-cntv.tp-v-lst{margin-bottom:calc(-1 * var(--cnt-vp))}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-tbpv_c>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_c{border-bottom-left-radius:0}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-tbpv_c>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_b{border-bottom-left-radius:0}.tp-rotv_c>*:not(.tp-v-fst),.tp-tbpv_c>*:not(.tp-v-fst),.tp-fldv_c>*:not(.tp-v-fst){margin-top:var(--cnt-usp)}.tp-rotv_c>.tp-sprv:not(.tp-v-fst),.tp-tbpv_c>.tp-sprv:not(.tp-v-fst),.tp-fldv_c>.tp-sprv:not(.tp-v-fst),.tp-rotv_c>.tp-cntv:not(.tp-v-fst),.tp-tbpv_c>.tp-cntv:not(.tp-v-fst),.tp-fldv_c>.tp-cntv:not(.tp-v-fst){margin-top:var(--cnt-vp)}.tp-rotv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-tbpv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-rotv_c>.tp-cntv+*:not(.tp-v-hidden),.tp-tbpv_c>.tp-cntv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-cntv+*:not(.tp-v-hidden){margin-top:var(--cnt-vp)}.tp-rotv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-tbpv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-fldv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-rotv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-tbpv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-fldv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv{margin-top:0}.tp-tbpv_c>.tp-cntv,.tp-fldv_c>.tp-cntv{margin-left:4px}.tp-tbpv_c>.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-fldv>.tp-fldv_b{border-top-left-radius:var(--bld-br);border-bottom-left-radius:var(--bld-br)}.tp-tbpv_c>.tp-fldv.tp-fldv-expanded>.tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-fldv-expanded>.tp-fldv_b{border-bottom-left-radius:0}.tp-tbpv_c .tp-fldv>.tp-fldv_c,.tp-fldv_c .tp-fldv>.tp-fldv_c{border-bottom-left-radius:var(--bld-br)}.tp-tbpv_c>.tp-cntv+.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-cntv+.tp-fldv>.tp-fldv_b{border-top-left-radius:0}.tp-tbpv_c>.tp-cntv+.tp-tabv>.tp-tabv_t,.tp-fldv_c>.tp-cntv+.tp-tabv>.tp-tabv_t{border-top-left-radius:0}.tp-tbpv_c>.tp-tabv>.tp-tabv_t,.tp-fldv_c>.tp-tabv>.tp-tabv_t{border-top-left-radius:var(--bld-br)}.tp-tbpv_c .tp-tabv>.tp-tabv_c,.tp-fldv_c .tp-tabv>.tp-tabv_c{border-bottom-left-radius:var(--bld-br)}.tp-rotv_b,.tp-fldv_b{background-color:var(--cnt-bg);color:var(--cnt-fg);cursor:pointer;display:block;height:calc(var(--cnt-usz) + 4px);line-height:calc(var(--cnt-usz) + 4px);overflow:hidden;padding-left:var(--cnt-hp);padding-right:calc(		2px * 2 + var(--cnt-usz) + var(--cnt-hp)	);position:relative;text-align:left;text-overflow:ellipsis;white-space:nowrap;width:100%;transition:border-radius .2s ease-in-out .2s}.tp-rotv_b:hover,.tp-fldv_b:hover{background-color:var(--cnt-bg-h)}.tp-rotv_b:focus,.tp-fldv_b:focus{background-color:var(--cnt-bg-f)}.tp-rotv_b:active,.tp-fldv_b:active{background-color:var(--cnt-bg-a)}.tp-rotv_b:disabled,.tp-fldv_b:disabled{opacity:.5}.tp-rotv_m,.tp-fldv_m{background:linear-gradient(to left, var(--cnt-fg), var(--cnt-fg) 2px, transparent 2px, transparent 4px, var(--cnt-fg) 4px);border-radius:2px;bottom:0;content:"";display:block;height:6px;right:calc(		var(--cnt-hp) + (				var(--cnt-usz) + 4px - 6px			) / 2 - 2px	);margin:auto;opacity:.5;position:absolute;top:0;transform:rotate(90deg);transition:transform .2s ease-in-out;width:6px}.tp-rotv.tp-rotv-expanded .tp-rotv_m,.tp-fldv.tp-fldv-expanded>.tp-fldv_b>.tp-fldv_m{transform:none}.tp-rotv_c,.tp-fldv_c{box-sizing:border-box;height:0;opacity:0;overflow:hidden;padding-bottom:0;padding-top:0;position:relative;transition:height .2s ease-in-out,opacity .2s linear,padding .2s ease-in-out}.tp-rotv.tp-rotv-cpl:not(.tp-rotv-expanded) .tp-rotv_c,.tp-fldv.tp-fldv-cpl:not(.tp-fldv-expanded)>.tp-fldv_c{display:none}.tp-rotv.tp-rotv-expanded .tp-rotv_c,.tp-fldv.tp-fldv-expanded>.tp-fldv_c{opacity:1;padding-bottom:var(--cnt-vp);padding-top:var(--cnt-vp);transform:none;overflow:visible;transition:height .2s ease-in-out,opacity .2s linear .2s,padding .2s ease-in-out}.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw{background-color:var(--in-bg);border-radius:var(--bld-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--cnt-usz);line-height:var(--cnt-usz);min-width:0;width:100%}.tp-txtv_i:hover,.tp-p2dpv_p:hover,.tp-colswv_sw:hover{background-color:var(--in-bg-h)}.tp-txtv_i:focus,.tp-p2dpv_p:focus,.tp-colswv_sw:focus{background-color:var(--in-bg-f)}.tp-txtv_i:active,.tp-p2dpv_p:active,.tp-colswv_sw:active{background-color:var(--in-bg-a)}.tp-txtv_i:disabled,.tp-p2dpv_p:disabled,.tp-colswv_sw:disabled{opacity:.5}.tp-lstv,.tp-coltxtv_m{position:relative}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m,.tp-coltxtv_mm{bottom:0;margin:auto;pointer-events:none;position:absolute;right:2px;top:0}.tp-lstv_m svg,.tp-coltxtv_mm svg{bottom:0;height:16px;margin:auto;position:absolute;right:0;top:0;width:16px}.tp-lstv_m svg path,.tp-coltxtv_mm svg path{fill:currentColor}.tp-sglv_i,.tp-mllv_i,.tp-grlv_g{background-color:var(--mo-bg);border-radius:var(--bld-br);box-sizing:border-box;color:var(--mo-fg);height:var(--cnt-usz);scrollbar-color:currentColor rgba(0,0,0,0);scrollbar-width:thin;width:100%}.tp-sglv_i::-webkit-scrollbar,.tp-mllv_i::-webkit-scrollbar,.tp-grlv_g::-webkit-scrollbar{height:8px;width:8px}.tp-sglv_i::-webkit-scrollbar-corner,.tp-mllv_i::-webkit-scrollbar-corner,.tp-grlv_g::-webkit-scrollbar-corner{background-color:rgba(0,0,0,0)}.tp-sglv_i::-webkit-scrollbar-thumb,.tp-mllv_i::-webkit-scrollbar-thumb,.tp-grlv_g::-webkit-scrollbar-thumb{background-clip:padding-box;background-color:currentColor;border:rgba(0,0,0,0) solid 2px;border-radius:4px}.tp-pndtxtv,.tp-coltxtv_w{display:flex}.tp-pndtxtv_a,.tp-coltxtv_c{width:100%}.tp-pndtxtv_a+.tp-pndtxtv_a,.tp-coltxtv_c+.tp-pndtxtv_a,.tp-pndtxtv_a+.tp-coltxtv_c,.tp-coltxtv_c+.tp-coltxtv_c{margin-left:2px}.tp-rotv{--bs-bg: var(--tp-base-background-color, hsl(230, 7%, 17%));--bs-br: var(--tp-base-border-radius, 6px);--bs-ff: var(--tp-base-font-family, Roboto Mono, Source Code Pro, Menlo, Courier, monospace);--bs-sh: var(--tp-base-shadow-color, rgba(0, 0, 0, 0.2));--bld-br: var(--tp-blade-border-radius, 2px);--bld-hp: var(--tp-blade-horizontal-padding, 4px);--bld-vw: var(--tp-blade-value-width, 160px);--btn-bg: var(--tp-button-background-color, hsl(230, 7%, 70%));--btn-bg-a: var(--tp-button-background-color-active, #d6d7db);--btn-bg-f: var(--tp-button-background-color-focus, #c8cad0);--btn-bg-h: var(--tp-button-background-color-hover, #bbbcc4);--btn-fg: var(--tp-button-foreground-color, hsl(230, 7%, 17%));--cnt-bg: var(--tp-container-background-color, rgba(187, 188, 196, 0.1));--cnt-bg-a: var(--tp-container-background-color-active, rgba(187, 188, 196, 0.25));--cnt-bg-f: var(--tp-container-background-color-focus, rgba(187, 188, 196, 0.2));--cnt-bg-h: var(--tp-container-background-color-hover, rgba(187, 188, 196, 0.15));--cnt-fg: var(--tp-container-foreground-color, hsl(230, 7%, 75%));--cnt-hp: var(--tp-container-horizontal-padding, 4px);--cnt-vp: var(--tp-container-vertical-padding, 4px);--cnt-usp: var(--tp-container-unit-spacing, 4px);--cnt-usz: var(--tp-container-unit-size, 20px);--in-bg: var(--tp-input-background-color, rgba(187, 188, 196, 0.1));--in-bg-a: var(--tp-input-background-color-active, rgba(187, 188, 196, 0.25));--in-bg-f: var(--tp-input-background-color-focus, rgba(187, 188, 196, 0.2));--in-bg-h: var(--tp-input-background-color-hover, rgba(187, 188, 196, 0.15));--in-fg: var(--tp-input-foreground-color, hsl(230, 7%, 75%));--lbl-fg: var(--tp-label-foreground-color, rgba(187, 188, 196, 0.7));--mo-bg: var(--tp-monitor-background-color, rgba(0, 0, 0, 0.2));--mo-fg: var(--tp-monitor-foreground-color, rgba(187, 188, 196, 0.7));--grv-fg: var(--tp-groove-foreground-color, rgba(187, 188, 196, 0.1))}.tp-btnv_b{width:100%}.tp-btnv_t{text-align:center}.tp-ckbv_l{display:block;position:relative}.tp-ckbv_i{left:0;opacity:0;position:absolute;top:0}.tp-ckbv_w{background-color:var(--in-bg);border-radius:var(--bld-br);cursor:pointer;display:block;height:var(--cnt-usz);position:relative;width:var(--cnt-usz)}.tp-ckbv_w svg{bottom:0;display:block;height:16px;left:0;margin:auto;opacity:0;position:absolute;right:0;top:0;width:16px}.tp-ckbv_w svg path{fill:none;stroke:var(--in-fg);stroke-width:2}.tp-ckbv_i:hover+.tp-ckbv_w{background-color:var(--in-bg-h)}.tp-ckbv_i:focus+.tp-ckbv_w{background-color:var(--in-bg-f)}.tp-ckbv_i:active+.tp-ckbv_w{background-color:var(--in-bg-a)}.tp-ckbv_i:checked+.tp-ckbv_w svg{opacity:1}.tp-ckbv.tp-v-disabled .tp-ckbv_w{opacity:.5}.tp-colv{position:relative}.tp-colv_h{display:flex}.tp-colv_s{flex-grow:0;flex-shrink:0;width:var(--cnt-usz)}.tp-colv_t{flex:1;margin-left:4px}.tp-colv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-colv.tp-colv-expanded.tp-colv-cpl .tp-colv_p{overflow:visible}.tp-colv.tp-colv-expanded .tp-colv_p{margin-top:var(--cnt-usp);opacity:1}.tp-colv .tp-popv{left:calc(-1 * var(--cnt-hp));right:calc(-1 * var(--cnt-hp));top:var(--cnt-usz)}.tp-colpv_h,.tp-colpv_ap{margin-left:6px;margin-right:6px}.tp-colpv_h{margin-top:var(--cnt-usp)}.tp-colpv_rgb{display:flex;margin-top:var(--cnt-usp);width:100%}.tp-colpv_a{display:flex;margin-top:var(--cnt-vp);padding-top:calc(			var(--cnt-vp) + 2px		);position:relative}.tp-colpv_a::before{background-color:var(--grv-fg);content:"";height:2px;left:calc(-1 * var(--cnt-hp));position:absolute;right:calc(-1 * var(--cnt-hp));top:0}.tp-colpv.tp-v-disabled .tp-colpv_a::before{opacity:.5}.tp-colpv_ap{align-items:center;display:flex;flex:3}.tp-colpv_at{flex:1;margin-left:4px}.tp-svpv{border-radius:var(--bld-br);outline:none;overflow:hidden;position:relative}.tp-svpv.tp-v-disabled{opacity:.5}.tp-svpv_c{cursor:crosshair;display:block;height:calc(var(--cnt-usz)*4);width:100%}.tp-svpv_m{border-radius:100%;border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;filter:drop-shadow(0 0 1px rgba(0, 0, 0, 0.3));height:12px;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;width:12px}.tp-svpv:focus .tp-svpv_m{border-color:#fff}.tp-hplv{cursor:pointer;height:var(--cnt-usz);outline:none;position:relative}.tp-hplv.tp-v-disabled{opacity:.5}.tp-hplv_c{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAABCAYAAABubagXAAAAQ0lEQVQoU2P8z8Dwn0GCgQEDi2OK/RBgYHjBgIpfovFh8j8YBIgzFGQxuqEgPhaDOT5gOhPkdCxOZeBg+IDFZZiGAgCaSSMYtcRHLgAAAABJRU5ErkJggg==);background-position:left top;background-repeat:no-repeat;background-size:100% 100%;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;position:absolute;top:50%;width:100%}.tp-hplv_m{border-radius:var(--bld-br);border:rgba(255,255,255,.75) solid 2px;box-shadow:0 0 2px rgba(0,0,0,.1);box-sizing:border-box;height:12px;left:50%;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;top:50%;width:12px}.tp-hplv:focus .tp-hplv_m{border-color:#fff}.tp-aplv{cursor:pointer;height:var(--cnt-usz);outline:none;position:relative;width:100%}.tp-aplv.tp-v-disabled{opacity:.5}.tp-aplv_b{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:4px 4px;background-position:0 0,2px 2px;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;overflow:hidden;position:absolute;top:50%;width:100%}.tp-aplv_c{bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv_m{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:12px 12px;background-position:0 0,6px 6px;border-radius:var(--bld-br);box-shadow:0 0 2px rgba(0,0,0,.1);height:12px;left:50%;margin-left:-6px;margin-top:-6px;overflow:hidden;pointer-events:none;position:absolute;top:50%;width:12px}.tp-aplv_p{border-radius:var(--bld-br);border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv:focus .tp-aplv_p{border-color:#fff}.tp-colswv{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:10px 10px;background-position:0 0,5px 5px;border-radius:var(--bld-br);overflow:hidden}.tp-colswv.tp-v-disabled{opacity:.5}.tp-colswv_sw{border-radius:0}.tp-colswv_b{cursor:pointer;display:block;height:var(--cnt-usz);left:0;position:absolute;top:0;width:var(--cnt-usz)}.tp-colswv_b:focus::after{border:rgba(255,255,255,.75) solid 2px;border-radius:var(--bld-br);bottom:0;content:"";display:block;left:0;position:absolute;right:0;top:0}.tp-coltxtv{display:flex;width:100%}.tp-coltxtv_m{margin-right:4px}.tp-coltxtv_ms{border-radius:var(--bld-br);color:var(--lbl-fg);cursor:pointer;height:var(--cnt-usz);line-height:var(--cnt-usz);padding:0 18px 0 4px}.tp-coltxtv_ms:hover{background-color:var(--in-bg-h)}.tp-coltxtv_ms:focus{background-color:var(--in-bg-f)}.tp-coltxtv_ms:active{background-color:var(--in-bg-a)}.tp-coltxtv_mm{color:var(--lbl-fg)}.tp-coltxtv.tp-v-disabled .tp-coltxtv_mm{opacity:.5}.tp-coltxtv_w{flex:1}.tp-dfwv{position:absolute;top:8px;right:8px;width:256px}.tp-fldv{position:relative}.tp-fldv_t{padding-left:4px}.tp-fldv_b:disabled .tp-fldv_m{display:none}.tp-fldv_c{padding-left:4px}.tp-fldv_i{bottom:0;color:var(--cnt-bg);left:0;overflow:hidden;position:absolute;top:calc(var(--cnt-usz) + 4px);width:max(var(--bs-br),4px)}.tp-fldv_i::before{background-color:currentColor;bottom:0;content:"";left:0;position:absolute;top:0;width:4px}.tp-fldv_b:hover+.tp-fldv_i{color:var(--cnt-bg-h)}.tp-fldv_b:focus+.tp-fldv_i{color:var(--cnt-bg-f)}.tp-fldv_b:active+.tp-fldv_i{color:var(--cnt-bg-a)}.tp-fldv.tp-v-disabled>.tp-fldv_i{opacity:.5}.tp-grlv{position:relative}.tp-grlv_g{display:block;height:calc(var(--cnt-usz) * 3)}.tp-grlv_g polyline{fill:none;stroke:var(--mo-fg);stroke-linejoin:round}.tp-grlv_t{margin-top:-4px;transition:left .05s,top .05s;visibility:hidden}.tp-grlv_t.tp-grlv_t-a{visibility:visible}.tp-grlv_t.tp-grlv_t-in{transition:none}.tp-grlv.tp-v-disabled .tp-grlv_g{opacity:.5}.tp-grlv .tp-ttv{background-color:var(--mo-fg)}.tp-grlv .tp-ttv::before{border-top-color:var(--mo-fg)}.tp-lblv{align-items:center;display:flex;line-height:1.3;padding-left:var(--cnt-hp);padding-right:var(--cnt-hp)}.tp-lblv.tp-lblv-nol{display:block}.tp-lblv_l{color:var(--lbl-fg);flex:1;-webkit-hyphens:auto;hyphens:auto;overflow:hidden;padding-left:4px;padding-right:16px}.tp-lblv.tp-v-disabled .tp-lblv_l{opacity:.5}.tp-lblv.tp-lblv-nol .tp-lblv_l{display:none}.tp-lblv_v{align-self:flex-start;flex-grow:0;flex-shrink:0;width:var(--bld-vw)}.tp-lblv.tp-lblv-nol .tp-lblv_v{width:100%}.tp-lstv_s{padding:0 20px 0 var(--bld-hp);width:100%}.tp-lstv_m{color:var(--btn-fg)}.tp-sglv_i{padding-left:var(--bld-hp);padding-right:var(--bld-hp)}.tp-sglv.tp-v-disabled .tp-sglv_i{opacity:.5}.tp-mllv_i{display:block;height:calc(var(--cnt-usz) * 3);line-height:var(--cnt-usz);padding-left:var(--bld-hp);padding-right:var(--bld-hp);resize:none;white-space:pre}.tp-mllv.tp-v-disabled .tp-mllv_i{opacity:.5}.tp-p2dv{position:relative}.tp-p2dv_h{display:flex}.tp-p2dv_b{height:var(--cnt-usz);margin-right:4px;position:relative;width:var(--cnt-usz)}.tp-p2dv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-p2dv_b svg path{stroke:currentColor;stroke-width:2}.tp-p2dv_b svg circle{fill:currentColor}.tp-p2dv_t{flex:1}.tp-p2dv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-p2dv.tp-p2dv-expanded .tp-p2dv_p{margin-top:var(--cnt-usp);opacity:1}.tp-p2dv .tp-popv{left:calc(-1 * var(--cnt-hp));right:calc(-1 * var(--cnt-hp));top:var(--cnt-usz)}.tp-p2dpv{padding-left:calc(var(--cnt-usz) + 4px)}.tp-p2dpv_p{cursor:crosshair;height:0;overflow:hidden;padding-bottom:100%;position:relative}.tp-p2dpv.tp-v-disabled .tp-p2dpv_p{opacity:.5}.tp-p2dpv_g{display:block;height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.tp-p2dpv_ax{opacity:.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_l{opacity:.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_m{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;position:absolute;width:4px}.tp-p2dpv_p:focus .tp-p2dpv_m{background-color:var(--in-fg);border-width:0}.tp-popv{background-color:var(--bs-bg);border-radius:var(--bs-br);box-shadow:0 2px 4px var(--bs-sh);display:none;max-width:var(--bld-vw);padding:var(--cnt-vp) var(--cnt-hp);position:absolute;visibility:hidden;z-index:1000}.tp-popv.tp-popv-v{display:block;visibility:visible}.tp-sldv.tp-v-disabled{opacity:.5}.tp-sldv_t{box-sizing:border-box;cursor:pointer;height:var(--cnt-usz);margin:0 6px;outline:none;position:relative}.tp-sldv_t::before{background-color:var(--in-bg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin:auto;position:absolute;right:0;top:0}.tp-sldv_k{height:100%;left:0;position:absolute;top:0}.tp-sldv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin-bottom:auto;margin-top:auto;position:absolute;right:0;top:0}.tp-sldv_k::after{background-color:var(--btn-bg);border-radius:var(--bld-br);bottom:0;content:"";display:block;height:12px;margin-bottom:auto;margin-top:auto;position:absolute;right:-6px;top:0;width:12px}.tp-sldv_t:hover .tp-sldv_k::after{background-color:var(--btn-bg-h)}.tp-sldv_t:focus .tp-sldv_k::after{background-color:var(--btn-bg-f)}.tp-sldv_t:active .tp-sldv_k::after{background-color:var(--btn-bg-a)}.tp-sldtxtv{display:flex}.tp-sldtxtv_s{flex:2}.tp-sldtxtv_t{flex:1;margin-left:4px}.tp-tabv{position:relative}.tp-tabv_t{align-items:flex-end;color:var(--cnt-bg);display:flex;overflow:hidden;position:relative}.tp-tabv_t:hover{color:var(--cnt-bg-h)}.tp-tabv_t:has(*:focus){color:var(--cnt-bg-f)}.tp-tabv_t:has(*:active){color:var(--cnt-bg-a)}.tp-tabv_t::before{background-color:currentColor;bottom:0;content:"";height:2px;left:0;pointer-events:none;position:absolute;right:0}.tp-tabv.tp-v-disabled .tp-tabv_t::before{opacity:.5}.tp-tabv.tp-tabv-nop .tp-tabv_t{height:calc(var(--cnt-usz) + 4px);position:relative}.tp-tabv.tp-tabv-nop .tp-tabv_t::before{background-color:var(--cnt-bg);bottom:0;content:"";height:2px;left:0;position:absolute;right:0}.tp-tabv_i{bottom:0;color:var(--cnt-bg);left:0;overflow:hidden;position:absolute;top:calc(var(--cnt-usz) + 4px);width:max(var(--bs-br),4px)}.tp-tabv_i::before{background-color:currentColor;bottom:0;content:"";left:0;position:absolute;top:0;width:4px}.tp-tabv_t:hover+.tp-tabv_i{color:var(--cnt-bg-h)}.tp-tabv_t:has(*:focus)+.tp-tabv_i{color:var(--cnt-bg-f)}.tp-tabv_t:has(*:active)+.tp-tabv_i{color:var(--cnt-bg-a)}.tp-tabv.tp-v-disabled>.tp-tabv_i{opacity:.5}.tp-tbiv{flex:1;min-width:0;position:relative}.tp-tbiv+.tp-tbiv{margin-left:2px}.tp-tbiv+.tp-tbiv.tp-v-disabled::before{opacity:.5}.tp-tbiv_b{display:block;padding-left:calc(var(--cnt-hp) + 4px);padding-right:calc(var(--cnt-hp) + 4px);position:relative;width:100%}.tp-tbiv_b:disabled{opacity:.5}.tp-tbiv_b::before{background-color:var(--cnt-bg);bottom:2px;content:"";left:0;pointer-events:none;position:absolute;right:0;top:0}.tp-tbiv_b:hover::before{background-color:var(--cnt-bg-h)}.tp-tbiv_b:focus::before{background-color:var(--cnt-bg-f)}.tp-tbiv_b:active::before{background-color:var(--cnt-bg-a)}.tp-tbiv_t{color:var(--cnt-fg);height:calc(var(--cnt-usz) + 4px);line-height:calc(var(--cnt-usz) + 4px);opacity:.5;overflow:hidden;text-overflow:ellipsis}.tp-tbiv.tp-tbiv-sel .tp-tbiv_t{opacity:1}.tp-tbpv_c{padding-bottom:var(--cnt-vp);padding-left:4px;padding-top:var(--cnt-vp)}.tp-txtv{position:relative}.tp-txtv_i{padding-left:var(--bld-hp);padding-right:var(--bld-hp)}.tp-txtv.tp-txtv-fst .tp-txtv_i{border-bottom-right-radius:0;border-top-right-radius:0}.tp-txtv.tp-txtv-mid .tp-txtv_i{border-radius:0}.tp-txtv.tp-txtv-lst .tp-txtv_i{border-bottom-left-radius:0;border-top-left-radius:0}.tp-txtv.tp-txtv-num .tp-txtv_i{text-align:right}.tp-txtv.tp-txtv-drg .tp-txtv_i{opacity:.3}.tp-txtv_k{cursor:pointer;height:100%;left:calc(			var(--bld-hp) - 5px		);position:absolute;top:0;width:12px}.tp-txtv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";height:calc(var(--cnt-usz) - 4px);left:50%;margin-bottom:auto;margin-left:-1px;margin-top:auto;opacity:.1;position:absolute;top:0;transition:border-radius .1s,height .1s,transform .1s,width .1s;width:2px}.tp-txtv_k:hover::before,.tp-txtv.tp-txtv-drg .tp-txtv_k::before{opacity:1}.tp-txtv.tp-txtv-drg .tp-txtv_k::before{border-radius:50%;height:4px;transform:translateX(-1px);width:4px}.tp-txtv_g{bottom:0;display:block;height:8px;left:50%;margin:auto;overflow:visible;pointer-events:none;position:absolute;top:0;visibility:hidden;width:100%}.tp-txtv.tp-txtv-drg .tp-txtv_g{visibility:visible}.tp-txtv_gb{fill:none;stroke:var(--in-fg);stroke-dasharray:1}.tp-txtv_gh{fill:none;stroke:var(--in-fg)}.tp-txtv .tp-ttv{margin-left:6px;visibility:hidden}.tp-txtv.tp-txtv-drg .tp-ttv{visibility:visible}.tp-ttv{background-color:var(--in-fg);border-radius:var(--bld-br);color:var(--bs-bg);padding:2px 4px;pointer-events:none;position:absolute;transform:translate(-50%, -100%)}.tp-ttv::before{border-color:var(--in-fg) rgba(0,0,0,0) rgba(0,0,0,0) rgba(0,0,0,0);border-style:solid;border-width:2px;box-sizing:border-box;content:"";font-size:.9em;height:4px;left:50%;margin-left:-2px;position:absolute;top:100%;width:4px}.tp-rotv{background-color:var(--bs-bg);border-radius:var(--bs-br);box-shadow:0 2px 4px var(--bs-sh);font-family:var(--bs-ff);font-size:11px;font-weight:500;line-height:1;text-align:left}.tp-rotv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br);border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br);padding-left:calc(			2px * 2 + var(--cnt-usz) + var(--cnt-hp)		);text-align:center}.tp-rotv.tp-rotv-expanded .tp-rotv_b{border-bottom-left-radius:0;border-bottom-right-radius:0;transition-delay:0s;transition-duration:0s}.tp-rotv.tp-rotv-not>.tp-rotv_b{display:none}.tp-rotv_b:disabled .tp-rotv_m{display:none}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_i{border-bottom-left-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst.tp-fldv-expanded>.tp-fldv_b{transition-delay:0s;transition-duration:0s}.tp-rotv_c .tp-fldv.tp-v-vlst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst{margin-top:calc(-1 * var(--cnt-vp))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst>.tp-fldv_b{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_i{border-bottom-left-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst{margin-top:calc(-1 * var(--cnt-vp))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst>.tp-tabv_t{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-v-disabled,.tp-rotv .tp-v-disabled{pointer-events:none}.tp-rotv.tp-v-hidden,.tp-rotv .tp-v-hidden{display:none}.tp-sprv_r{background-color:var(--grv-fg);border-width:0;display:block;height:2px;margin:0;width:100%}.tp-sprv.tp-v-disabled .tp-sprv_r{opacity:.5}',
      plugins: [
        ListBladePlugin,
        SeparatorBladePlugin,
        SliderBladePlugin,
        TabBladePlugin,
        TextBladePlugin
      ]
    });
  }
};
var VERSION = new Semver("4.0.1");

// node_modules/@tresjs/cientos/dist/trescientos.js
var qi = Object.defineProperty;
var Ji = (l, e, t) => e in l ? qi(l, e, { enumerable: true, configurable: true, writable: true, value: t }) : l[e] = t;
var Ie = (l, e, t) => (Ji(l, typeof e != "symbol" ? e + "" : e, t), t);
function zn(l, e) {
  if (e === TrianglesDrawMode)
    return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), l;
  if (e === TriangleFanDrawMode || e === TriangleStripDrawMode) {
    let t = l.getIndex();
    if (t === null) {
      const o = [], r = l.getAttribute("position");
      if (r !== void 0) {
        for (let a = 0; a < r.count; a++)
          o.push(a);
        l.setIndex(o), t = l.getIndex();
      } else
        return console.error(
          "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
        ), l;
    }
    const s = t.count - 2, n = [];
    if (t)
      if (e === TriangleFanDrawMode)
        for (let o = 1; o <= s; o++)
          n.push(t.getX(0)), n.push(t.getX(o)), n.push(t.getX(o + 1));
      else
        for (let o = 0; o < s; o++)
          o % 2 === 0 ? (n.push(t.getX(o)), n.push(t.getX(o + 1)), n.push(t.getX(o + 2))) : (n.push(t.getX(o + 2)), n.push(t.getX(o + 1)), n.push(t.getX(o)));
    n.length / 3 !== s && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    const i = l.clone();
    return i.setIndex(n), i.clearGroups(), i;
  } else
    return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e), l;
}
var Je = Uint8Array;
var St = Uint16Array;
var xn = Uint32Array;
var Li = new Je([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]);
var Ri = new Je([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]);
var Xo = new Je([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var Ci = function(l, e) {
  for (var t = new St(31), s = 0; s < 31; ++s)
    t[s] = e += 1 << l[s - 1];
  for (var n = new xn(t[30]), s = 1; s < 30; ++s)
    for (var i = t[s]; i < t[s + 1]; ++i)
      n[i] = i - t[s] << 5 | s;
  return [t, n];
};
var Ii = Ci(Li, 2);
var Di = Ii[0];
var Zo = Ii[1];
Di[28] = 258, Zo[258] = 28;
var $o = Ci(Ri, 0);
var Ko = $o[0];
var wn = new St(32768);
for (Re = 0; Re < 32768; ++Re) {
  Tt = (Re & 43690) >>> 1 | (Re & 21845) << 1;
  Tt = (Tt & 52428) >>> 2 | (Tt & 13107) << 2, Tt = (Tt & 61680) >>> 4 | (Tt & 3855) << 4, wn[Re] = ((Tt & 65280) >>> 8 | (Tt & 255) << 8) >>> 1;
}
var Tt;
var Re;
var us = function(l, e, t) {
  for (var s = l.length, n = 0, i = new St(e); n < s; ++n)
    ++i[l[n] - 1];
  var o = new St(e);
  for (n = 0; n < e; ++n)
    o[n] = o[n - 1] + i[n - 1] << 1;
  var r;
  if (t) {
    r = new St(1 << e);
    var a = 15 - e;
    for (n = 0; n < s; ++n)
      if (l[n])
        for (var c = n << 4 | l[n], u = e - l[n], h = o[l[n] - 1]++ << u, d = h | (1 << u) - 1; h <= d; ++h)
          r[wn[h] >>> a] = c;
  } else
    for (r = new St(s), n = 0; n < s; ++n)
      l[n] && (r[n] = wn[o[l[n] - 1]++] >>> 15 - l[n]);
  return r;
};
var vs = new Je(288);
for (Re = 0; Re < 144; ++Re)
  vs[Re] = 8;
var Re;
for (Re = 144; Re < 256; ++Re)
  vs[Re] = 9;
var Re;
for (Re = 256; Re < 280; ++Re)
  vs[Re] = 7;
var Re;
for (Re = 280; Re < 288; ++Re)
  vs[Re] = 8;
var Re;
var ki = new Je(32);
for (Re = 0; Re < 32; ++Re)
  ki[Re] = 5;
var Re;
var Wo = us(vs, 9, 1);
var Qo = us(ki, 5, 1);
var Ks = function(l) {
  for (var e = l[0], t = 1; t < l.length; ++t)
    l[t] > e && (e = l[t]);
  return e;
};
var st = function(l, e, t) {
  var s = e / 8 | 0;
  return (l[s] | l[s + 1] << 8) >> (e & 7) & t;
};
var Ws = function(l, e) {
  var t = e / 8 | 0;
  return (l[t] | l[t + 1] << 8 | l[t + 2] << 16) >> (e & 7);
};
var qo = function(l) {
  return (l / 8 | 0) + (l & 7 && 1);
};
var Jo = function(l, e, t) {
  (e == null || e < 0) && (e = 0), (t == null || t > l.length) && (t = l.length);
  var s = new (l instanceof St ? St : l instanceof xn ? xn : Je)(t - e);
  return s.set(l.subarray(e, t)), s;
};
var er = function(l, e, t) {
  var s = l.length;
  if (!s || t && !t.l && s < 5)
    return e || new Je(0);
  var n = !e || t, i = !t || t.i;
  t || (t = {}), e || (e = new Je(s * 3));
  var o = function(H) {
    var S = e.length;
    if (H > S) {
      var V = new Je(Math.max(S * 2, H));
      V.set(e), e = V;
    }
  }, r = t.f || 0, a = t.p || 0, c = t.b || 0, u = t.l, h = t.d, d = t.m, f = t.n, E = s * 8;
  do {
    if (!u) {
      t.f = r = st(l, a, 1);
      var v = st(l, a + 1, 3);
      if (a += 3, v)
        if (v == 1)
          u = Wo, h = Qo, d = 9, f = 5;
        else if (v == 2) {
          var y = st(l, a, 31) + 257, m = st(l, a + 10, 15) + 4, A = y + st(l, a + 5, 31) + 1;
          a += 14;
          for (var b = new Je(A), _ = new Je(19), T = 0; T < m; ++T)
            _[Xo[T]] = st(l, a + T * 3, 7);
          a += m * 3;
          for (var L2 = Ks(_), B = (1 << L2) - 1, k = us(_, L2, 1), T = 0; T < A; ) {
            var N = k[st(l, a, B)];
            a += N & 15;
            var g = N >>> 4;
            if (g < 16)
              b[T++] = g;
            else {
              var $ = 0, Q = 0;
              for (g == 16 ? (Q = 3 + st(l, a, 3), a += 2, $ = b[T - 1]) : g == 17 ? (Q = 3 + st(l, a, 7), a += 3) : g == 18 && (Q = 11 + st(l, a, 127), a += 7); Q--; )
                b[T++] = $;
            }
          }
          var Z = b.subarray(0, y), me = b.subarray(y);
          d = Ks(Z), f = Ks(me), u = us(Z, d, 1), h = us(me, f, 1);
        } else
          throw "invalid block type";
      else {
        var g = qo(a) + 4, x = l[g - 4] | l[g - 3] << 8, M = g + x;
        if (M > s) {
          if (i)
            throw "unexpected EOF";
          break;
        }
        n && o(c + x), e.set(l.subarray(g, M), c), t.b = c += x, t.p = a = M * 8;
        continue;
      }
      if (a > E) {
        if (i)
          throw "unexpected EOF";
        break;
      }
    }
    n && o(c + 131072);
    for (var X = (1 << d) - 1, z = (1 << f) - 1, ce = a; ; ce = a) {
      var $ = u[Ws(l, a) & X], se = $ >>> 4;
      if (a += $ & 15, a > E) {
        if (i)
          throw "unexpected EOF";
        break;
      }
      if (!$)
        throw "invalid length/literal";
      if (se < 256)
        e[c++] = se;
      else if (se == 256) {
        ce = a, u = null;
        break;
      } else {
        var ae2 = se - 254;
        if (se > 264) {
          var T = se - 257, I = Li[T];
          ae2 = st(l, a, (1 << I) - 1) + Di[T], a += I;
        }
        var O = h[Ws(l, a) & z], p = O >>> 4;
        if (!O)
          throw "invalid distance";
        a += O & 15;
        var me = Ko[p];
        if (p > 3) {
          var I = Ri[p];
          me += Ws(l, a) & (1 << I) - 1, a += I;
        }
        if (a > E) {
          if (i)
            throw "unexpected EOF";
          break;
        }
        n && o(c + 131072);
        for (var R = c + ae2; c < R; c += 4)
          e[c] = e[c - me], e[c + 1] = e[c + 1 - me], e[c + 2] = e[c + 2 - me], e[c + 3] = e[c + 3 - me];
        c = R;
      }
    }
    t.l = u, t.p = ce, t.b = c, u && (r = 1, t.m = d, t.d = h, t.n = f);
  } while (!r);
  return c == e.length ? e : Jo(e, 0, c);
};
var tr = new Je(0);
var sr = function(l) {
  if ((l[0] & 15) != 8 || l[0] >>> 4 > 7 || (l[0] << 8 | l[1]) % 31)
    throw "invalid zlib data";
  if (l[1] & 32)
    throw "invalid zlib data: preset dictionaries not supported";
};
function nr(l, e) {
  return er((sr(l), l.subarray(2, -4)), e);
}
var ir = typeof TextDecoder < "u" && new TextDecoder();
var or = 0;
try {
  ir.decode(tr, { stream: true }), or = 1;
} catch {
}
var rr = Object.defineProperty;
var ar = (l, e, t) => e in l ? rr(l, e, { enumerable: true, configurable: true, writable: true, value: t }) : l[e] = t;
var F = (l, e, t) => (ar(l, typeof e != "symbol" ? e + "" : e, t), t);
var lr = class extends Object3D {
  constructor(e, t) {
    super(), F(this, "isTransformControls", true), F(this, "visible", false), F(this, "domElement"), F(this, "raycaster", new Raycaster()), F(this, "gizmo"), F(this, "plane"), F(this, "tempVector", new Vector3()), F(this, "tempVector2", new Vector3()), F(this, "tempQuaternion", new Quaternion()), F(this, "unit", {
      X: new Vector3(1, 0, 0),
      Y: new Vector3(0, 1, 0),
      Z: new Vector3(0, 0, 1)
    }), F(this, "pointStart", new Vector3()), F(this, "pointEnd", new Vector3()), F(this, "offset", new Vector3()), F(this, "rotationAxis", new Vector3()), F(this, "startNorm", new Vector3()), F(this, "endNorm", new Vector3()), F(this, "rotationAngle", 0), F(this, "cameraPosition", new Vector3()), F(this, "cameraQuaternion", new Quaternion()), F(this, "cameraScale", new Vector3()), F(this, "parentPosition", new Vector3()), F(this, "parentQuaternion", new Quaternion()), F(this, "parentQuaternionInv", new Quaternion()), F(this, "parentScale", new Vector3()), F(this, "worldPositionStart", new Vector3()), F(this, "worldQuaternionStart", new Quaternion()), F(this, "worldScaleStart", new Vector3()), F(this, "worldPosition", new Vector3()), F(this, "worldQuaternion", new Quaternion()), F(this, "worldQuaternionInv", new Quaternion()), F(this, "worldScale", new Vector3()), F(this, "eye", new Vector3()), F(this, "positionStart", new Vector3()), F(this, "quaternionStart", new Quaternion()), F(this, "scaleStart", new Vector3()), F(this, "camera"), F(this, "object"), F(this, "enabled", true), F(this, "axis", null), F(this, "mode", "translate"), F(this, "translationSnap", null), F(this, "rotationSnap", null), F(this, "scaleSnap", null), F(this, "space", "world"), F(this, "size", 1), F(this, "dragging", false), F(this, "showX", true), F(this, "showY", true), F(this, "showZ", true), F(this, "changeEvent", { type: "change" }), F(this, "mouseDownEvent", { type: "mouseDown", mode: this.mode }), F(this, "mouseUpEvent", { type: "mouseUp", mode: this.mode }), F(this, "objectChangeEvent", { type: "objectChange" }), F(this, "intersectObjectWithRay", (n, i, o) => {
      const r = i.intersectObject(n, true);
      for (let a = 0; a < r.length; a++)
        if (r[a].object.visible || o)
          return r[a];
      return false;
    }), F(this, "attach", (n) => (this.object = n, this.visible = true, this)), F(this, "detach", () => (this.object = void 0, this.visible = false, this.axis = null, this)), F(this, "reset", () => this.enabled ? (this.dragging && this.object !== void 0 && (this.object.position.copy(this.positionStart), this.object.quaternion.copy(this.quaternionStart), this.object.scale.copy(this.scaleStart), this.dispatchEvent(this.changeEvent), this.dispatchEvent(this.objectChangeEvent), this.pointStart.copy(this.pointEnd)), this) : this), F(this, "updateMatrixWorld", () => {
      this.object !== void 0 && (this.object.updateMatrixWorld(), this.object.parent === null ? console.error("TransformControls: The attached 3D object must be a part of the scene graph.") : this.object.parent.matrixWorld.decompose(this.parentPosition, this.parentQuaternion, this.parentScale), this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this.worldScale), this.parentQuaternionInv.copy(this.parentQuaternion).invert(), this.worldQuaternionInv.copy(this.worldQuaternion).invert()), this.camera.updateMatrixWorld(), this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this.cameraScale), this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(), super.updateMatrixWorld();
    }), F(this, "pointerHover", (n) => {
      if (this.object === void 0 || this.dragging === true)
        return;
      this.raycaster.setFromCamera(n, this.camera);
      const i = this.intersectObjectWithRay(this.gizmo.picker[this.mode], this.raycaster);
      i ? this.axis = i.object.name : this.axis = null;
    }), F(this, "pointerDown", (n) => {
      if (!(this.object === void 0 || this.dragging === true || n.button !== 0) && this.axis !== null) {
        this.raycaster.setFromCamera(n, this.camera);
        const i = this.intersectObjectWithRay(this.plane, this.raycaster, true);
        if (i) {
          let o = this.space;
          if (this.mode === "scale" ? o = "local" : (this.axis === "E" || this.axis === "XYZE" || this.axis === "XYZ") && (o = "world"), o === "local" && this.mode === "rotate") {
            const r = this.rotationSnap;
            this.axis === "X" && r && (this.object.rotation.x = Math.round(this.object.rotation.x / r) * r), this.axis === "Y" && r && (this.object.rotation.y = Math.round(this.object.rotation.y / r) * r), this.axis === "Z" && r && (this.object.rotation.z = Math.round(this.object.rotation.z / r) * r);
          }
          this.object.updateMatrixWorld(), this.object.parent && this.object.parent.updateMatrixWorld(), this.positionStart.copy(this.object.position), this.quaternionStart.copy(this.object.quaternion), this.scaleStart.copy(this.object.scale), this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this.worldScaleStart), this.pointStart.copy(i.point).sub(this.worldPositionStart);
        }
        this.dragging = true, this.mouseDownEvent.mode = this.mode, this.dispatchEvent(this.mouseDownEvent);
      }
    }), F(this, "pointerMove", (n) => {
      const i = this.axis, o = this.mode, r = this.object;
      let a = this.space;
      if (o === "scale" ? a = "local" : (i === "E" || i === "XYZE" || i === "XYZ") && (a = "world"), r === void 0 || i === null || this.dragging === false || n.button !== -1)
        return;
      this.raycaster.setFromCamera(n, this.camera);
      const c = this.intersectObjectWithRay(this.plane, this.raycaster, true);
      if (c) {
        if (this.pointEnd.copy(c.point).sub(this.worldPositionStart), o === "translate")
          this.offset.copy(this.pointEnd).sub(this.pointStart), a === "local" && i !== "XYZ" && this.offset.applyQuaternion(this.worldQuaternionInv), i.indexOf("X") === -1 && (this.offset.x = 0), i.indexOf("Y") === -1 && (this.offset.y = 0), i.indexOf("Z") === -1 && (this.offset.z = 0), a === "local" && i !== "XYZ" ? this.offset.applyQuaternion(this.quaternionStart).divide(this.parentScale) : this.offset.applyQuaternion(this.parentQuaternionInv).divide(this.parentScale), r.position.copy(this.offset).add(this.positionStart), this.translationSnap && (a === "local" && (r.position.applyQuaternion(this.tempQuaternion.copy(this.quaternionStart).invert()), i.search("X") !== -1 && (r.position.x = Math.round(r.position.x / this.translationSnap) * this.translationSnap), i.search("Y") !== -1 && (r.position.y = Math.round(r.position.y / this.translationSnap) * this.translationSnap), i.search("Z") !== -1 && (r.position.z = Math.round(r.position.z / this.translationSnap) * this.translationSnap), r.position.applyQuaternion(this.quaternionStart)), a === "world" && (r.parent && r.position.add(this.tempVector.setFromMatrixPosition(r.parent.matrixWorld)), i.search("X") !== -1 && (r.position.x = Math.round(r.position.x / this.translationSnap) * this.translationSnap), i.search("Y") !== -1 && (r.position.y = Math.round(r.position.y / this.translationSnap) * this.translationSnap), i.search("Z") !== -1 && (r.position.z = Math.round(r.position.z / this.translationSnap) * this.translationSnap), r.parent && r.position.sub(this.tempVector.setFromMatrixPosition(r.parent.matrixWorld))));
        else if (o === "scale") {
          if (i.search("XYZ") !== -1) {
            let u = this.pointEnd.length() / this.pointStart.length();
            this.pointEnd.dot(this.pointStart) < 0 && (u *= -1), this.tempVector2.set(u, u, u);
          } else
            this.tempVector.copy(this.pointStart), this.tempVector2.copy(this.pointEnd), this.tempVector.applyQuaternion(this.worldQuaternionInv), this.tempVector2.applyQuaternion(this.worldQuaternionInv), this.tempVector2.divide(this.tempVector), i.search("X") === -1 && (this.tempVector2.x = 1), i.search("Y") === -1 && (this.tempVector2.y = 1), i.search("Z") === -1 && (this.tempVector2.z = 1);
          r.scale.copy(this.scaleStart).multiply(this.tempVector2), this.scaleSnap && this.object && (i.search("X") !== -1 && (this.object.scale.x = Math.round(r.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap), i.search("Y") !== -1 && (r.scale.y = Math.round(r.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap), i.search("Z") !== -1 && (r.scale.z = Math.round(r.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap));
        } else if (o === "rotate") {
          this.offset.copy(this.pointEnd).sub(this.pointStart);
          const u = 20 / this.worldPosition.distanceTo(this.tempVector.setFromMatrixPosition(this.camera.matrixWorld));
          i === "E" ? (this.rotationAxis.copy(this.eye), this.rotationAngle = this.pointEnd.angleTo(this.pointStart), this.startNorm.copy(this.pointStart).normalize(), this.endNorm.copy(this.pointEnd).normalize(), this.rotationAngle *= this.endNorm.cross(this.startNorm).dot(this.eye) < 0 ? 1 : -1) : i === "XYZE" ? (this.rotationAxis.copy(this.offset).cross(this.eye).normalize(), this.rotationAngle = this.offset.dot(this.tempVector.copy(this.rotationAxis).cross(this.eye)) * u) : (i === "X" || i === "Y" || i === "Z") && (this.rotationAxis.copy(this.unit[i]), this.tempVector.copy(this.unit[i]), a === "local" && this.tempVector.applyQuaternion(this.worldQuaternion), this.rotationAngle = this.offset.dot(this.tempVector.cross(this.eye).normalize()) * u), this.rotationSnap && (this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap), a === "local" && i !== "E" && i !== "XYZE" ? (r.quaternion.copy(this.quaternionStart), r.quaternion.multiply(this.tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize()) : (this.rotationAxis.applyQuaternion(this.parentQuaternionInv), r.quaternion.copy(this.tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle)), r.quaternion.multiply(this.quaternionStart).normalize());
        }
        this.dispatchEvent(this.changeEvent), this.dispatchEvent(this.objectChangeEvent);
      }
    }), F(this, "pointerUp", (n) => {
      n.button === 0 && (this.dragging && this.axis !== null && (this.mouseUpEvent.mode = this.mode, this.dispatchEvent(this.mouseUpEvent)), this.dragging = false, this.axis = null);
    }), F(this, "getPointer", (n) => {
      var i, o;
      if (this.domElement && ((i = this.domElement.ownerDocument) != null && i.pointerLockElement))
        return {
          x: 0,
          y: 0,
          button: n.button
        };
      {
        const r = n.changedTouches ? n.changedTouches[0] : n, a = (o = this.domElement) == null ? void 0 : o.getBoundingClientRect();
        return {
          x: (r.clientX - a.left) / a.width * 2 - 1,
          y: -(r.clientY - a.top) / a.height * 2 + 1,
          button: n.button
        };
      }
    }), F(this, "onPointerHover", (n) => {
      if (this.enabled)
        switch (n.pointerType) {
          case "mouse":
          case "pen":
            this.pointerHover(this.getPointer(n));
            break;
        }
    }), F(this, "onPointerDown", (n) => {
      !this.enabled || !this.domElement || (this.domElement.style.touchAction = "none", this.domElement.ownerDocument.addEventListener("pointermove", this.onPointerMove), this.pointerHover(this.getPointer(n)), this.pointerDown(this.getPointer(n)));
    }), F(this, "onPointerMove", (n) => {
      this.enabled && this.pointerMove(this.getPointer(n));
    }), F(this, "onPointerUp", (n) => {
      !this.enabled || !this.domElement || (this.domElement.style.touchAction = "", this.domElement.ownerDocument.removeEventListener("pointermove", this.onPointerMove), this.pointerUp(this.getPointer(n)));
    }), F(this, "getMode", () => this.mode), F(this, "setMode", (n) => {
      this.mode = n;
    }), F(this, "setTranslationSnap", (n) => {
      this.translationSnap = n;
    }), F(this, "setRotationSnap", (n) => {
      this.rotationSnap = n;
    }), F(this, "setScaleSnap", (n) => {
      this.scaleSnap = n;
    }), F(this, "setSize", (n) => {
      this.size = n;
    }), F(this, "setSpace", (n) => {
      this.space = n;
    }), F(this, "update", () => {
      console.warn(
        "THREE.TransformControls: update function has no more functionality and therefore has been deprecated."
      );
    }), F(this, "connect", (n) => {
      n === document && console.error(
        'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'
      ), this.domElement = n, this.domElement.addEventListener("pointerdown", this.onPointerDown), this.domElement.addEventListener("pointermove", this.onPointerHover), this.domElement.ownerDocument.addEventListener("pointerup", this.onPointerUp);
    }), F(this, "dispose", () => {
      var n, i, o, r, a, c;
      (n = this.domElement) == null || n.removeEventListener("pointerdown", this.onPointerDown), (i = this.domElement) == null || i.removeEventListener("pointermove", this.onPointerHover), (r = (o = this.domElement) == null ? void 0 : o.ownerDocument) == null || r.removeEventListener("pointermove", this.onPointerMove), (c = (a = this.domElement) == null ? void 0 : a.ownerDocument) == null || c.removeEventListener("pointerup", this.onPointerUp), this.traverse((u) => {
        const h = u;
        h.geometry && h.geometry.dispose(), h.material && h.material.dispose();
      });
    }), this.domElement = t, this.camera = e, this.gizmo = new cr(), this.add(this.gizmo), this.plane = new hr(), this.add(this.plane);
    const s = (n, i) => {
      let o = i;
      Object.defineProperty(this, n, {
        get: function() {
          return o !== void 0 ? o : i;
        },
        set: function(r) {
          o !== r && (o = r, this.plane[n] = r, this.gizmo[n] = r, this.dispatchEvent({ type: n + "-changed", value: r }), this.dispatchEvent(this.changeEvent));
        }
      }), this[n] = i, this.plane[n] = i, this.gizmo[n] = i;
    };
    s("camera", this.camera), s("object", this.object), s("enabled", this.enabled), s("axis", this.axis), s("mode", this.mode), s("translationSnap", this.translationSnap), s("rotationSnap", this.rotationSnap), s("scaleSnap", this.scaleSnap), s("space", this.space), s("size", this.size), s("dragging", this.dragging), s("showX", this.showX), s("showY", this.showY), s("showZ", this.showZ), s("worldPosition", this.worldPosition), s("worldPositionStart", this.worldPositionStart), s("worldQuaternion", this.worldQuaternion), s("worldQuaternionStart", this.worldQuaternionStart), s("cameraPosition", this.cameraPosition), s("cameraQuaternion", this.cameraQuaternion), s("pointStart", this.pointStart), s("pointEnd", this.pointEnd), s("rotationAxis", this.rotationAxis), s("rotationAngle", this.rotationAngle), s("eye", this.eye), t !== void 0 && this.connect(t);
  }
};
var cr = class extends Object3D {
  constructor() {
    super(), F(this, "isTransformControlsGizmo", true), F(this, "type", "TransformControlsGizmo"), F(this, "tempVector", new Vector3(0, 0, 0)), F(this, "tempEuler", new Euler()), F(this, "alignVector", new Vector3(0, 1, 0)), F(this, "zeroVector", new Vector3(0, 0, 0)), F(this, "lookAtMatrix", new Matrix4()), F(this, "tempQuaternion", new Quaternion()), F(this, "tempQuaternion2", new Quaternion()), F(this, "identityQuaternion", new Quaternion()), F(this, "unitX", new Vector3(1, 0, 0)), F(this, "unitY", new Vector3(0, 1, 0)), F(this, "unitZ", new Vector3(0, 0, 1)), F(this, "gizmo"), F(this, "picker"), F(this, "helper"), F(this, "rotationAxis", new Vector3()), F(this, "cameraPosition", new Vector3()), F(this, "worldPositionStart", new Vector3()), F(this, "worldQuaternionStart", new Quaternion()), F(this, "worldPosition", new Vector3()), F(this, "worldQuaternion", new Quaternion()), F(this, "eye", new Vector3()), F(this, "camera", null), F(this, "enabled", true), F(this, "axis", null), F(this, "mode", "translate"), F(this, "space", "world"), F(this, "size", 1), F(this, "dragging", false), F(this, "showX", true), F(this, "showY", true), F(this, "showZ", true), F(this, "updateMatrixWorld", () => {
      let se = this.space;
      this.mode === "scale" && (se = "local");
      const ae2 = se === "local" ? this.worldQuaternion : this.identityQuaternion;
      this.gizmo.translate.visible = this.mode === "translate", this.gizmo.rotate.visible = this.mode === "rotate", this.gizmo.scale.visible = this.mode === "scale", this.helper.translate.visible = this.mode === "translate", this.helper.rotate.visible = this.mode === "rotate", this.helper.scale.visible = this.mode === "scale";
      let I = [];
      I = I.concat(this.picker[this.mode].children), I = I.concat(this.gizmo[this.mode].children), I = I.concat(this.helper[this.mode].children);
      for (let O = 0; O < I.length; O++) {
        const p = I[O];
        p.visible = true, p.rotation.set(0, 0, 0), p.position.copy(this.worldPosition);
        let R;
        if (this.camera.isOrthographicCamera ? R = (this.camera.top - this.camera.bottom) / this.camera.zoom : R = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7), p.scale.set(1, 1, 1).multiplyScalar(R * this.size / 7), p.tag === "helper") {
          p.visible = false, p.name === "AXIS" ? (p.position.copy(this.worldPositionStart), p.visible = !!this.axis, this.axis === "X" && (this.tempQuaternion.setFromEuler(this.tempEuler.set(0, 0, 0)), p.quaternion.copy(ae2).multiply(this.tempQuaternion), Math.abs(this.alignVector.copy(this.unitX).applyQuaternion(ae2).dot(this.eye)) > 0.9 && (p.visible = false)), this.axis === "Y" && (this.tempQuaternion.setFromEuler(this.tempEuler.set(0, 0, Math.PI / 2)), p.quaternion.copy(ae2).multiply(this.tempQuaternion), Math.abs(this.alignVector.copy(this.unitY).applyQuaternion(ae2).dot(this.eye)) > 0.9 && (p.visible = false)), this.axis === "Z" && (this.tempQuaternion.setFromEuler(this.tempEuler.set(0, Math.PI / 2, 0)), p.quaternion.copy(ae2).multiply(this.tempQuaternion), Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion(ae2).dot(this.eye)) > 0.9 && (p.visible = false)), this.axis === "XYZE" && (this.tempQuaternion.setFromEuler(this.tempEuler.set(0, Math.PI / 2, 0)), this.alignVector.copy(this.rotationAxis), p.quaternion.setFromRotationMatrix(
            this.lookAtMatrix.lookAt(this.zeroVector, this.alignVector, this.unitY)
          ), p.quaternion.multiply(this.tempQuaternion), p.visible = this.dragging), this.axis === "E" && (p.visible = false)) : p.name === "START" ? (p.position.copy(this.worldPositionStart), p.visible = this.dragging) : p.name === "END" ? (p.position.copy(this.worldPosition), p.visible = this.dragging) : p.name === "DELTA" ? (p.position.copy(this.worldPositionStart), p.quaternion.copy(this.worldQuaternionStart), this.tempVector.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1), this.tempVector.applyQuaternion(this.worldQuaternionStart.clone().invert()), p.scale.copy(this.tempVector), p.visible = this.dragging) : (p.quaternion.copy(ae2), this.dragging ? p.position.copy(this.worldPositionStart) : p.position.copy(this.worldPosition), this.axis && (p.visible = this.axis.search(p.name) !== -1));
          continue;
        }
        p.quaternion.copy(ae2), this.mode === "translate" || this.mode === "scale" ? ((p.name === "X" || p.name === "XYZX") && Math.abs(this.alignVector.copy(this.unitX).applyQuaternion(ae2).dot(this.eye)) > 0.99 && (p.scale.set(1e-10, 1e-10, 1e-10), p.visible = false), (p.name === "Y" || p.name === "XYZY") && Math.abs(this.alignVector.copy(this.unitY).applyQuaternion(ae2).dot(this.eye)) > 0.99 && (p.scale.set(1e-10, 1e-10, 1e-10), p.visible = false), (p.name === "Z" || p.name === "XYZZ") && Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion(ae2).dot(this.eye)) > 0.99 && (p.scale.set(1e-10, 1e-10, 1e-10), p.visible = false), p.name === "XY" && Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion(ae2).dot(this.eye)) < 0.2 && (p.scale.set(1e-10, 1e-10, 1e-10), p.visible = false), p.name === "YZ" && Math.abs(this.alignVector.copy(this.unitX).applyQuaternion(ae2).dot(this.eye)) < 0.2 && (p.scale.set(1e-10, 1e-10, 1e-10), p.visible = false), p.name === "XZ" && Math.abs(this.alignVector.copy(this.unitY).applyQuaternion(ae2).dot(this.eye)) < 0.2 && (p.scale.set(1e-10, 1e-10, 1e-10), p.visible = false), p.name.search("X") !== -1 && (this.alignVector.copy(this.unitX).applyQuaternion(ae2).dot(this.eye) < 0 ? p.tag === "fwd" ? p.visible = false : p.scale.x *= -1 : p.tag === "bwd" && (p.visible = false)), p.name.search("Y") !== -1 && (this.alignVector.copy(this.unitY).applyQuaternion(ae2).dot(this.eye) < 0 ? p.tag === "fwd" ? p.visible = false : p.scale.y *= -1 : p.tag === "bwd" && (p.visible = false)), p.name.search("Z") !== -1 && (this.alignVector.copy(this.unitZ).applyQuaternion(ae2).dot(this.eye) < 0 ? p.tag === "fwd" ? p.visible = false : p.scale.z *= -1 : p.tag === "bwd" && (p.visible = false))) : this.mode === "rotate" && (this.tempQuaternion2.copy(ae2), this.alignVector.copy(this.eye).applyQuaternion(this.tempQuaternion.copy(ae2).invert()), p.name.search("E") !== -1 && p.quaternion.setFromRotationMatrix(this.lookAtMatrix.lookAt(this.eye, this.zeroVector, this.unitY)), p.name === "X" && (this.tempQuaternion.setFromAxisAngle(this.unitX, Math.atan2(-this.alignVector.y, this.alignVector.z)), this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2, this.tempQuaternion), p.quaternion.copy(this.tempQuaternion)), p.name === "Y" && (this.tempQuaternion.setFromAxisAngle(this.unitY, Math.atan2(this.alignVector.x, this.alignVector.z)), this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2, this.tempQuaternion), p.quaternion.copy(this.tempQuaternion)), p.name === "Z" && (this.tempQuaternion.setFromAxisAngle(this.unitZ, Math.atan2(this.alignVector.y, this.alignVector.x)), this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2, this.tempQuaternion), p.quaternion.copy(this.tempQuaternion))), p.visible = p.visible && (p.name.indexOf("X") === -1 || this.showX), p.visible = p.visible && (p.name.indexOf("Y") === -1 || this.showY), p.visible = p.visible && (p.name.indexOf("Z") === -1 || this.showZ), p.visible = p.visible && (p.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ), p.material.tempOpacity = p.material.tempOpacity || p.material.opacity, p.material.tempColor = p.material.tempColor || p.material.color.clone(), p.material.color.copy(p.material.tempColor), p.material.opacity = p.material.tempOpacity, this.enabled ? this.axis && (p.name === this.axis ? (p.material.opacity = 1, p.material.color.lerp(new Color(1, 1, 1), 0.5)) : this.axis.split("").some(function(H) {
          return p.name === H;
        }) ? (p.material.opacity = 1, p.material.color.lerp(new Color(1, 1, 1), 0.5)) : (p.material.opacity *= 0.25, p.material.color.lerp(new Color(1, 1, 1), 0.5))) : (p.material.opacity *= 0.5, p.material.color.lerp(new Color(1, 1, 1), 0.5));
      }
      super.updateMatrixWorld();
    });
    const e = new MeshBasicMaterial({
      depthTest: false,
      depthWrite: false,
      transparent: true,
      side: DoubleSide,
      fog: false,
      toneMapped: false
    }), t = new LineBasicMaterial({
      depthTest: false,
      depthWrite: false,
      transparent: true,
      linewidth: 1,
      fog: false,
      toneMapped: false
    }), s = e.clone();
    s.opacity = 0.15;
    const n = e.clone();
    n.opacity = 0.33;
    const i = e.clone();
    i.color.set(16711680);
    const o = e.clone();
    o.color.set(65280);
    const r = e.clone();
    r.color.set(255);
    const a = e.clone();
    a.opacity = 0.25;
    const c = a.clone();
    c.color.set(16776960);
    const u = a.clone();
    u.color.set(65535);
    const h = a.clone();
    h.color.set(16711935), e.clone().color.set(16776960);
    const f = t.clone();
    f.color.set(16711680);
    const E = t.clone();
    E.color.set(65280);
    const v = t.clone();
    v.color.set(255);
    const g = t.clone();
    g.color.set(65535);
    const x = t.clone();
    x.color.set(16711935);
    const M = t.clone();
    M.color.set(16776960);
    const y = t.clone();
    y.color.set(7895160);
    const m = M.clone();
    m.opacity = 0.25;
    const A = new CylinderGeometry(0, 0.05, 0.2, 12, 1, false), b = new BoxGeometry(0.125, 0.125, 0.125), _ = new BufferGeometry();
    _.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 1, 0, 0], 3));
    const T = (se, ae2) => {
      const I = new BufferGeometry(), O = [];
      for (let p = 0; p <= 64 * ae2; ++p)
        O.push(0, Math.cos(p / 32 * Math.PI) * se, Math.sin(p / 32 * Math.PI) * se);
      return I.setAttribute("position", new Float32BufferAttribute(O, 3)), I;
    }, L2 = () => {
      const se = new BufferGeometry();
      return se.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 1, 1, 1], 3)), se;
    }, B = {
      X: [
        [new Mesh(A, i), [1, 0, 0], [0, 0, -Math.PI / 2], null, "fwd"],
        [new Mesh(A, i), [1, 0, 0], [0, 0, Math.PI / 2], null, "bwd"],
        [new Line(_, f)]
      ],
      Y: [
        [new Mesh(A, o), [0, 1, 0], null, null, "fwd"],
        [new Mesh(A, o), [0, 1, 0], [Math.PI, 0, 0], null, "bwd"],
        [new Line(_, E), null, [0, 0, Math.PI / 2]]
      ],
      Z: [
        [new Mesh(A, r), [0, 0, 1], [Math.PI / 2, 0, 0], null, "fwd"],
        [new Mesh(A, r), [0, 0, 1], [-Math.PI / 2, 0, 0], null, "bwd"],
        [new Line(_, v), null, [0, -Math.PI / 2, 0]]
      ],
      XYZ: [[new Mesh(new OctahedronGeometry(0.1, 0), a.clone()), [0, 0, 0], [0, 0, 0]]],
      XY: [
        [new Mesh(new PlaneGeometry(0.295, 0.295), c.clone()), [0.15, 0.15, 0]],
        [new Line(_, M), [0.18, 0.3, 0], null, [0.125, 1, 1]],
        [new Line(_, M), [0.3, 0.18, 0], [0, 0, Math.PI / 2], [0.125, 1, 1]]
      ],
      YZ: [
        [new Mesh(new PlaneGeometry(0.295, 0.295), u.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]],
        [new Line(_, g), [0, 0.18, 0.3], [0, 0, Math.PI / 2], [0.125, 1, 1]],
        [new Line(_, g), [0, 0.3, 0.18], [0, -Math.PI / 2, 0], [0.125, 1, 1]]
      ],
      XZ: [
        [
          new Mesh(new PlaneGeometry(0.295, 0.295), h.clone()),
          [0.15, 0, 0.15],
          [-Math.PI / 2, 0, 0]
        ],
        [new Line(_, x), [0.18, 0, 0.3], null, [0.125, 1, 1]],
        [new Line(_, x), [0.3, 0, 0.18], [0, -Math.PI / 2, 0], [0.125, 1, 1]]
      ]
    }, k = {
      X: [[new Mesh(new CylinderGeometry(0.2, 0, 1, 4, 1, false), s), [0.6, 0, 0], [0, 0, -Math.PI / 2]]],
      Y: [[new Mesh(new CylinderGeometry(0.2, 0, 1, 4, 1, false), s), [0, 0.6, 0]]],
      Z: [[new Mesh(new CylinderGeometry(0.2, 0, 1, 4, 1, false), s), [0, 0, 0.6], [Math.PI / 2, 0, 0]]],
      XYZ: [[new Mesh(new OctahedronGeometry(0.2, 0), s)]],
      XY: [[new Mesh(new PlaneGeometry(0.4, 0.4), s), [0.2, 0.2, 0]]],
      YZ: [[new Mesh(new PlaneGeometry(0.4, 0.4), s), [0, 0.2, 0.2], [0, Math.PI / 2, 0]]],
      XZ: [[new Mesh(new PlaneGeometry(0.4, 0.4), s), [0.2, 0, 0.2], [-Math.PI / 2, 0, 0]]]
    }, N = {
      START: [[new Mesh(new OctahedronGeometry(0.01, 2), n), null, null, null, "helper"]],
      END: [[new Mesh(new OctahedronGeometry(0.01, 2), n), null, null, null, "helper"]],
      DELTA: [[new Line(L2(), n), null, null, null, "helper"]],
      X: [[new Line(_, n.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]],
      Y: [[new Line(_, n.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]],
      Z: [[new Line(_, n.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]]
    }, $ = {
      X: [
        [new Line(T(1, 0.5), f)],
        [new Mesh(new OctahedronGeometry(0.04, 0), i), [0, 0, 0.99], null, [1, 3, 1]]
      ],
      Y: [
        [new Line(T(1, 0.5), E), null, [0, 0, -Math.PI / 2]],
        [new Mesh(new OctahedronGeometry(0.04, 0), o), [0, 0, 0.99], null, [3, 1, 1]]
      ],
      Z: [
        [new Line(T(1, 0.5), v), null, [0, Math.PI / 2, 0]],
        [new Mesh(new OctahedronGeometry(0.04, 0), r), [0.99, 0, 0], null, [1, 3, 1]]
      ],
      E: [
        [new Line(T(1.25, 1), m), null, [0, Math.PI / 2, 0]],
        [
          new Mesh(new CylinderGeometry(0.03, 0, 0.15, 4, 1, false), m),
          [1.17, 0, 0],
          [0, 0, -Math.PI / 2],
          [1, 1, 1e-3]
        ],
        [
          new Mesh(new CylinderGeometry(0.03, 0, 0.15, 4, 1, false), m),
          [-1.17, 0, 0],
          [0, 0, Math.PI / 2],
          [1, 1, 1e-3]
        ],
        [
          new Mesh(new CylinderGeometry(0.03, 0, 0.15, 4, 1, false), m),
          [0, -1.17, 0],
          [Math.PI, 0, 0],
          [1, 1, 1e-3]
        ],
        [
          new Mesh(new CylinderGeometry(0.03, 0, 0.15, 4, 1, false), m),
          [0, 1.17, 0],
          [0, 0, 0],
          [1, 1, 1e-3]
        ]
      ],
      XYZE: [[new Line(T(1, 1), y), null, [0, Math.PI / 2, 0]]]
    }, Q = {
      AXIS: [[new Line(_, n.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]]
    }, Z = {
      X: [[new Mesh(new TorusGeometry(1, 0.1, 4, 24), s), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]],
      Y: [[new Mesh(new TorusGeometry(1, 0.1, 4, 24), s), [0, 0, 0], [Math.PI / 2, 0, 0]]],
      Z: [[new Mesh(new TorusGeometry(1, 0.1, 4, 24), s), [0, 0, 0], [0, 0, -Math.PI / 2]]],
      E: [[new Mesh(new TorusGeometry(1.25, 0.1, 2, 24), s)]],
      XYZE: [[new Mesh(new SphereGeometry(0.7, 10, 8), s)]]
    }, me = {
      X: [
        [new Mesh(b, i), [0.8, 0, 0], [0, 0, -Math.PI / 2]],
        [new Line(_, f), null, null, [0.8, 1, 1]]
      ],
      Y: [
        [new Mesh(b, o), [0, 0.8, 0]],
        [new Line(_, E), null, [0, 0, Math.PI / 2], [0.8, 1, 1]]
      ],
      Z: [
        [new Mesh(b, r), [0, 0, 0.8], [Math.PI / 2, 0, 0]],
        [new Line(_, v), null, [0, -Math.PI / 2, 0], [0.8, 1, 1]]
      ],
      XY: [
        [new Mesh(b, c), [0.85, 0.85, 0], null, [2, 2, 0.2]],
        [new Line(_, M), [0.855, 0.98, 0], null, [0.125, 1, 1]],
        [new Line(_, M), [0.98, 0.855, 0], [0, 0, Math.PI / 2], [0.125, 1, 1]]
      ],
      YZ: [
        [new Mesh(b, u), [0, 0.85, 0.85], null, [0.2, 2, 2]],
        [new Line(_, g), [0, 0.855, 0.98], [0, 0, Math.PI / 2], [0.125, 1, 1]],
        [new Line(_, g), [0, 0.98, 0.855], [0, -Math.PI / 2, 0], [0.125, 1, 1]]
      ],
      XZ: [
        [new Mesh(b, h), [0.85, 0, 0.85], null, [2, 0.2, 2]],
        [new Line(_, x), [0.855, 0, 0.98], null, [0.125, 1, 1]],
        [new Line(_, x), [0.98, 0, 0.855], [0, -Math.PI / 2, 0], [0.125, 1, 1]]
      ],
      XYZX: [[new Mesh(new BoxGeometry(0.125, 0.125, 0.125), a.clone()), [1.1, 0, 0]]],
      XYZY: [[new Mesh(new BoxGeometry(0.125, 0.125, 0.125), a.clone()), [0, 1.1, 0]]],
      XYZZ: [[new Mesh(new BoxGeometry(0.125, 0.125, 0.125), a.clone()), [0, 0, 1.1]]]
    }, X = {
      X: [[new Mesh(new CylinderGeometry(0.2, 0, 0.8, 4, 1, false), s), [0.5, 0, 0], [0, 0, -Math.PI / 2]]],
      Y: [[new Mesh(new CylinderGeometry(0.2, 0, 0.8, 4, 1, false), s), [0, 0.5, 0]]],
      Z: [[new Mesh(new CylinderGeometry(0.2, 0, 0.8, 4, 1, false), s), [0, 0, 0.5], [Math.PI / 2, 0, 0]]],
      XY: [[new Mesh(b, s), [0.85, 0.85, 0], null, [3, 3, 0.2]]],
      YZ: [[new Mesh(b, s), [0, 0.85, 0.85], null, [0.2, 3, 3]]],
      XZ: [[new Mesh(b, s), [0.85, 0, 0.85], null, [3, 0.2, 3]]],
      XYZX: [[new Mesh(new BoxGeometry(0.2, 0.2, 0.2), s), [1.1, 0, 0]]],
      XYZY: [[new Mesh(new BoxGeometry(0.2, 0.2, 0.2), s), [0, 1.1, 0]]],
      XYZZ: [[new Mesh(new BoxGeometry(0.2, 0.2, 0.2), s), [0, 0, 1.1]]]
    }, z = {
      X: [[new Line(_, n.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]],
      Y: [[new Line(_, n.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]],
      Z: [[new Line(_, n.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]]
    }, ce = (se) => {
      const ae2 = new Object3D();
      for (let I in se)
        for (let O = se[I].length; O--; ) {
          const p = se[I][O][0].clone(), R = se[I][O][1], H = se[I][O][2], S = se[I][O][3], V = se[I][O][4];
          p.name = I, p.tag = V, R && p.position.set(R[0], R[1], R[2]), H && p.rotation.set(H[0], H[1], H[2]), S && p.scale.set(S[0], S[1], S[2]), p.updateMatrix();
          const ie = p.geometry.clone();
          ie.applyMatrix4(p.matrix), p.geometry = ie, p.renderOrder = 1 / 0, p.position.set(0, 0, 0), p.rotation.set(0, 0, 0), p.scale.set(1, 1, 1), ae2.add(p);
        }
      return ae2;
    };
    this.gizmo = {}, this.picker = {}, this.helper = {}, this.add(this.gizmo.translate = ce(B)), this.add(this.gizmo.rotate = ce($)), this.add(this.gizmo.scale = ce(me)), this.add(this.picker.translate = ce(k)), this.add(this.picker.rotate = ce(Z)), this.add(this.picker.scale = ce(X)), this.add(this.helper.translate = ce(N)), this.add(this.helper.rotate = ce(Q)), this.add(this.helper.scale = ce(z)), this.picker.translate.visible = false, this.picker.rotate.visible = false, this.picker.scale.visible = false;
  }
};
var hr = class extends Mesh {
  constructor() {
    super(
      new PlaneGeometry(1e5, 1e5, 2, 2),
      new MeshBasicMaterial({
        visible: false,
        wireframe: true,
        side: DoubleSide,
        transparent: true,
        opacity: 0.1,
        toneMapped: false
      })
    ), F(this, "isTransformControlsPlane", true), F(this, "type", "TransformControlsPlane"), F(this, "unitX", new Vector3(1, 0, 0)), F(this, "unitY", new Vector3(0, 1, 0)), F(this, "unitZ", new Vector3(0, 0, 1)), F(this, "tempVector", new Vector3()), F(this, "dirVector", new Vector3()), F(this, "alignVector", new Vector3()), F(this, "tempMatrix", new Matrix4()), F(this, "identityQuaternion", new Quaternion()), F(this, "cameraQuaternion", new Quaternion()), F(this, "worldPosition", new Vector3()), F(this, "worldQuaternion", new Quaternion()), F(this, "eye", new Vector3()), F(this, "axis", null), F(this, "mode", "translate"), F(this, "space", "world"), F(this, "updateMatrixWorld", () => {
      let e = this.space;
      switch (this.position.copy(this.worldPosition), this.mode === "scale" && (e = "local"), this.unitX.set(1, 0, 0).applyQuaternion(e === "local" ? this.worldQuaternion : this.identityQuaternion), this.unitY.set(0, 1, 0).applyQuaternion(e === "local" ? this.worldQuaternion : this.identityQuaternion), this.unitZ.set(0, 0, 1).applyQuaternion(e === "local" ? this.worldQuaternion : this.identityQuaternion), this.alignVector.copy(this.unitY), this.mode) {
        case "translate":
        case "scale":
          switch (this.axis) {
            case "X":
              this.alignVector.copy(this.eye).cross(this.unitX), this.dirVector.copy(this.unitX).cross(this.alignVector);
              break;
            case "Y":
              this.alignVector.copy(this.eye).cross(this.unitY), this.dirVector.copy(this.unitY).cross(this.alignVector);
              break;
            case "Z":
              this.alignVector.copy(this.eye).cross(this.unitZ), this.dirVector.copy(this.unitZ).cross(this.alignVector);
              break;
            case "XY":
              this.dirVector.copy(this.unitZ);
              break;
            case "YZ":
              this.dirVector.copy(this.unitX);
              break;
            case "XZ":
              this.alignVector.copy(this.unitZ), this.dirVector.copy(this.unitY);
              break;
            case "XYZ":
            case "E":
              this.dirVector.set(0, 0, 0);
              break;
          }
          break;
        case "rotate":
        default:
          this.dirVector.set(0, 0, 0);
      }
      this.dirVector.length() === 0 ? this.quaternion.copy(this.cameraQuaternion) : (this.tempMatrix.lookAt(this.tempVector.set(0, 0, 0), this.dirVector, this.alignVector), this.quaternion.setFromRotationMatrix(this.tempMatrix)), super.updateMatrixWorld();
    });
  }
};
var ur = Object.defineProperty;
var pr = (l, e, t) => e in l ? ur(l, e, { enumerable: true, configurable: true, writable: true, value: t }) : l[e] = t;
var Be = (l, e, t) => (pr(l, typeof e != "symbol" ? e + "" : e, t), t);
var Xt = new Euler(0, 0, 0, "YXZ");
var Zt = new Vector3();
var dr = { type: "change" };
var fr = { type: "lock" };
var mr = { type: "unlock" };
var Hn = Math.PI / 2;
var bn = class extends EventDispatcher {
  constructor(e, t) {
    super(), Be(this, "camera"), Be(this, "domElement"), Be(this, "isLocked"), Be(this, "minPolarAngle"), Be(this, "maxPolarAngle"), Be(this, "pointerSpeed"), Be(this, "onMouseMove", (s) => {
      if (!this.domElement || this.isLocked === false)
        return;
      const n = s.movementX || s.mozMovementX || s.webkitMovementX || 0, i = s.movementY || s.mozMovementY || s.webkitMovementY || 0;
      Xt.setFromQuaternion(this.camera.quaternion), Xt.y -= n * 2e-3 * this.pointerSpeed, Xt.x -= i * 2e-3 * this.pointerSpeed, Xt.x = Math.max(Hn - this.maxPolarAngle, Math.min(Hn - this.minPolarAngle, Xt.x)), this.camera.quaternion.setFromEuler(Xt), this.dispatchEvent(dr);
    }), Be(this, "onPointerlockChange", () => {
      this.domElement && (this.domElement.ownerDocument.pointerLockElement === this.domElement ? (this.dispatchEvent(fr), this.isLocked = true) : (this.dispatchEvent(mr), this.isLocked = false));
    }), Be(this, "onPointerlockError", () => {
      console.error("THREE.PointerLockControls: Unable to use Pointer Lock API");
    }), Be(this, "connect", (s) => {
      this.domElement = s || this.domElement, this.domElement && (this.domElement.ownerDocument.addEventListener("mousemove", this.onMouseMove), this.domElement.ownerDocument.addEventListener("pointerlockchange", this.onPointerlockChange), this.domElement.ownerDocument.addEventListener("pointerlockerror", this.onPointerlockError));
    }), Be(this, "disconnect", () => {
      this.domElement && (this.domElement.ownerDocument.removeEventListener("mousemove", this.onMouseMove), this.domElement.ownerDocument.removeEventListener("pointerlockchange", this.onPointerlockChange), this.domElement.ownerDocument.removeEventListener("pointerlockerror", this.onPointerlockError));
    }), Be(this, "dispose", () => {
      this.disconnect();
    }), Be(this, "getObject", () => this.camera), Be(this, "direction", new Vector3(0, 0, -1)), Be(this, "getDirection", (s) => s.copy(this.direction).applyQuaternion(this.camera.quaternion)), Be(this, "moveForward", (s) => {
      Zt.setFromMatrixColumn(this.camera.matrix, 0), Zt.crossVectors(this.camera.up, Zt), this.camera.position.addScaledVector(Zt, s);
    }), Be(this, "moveRight", (s) => {
      Zt.setFromMatrixColumn(this.camera.matrix, 0), this.camera.position.addScaledVector(Zt, s);
    }), Be(this, "lock", () => {
      this.domElement && this.domElement.requestPointerLock();
    }), Be(this, "unlock", () => {
      this.domElement && this.domElement.ownerDocument.exitPointerLock();
    }), this.camera = e, this.domElement = t, this.isLocked = false, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.pointerSpeed = 1, t && this.connect(t);
  }
};
var gr = Object.defineProperty;
var yr = (l, e, t) => e in l ? gr(l, e, { enumerable: true, configurable: true, writable: true, value: t }) : l[e] = t;
var re = (l, e, t) => (yr(l, typeof e != "symbol" ? e + "" : e, t), t);
var Vn = (l, e) => (l % e + e) % e;
var Fi = class extends EventDispatcher {
  constructor(e, t) {
    super(), re(this, "object"), re(this, "domElement"), re(this, "enabled", true), re(this, "target", new Vector3()), re(this, "minDistance", 0), re(this, "maxDistance", 1 / 0), re(this, "minZoom", 0), re(this, "maxZoom", 1 / 0), re(this, "minPolarAngle", 0), re(this, "maxPolarAngle", Math.PI), re(this, "minAzimuthAngle", -1 / 0), re(this, "maxAzimuthAngle", 1 / 0), re(this, "enableDamping", false), re(this, "dampingFactor", 0.05), re(this, "enableZoom", true), re(this, "zoomSpeed", 1), re(this, "enableRotate", true), re(this, "rotateSpeed", 1), re(this, "enablePan", true), re(this, "panSpeed", 1), re(this, "screenSpacePanning", true), re(this, "keyPanSpeed", 7), re(this, "autoRotate", false), re(this, "autoRotateSpeed", 2), re(this, "reverseOrbit", false), re(this, "reverseHorizontalOrbit", false), re(this, "reverseVerticalOrbit", false), re(this, "keys", { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }), re(this, "mouseButtons", {
      LEFT: MOUSE.ROTATE,
      MIDDLE: MOUSE.DOLLY,
      RIGHT: MOUSE.PAN
    }), re(this, "touches", { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN }), re(this, "target0"), re(this, "position0"), re(this, "zoom0"), re(this, "_domElementKeyEvents", null), re(this, "getPolarAngle"), re(this, "getAzimuthalAngle"), re(this, "setPolarAngle"), re(this, "setAzimuthalAngle"), re(this, "getDistance"), re(this, "listenToKeyEvents"), re(this, "stopListenToKeyEvents"), re(this, "saveState"), re(this, "reset"), re(this, "update"), re(this, "connect"), re(this, "dispose"), this.object = e, this.domElement = t, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this.getPolarAngle = () => u.phi, this.getAzimuthalAngle = () => u.theta, this.setPolarAngle = (C) => {
      let G = Vn(C, 2 * Math.PI), le = u.phi;
      le < 0 && (le += 2 * Math.PI), G < 0 && (G += 2 * Math.PI);
      let Ae = Math.abs(G - le);
      2 * Math.PI - Ae < Ae && (G < le ? G += 2 * Math.PI : le += 2 * Math.PI), h.phi = G - le, s.update();
    }, this.setAzimuthalAngle = (C) => {
      let G = Vn(C, 2 * Math.PI), le = u.theta;
      le < 0 && (le += 2 * Math.PI), G < 0 && (G += 2 * Math.PI);
      let Ae = Math.abs(G - le);
      2 * Math.PI - Ae < Ae && (G < le ? G += 2 * Math.PI : le += 2 * Math.PI), h.theta = G - le, s.update();
    }, this.getDistance = () => s.object.position.distanceTo(s.target), this.listenToKeyEvents = (C) => {
      C.addEventListener("keydown", ts), this._domElementKeyEvents = C;
    }, this.stopListenToKeyEvents = () => {
      this._domElementKeyEvents.removeEventListener("keydown", ts), this._domElementKeyEvents = null;
    }, this.saveState = () => {
      s.target0.copy(s.target), s.position0.copy(s.object.position), s.zoom0 = s.object.zoom;
    }, this.reset = () => {
      s.target.copy(s.target0), s.object.position.copy(s.position0), s.object.zoom = s.zoom0, s.object.updateProjectionMatrix(), s.dispatchEvent(n), s.update(), a = r.NONE;
    }, this.update = (() => {
      const C = new Vector3(), G = new Vector3(0, 1, 0), le = new Quaternion().setFromUnitVectors(e.up, G), Ae = le.clone().invert(), He = new Vector3(), Ct = new Quaternion(), _t = 2 * Math.PI;
      return function() {
        const Fn = s.object.position;
        le.setFromUnitVectors(e.up, G), Ae.copy(le).invert(), C.copy(Fn).sub(s.target), C.applyQuaternion(le), u.setFromVector3(C), s.autoRotate && a === r.NONE && N(B()), s.enableDamping ? (u.theta += h.theta * s.dampingFactor, u.phi += h.phi * s.dampingFactor) : (u.theta += h.theta, u.phi += h.phi);
        let pt = s.minAzimuthAngle, dt2 = s.maxAzimuthAngle;
        return isFinite(pt) && isFinite(dt2) && (pt < -Math.PI ? pt += _t : pt > Math.PI && (pt -= _t), dt2 < -Math.PI ? dt2 += _t : dt2 > Math.PI && (dt2 -= _t), pt <= dt2 ? u.theta = Math.max(pt, Math.min(dt2, u.theta)) : u.theta = u.theta > (pt + dt2) / 2 ? Math.max(pt, u.theta) : Math.min(dt2, u.theta)), u.phi = Math.max(s.minPolarAngle, Math.min(s.maxPolarAngle, u.phi)), u.makeSafe(), u.radius *= d, u.radius = Math.max(s.minDistance, Math.min(s.maxDistance, u.radius)), s.enableDamping === true ? s.target.addScaledVector(f, s.dampingFactor) : s.target.add(f), C.setFromSpherical(u), C.applyQuaternion(Ae), Fn.copy(s.target).add(C), s.object.lookAt(s.target), s.enableDamping === true ? (h.theta *= 1 - s.dampingFactor, h.phi *= 1 - s.dampingFactor, f.multiplyScalar(1 - s.dampingFactor)) : (h.set(0, 0, 0), f.set(0, 0, 0)), d = 1, E || He.distanceToSquared(s.object.position) > c || 8 * (1 - Ct.dot(s.object.quaternion)) > c ? (s.dispatchEvent(n), He.copy(s.object.position), Ct.copy(s.object.quaternion), E = false, true) : false;
      };
    })(), this.connect = (C) => {
      C === document && console.error(
        'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'
      ), s.domElement = C, s.domElement.style.touchAction = "none", s.domElement.addEventListener("contextmenu", xs), s.domElement.addEventListener("pointerdown", w), s.domElement.addEventListener("pointercancel", Oe), s.domElement.addEventListener("wheel", yt);
    }, this.dispose = () => {
      var C, G, le, Ae, He, Ct;
      (C = s.domElement) == null || C.removeEventListener("contextmenu", xs), (G = s.domElement) == null || G.removeEventListener("pointerdown", w), (le = s.domElement) == null || le.removeEventListener("pointercancel", Oe), (Ae = s.domElement) == null || Ae.removeEventListener("wheel", yt), (He = s.domElement) == null || He.ownerDocument.removeEventListener("pointermove", q), (Ct = s.domElement) == null || Ct.ownerDocument.removeEventListener("pointerup", ge), s._domElementKeyEvents !== null && s._domElementKeyEvents.removeEventListener("keydown", ts);
    };
    const s = this, n = { type: "change" }, i = { type: "start" }, o = { type: "end" }, r = {
      NONE: -1,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2,
      TOUCH_ROTATE: 3,
      TOUCH_PAN: 4,
      TOUCH_DOLLY_PAN: 5,
      TOUCH_DOLLY_ROTATE: 6
    };
    let a = r.NONE;
    const c = 1e-6, u = new Spherical(), h = new Spherical();
    let d = 1;
    const f = new Vector3();
    let E = false;
    const v = new Vector2(), g = new Vector2(), x = new Vector2(), M = new Vector2(), y = new Vector2(), m = new Vector2(), A = new Vector2(), b = new Vector2(), _ = new Vector2(), T = [], L2 = {};
    function B() {
      return 2 * Math.PI / 60 / 60 * s.autoRotateSpeed;
    }
    function k() {
      return Math.pow(0.95, s.zoomSpeed);
    }
    function N(C) {
      s.reverseOrbit || s.reverseHorizontalOrbit ? h.theta += C : h.theta -= C;
    }
    function $(C) {
      s.reverseOrbit || s.reverseVerticalOrbit ? h.phi += C : h.phi -= C;
    }
    const Q = (() => {
      const C = new Vector3();
      return function(le, Ae) {
        C.setFromMatrixColumn(Ae, 0), C.multiplyScalar(-le), f.add(C);
      };
    })(), Z = (() => {
      const C = new Vector3();
      return function(le, Ae) {
        s.screenSpacePanning === true ? C.setFromMatrixColumn(Ae, 1) : (C.setFromMatrixColumn(Ae, 0), C.crossVectors(s.object.up, C)), C.multiplyScalar(le), f.add(C);
      };
    })(), me = (() => {
      const C = new Vector3();
      return function(le, Ae) {
        const He = s.domElement;
        if (He && s.object instanceof PerspectiveCamera && s.object.isPerspectiveCamera) {
          const Ct = s.object.position;
          C.copy(Ct).sub(s.target);
          let _t = C.length();
          _t *= Math.tan(s.object.fov / 2 * Math.PI / 180), Q(2 * le * _t / He.clientHeight, s.object.matrix), Z(2 * Ae * _t / He.clientHeight, s.object.matrix);
        } else
          He && s.object instanceof OrthographicCamera && s.object.isOrthographicCamera ? (Q(
            le * (s.object.right - s.object.left) / s.object.zoom / He.clientWidth,
            s.object.matrix
          ), Z(
            Ae * (s.object.top - s.object.bottom) / s.object.zoom / He.clientHeight,
            s.object.matrix
          )) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), s.enablePan = false);
      };
    })();
    function X(C) {
      s.object instanceof PerspectiveCamera && s.object.isPerspectiveCamera ? d /= C : s.object instanceof OrthographicCamera && s.object.isOrthographicCamera ? (s.object.zoom = Math.max(s.minZoom, Math.min(s.maxZoom, s.object.zoom * C)), s.object.updateProjectionMatrix(), E = true) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), s.enableZoom = false);
    }
    function z(C) {
      s.object instanceof PerspectiveCamera && s.object.isPerspectiveCamera ? d *= C : s.object instanceof OrthographicCamera && s.object.isOrthographicCamera ? (s.object.zoom = Math.max(s.minZoom, Math.min(s.maxZoom, s.object.zoom / C)), s.object.updateProjectionMatrix(), E = true) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), s.enableZoom = false);
    }
    function ce(C) {
      v.set(C.clientX, C.clientY);
    }
    function se(C) {
      A.set(C.clientX, C.clientY);
    }
    function ae2(C) {
      M.set(C.clientX, C.clientY);
    }
    function I(C) {
      g.set(C.clientX, C.clientY), x.subVectors(g, v).multiplyScalar(s.rotateSpeed);
      const G = s.domElement;
      G && (N(2 * Math.PI * x.x / G.clientHeight), $(2 * Math.PI * x.y / G.clientHeight)), v.copy(g), s.update();
    }
    function O(C) {
      b.set(C.clientX, C.clientY), _.subVectors(b, A), _.y > 0 ? X(k()) : _.y < 0 && z(k()), A.copy(b), s.update();
    }
    function p(C) {
      y.set(C.clientX, C.clientY), m.subVectors(y, M).multiplyScalar(s.panSpeed), me(m.x, m.y), M.copy(y), s.update();
    }
    function R(C) {
      C.deltaY < 0 ? z(k()) : C.deltaY > 0 && X(k()), s.update();
    }
    function H(C) {
      let G = false;
      switch (C.code) {
        case s.keys.UP:
          me(0, s.keyPanSpeed), G = true;
          break;
        case s.keys.BOTTOM:
          me(0, -s.keyPanSpeed), G = true;
          break;
        case s.keys.LEFT:
          me(s.keyPanSpeed, 0), G = true;
          break;
        case s.keys.RIGHT:
          me(-s.keyPanSpeed, 0), G = true;
          break;
      }
      G && (C.preventDefault(), s.update());
    }
    function S() {
      if (T.length == 1)
        v.set(T[0].pageX, T[0].pageY);
      else {
        const C = 0.5 * (T[0].pageX + T[1].pageX), G = 0.5 * (T[0].pageY + T[1].pageY);
        v.set(C, G);
      }
    }
    function V() {
      if (T.length == 1)
        M.set(T[0].pageX, T[0].pageY);
      else {
        const C = 0.5 * (T[0].pageX + T[1].pageX), G = 0.5 * (T[0].pageY + T[1].pageY);
        M.set(C, G);
      }
    }
    function ie() {
      const C = T[0].pageX - T[1].pageX, G = T[0].pageY - T[1].pageY, le = Math.sqrt(C * C + G * G);
      A.set(0, le);
    }
    function J() {
      s.enableZoom && ie(), s.enablePan && V();
    }
    function te() {
      s.enableZoom && ie(), s.enableRotate && S();
    }
    function K(C) {
      if (T.length == 1)
        g.set(C.pageX, C.pageY);
      else {
        const le = js(C), Ae = 0.5 * (C.pageX + le.x), He = 0.5 * (C.pageY + le.y);
        g.set(Ae, He);
      }
      x.subVectors(g, v).multiplyScalar(s.rotateSpeed);
      const G = s.domElement;
      G && (N(2 * Math.PI * x.x / G.clientHeight), $(2 * Math.PI * x.y / G.clientHeight)), v.copy(g);
    }
    function Te(C) {
      if (T.length == 1)
        y.set(C.pageX, C.pageY);
      else {
        const G = js(C), le = 0.5 * (C.pageX + G.x), Ae = 0.5 * (C.pageY + G.y);
        y.set(le, Ae);
      }
      m.subVectors(y, M).multiplyScalar(s.panSpeed), me(m.x, m.y), M.copy(y);
    }
    function j(C) {
      const G = js(C), le = C.pageX - G.x, Ae = C.pageY - G.y, He = Math.sqrt(le * le + Ae * Ae);
      b.set(0, He), _.set(0, Math.pow(b.y / A.y, s.zoomSpeed)), X(_.y), A.copy(b);
    }
    function W(C) {
      s.enableZoom && j(C), s.enablePan && Te(C);
    }
    function P(C) {
      s.enableZoom && j(C), s.enableRotate && K(C);
    }
    function w(C) {
      var G, le;
      s.enabled !== false && (T.length === 0 && ((G = s.domElement) == null || G.ownerDocument.addEventListener("pointermove", q), (le = s.domElement) == null || le.ownerDocument.addEventListener("pointerup", ge)), ws(C), C.pointerType === "touch" ? Gs(C) : ze(C));
    }
    function q(C) {
      s.enabled !== false && (C.pointerType === "touch" ? Es(C) : Ke(C));
    }
    function ge(C) {
      var G, le, Ae;
      Dn(C), T.length === 0 && ((G = s.domElement) == null || G.releasePointerCapture(C.pointerId), (le = s.domElement) == null || le.ownerDocument.removeEventListener("pointermove", q), (Ae = s.domElement) == null || Ae.ownerDocument.removeEventListener("pointerup", ge)), s.dispatchEvent(o), a = r.NONE;
    }
    function Oe(C) {
      Dn(C);
    }
    function ze(C) {
      let G;
      switch (C.button) {
        case 0:
          G = s.mouseButtons.LEFT;
          break;
        case 1:
          G = s.mouseButtons.MIDDLE;
          break;
        case 2:
          G = s.mouseButtons.RIGHT;
          break;
        default:
          G = -1;
      }
      switch (G) {
        case MOUSE.DOLLY:
          if (s.enableZoom === false)
            return;
          se(C), a = r.DOLLY;
          break;
        case MOUSE.ROTATE:
          if (C.ctrlKey || C.metaKey || C.shiftKey) {
            if (s.enablePan === false)
              return;
            ae2(C), a = r.PAN;
          } else {
            if (s.enableRotate === false)
              return;
            ce(C), a = r.ROTATE;
          }
          break;
        case MOUSE.PAN:
          if (C.ctrlKey || C.metaKey || C.shiftKey) {
            if (s.enableRotate === false)
              return;
            ce(C), a = r.ROTATE;
          } else {
            if (s.enablePan === false)
              return;
            ae2(C), a = r.PAN;
          }
          break;
        default:
          a = r.NONE;
      }
      a !== r.NONE && s.dispatchEvent(i);
    }
    function Ke(C) {
      if (s.enabled !== false)
        switch (a) {
          case r.ROTATE:
            if (s.enableRotate === false)
              return;
            I(C);
            break;
          case r.DOLLY:
            if (s.enableZoom === false)
              return;
            O(C);
            break;
          case r.PAN:
            if (s.enablePan === false)
              return;
            p(C);
            break;
        }
    }
    function yt(C) {
      s.enabled === false || s.enableZoom === false || a !== r.NONE && a !== r.ROTATE || (C.preventDefault(), s.dispatchEvent(i), R(C), s.dispatchEvent(o));
    }
    function ts(C) {
      s.enabled === false || s.enablePan === false || H(C);
    }
    function Gs(C) {
      switch (kn(C), T.length) {
        case 1:
          switch (s.touches.ONE) {
            case TOUCH.ROTATE:
              if (s.enableRotate === false)
                return;
              S(), a = r.TOUCH_ROTATE;
              break;
            case TOUCH.PAN:
              if (s.enablePan === false)
                return;
              V(), a = r.TOUCH_PAN;
              break;
            default:
              a = r.NONE;
          }
          break;
        case 2:
          switch (s.touches.TWO) {
            case TOUCH.DOLLY_PAN:
              if (s.enableZoom === false && s.enablePan === false)
                return;
              J(), a = r.TOUCH_DOLLY_PAN;
              break;
            case TOUCH.DOLLY_ROTATE:
              if (s.enableZoom === false && s.enableRotate === false)
                return;
              te(), a = r.TOUCH_DOLLY_ROTATE;
              break;
            default:
              a = r.NONE;
          }
          break;
        default:
          a = r.NONE;
      }
      a !== r.NONE && s.dispatchEvent(i);
    }
    function Es(C) {
      switch (kn(C), a) {
        case r.TOUCH_ROTATE:
          if (s.enableRotate === false)
            return;
          K(C), s.update();
          break;
        case r.TOUCH_PAN:
          if (s.enablePan === false)
            return;
          Te(C), s.update();
          break;
        case r.TOUCH_DOLLY_PAN:
          if (s.enableZoom === false && s.enablePan === false)
            return;
          W(C), s.update();
          break;
        case r.TOUCH_DOLLY_ROTATE:
          if (s.enableZoom === false && s.enableRotate === false)
            return;
          P(C), s.update();
          break;
        default:
          a = r.NONE;
      }
    }
    function xs(C) {
      s.enabled !== false && C.preventDefault();
    }
    function ws(C) {
      T.push(C);
    }
    function Dn(C) {
      delete L2[C.pointerId];
      for (let G = 0; G < T.length; G++)
        if (T[G].pointerId == C.pointerId) {
          T.splice(G, 1);
          return;
        }
    }
    function kn(C) {
      let G = L2[C.pointerId];
      G === void 0 && (G = new Vector2(), L2[C.pointerId] = G), G.set(C.pageX, C.pageY);
    }
    function js(C) {
      const G = C.pointerId === T[0].pointerId ? T[1] : T[0];
      return L2[G.pointerId];
    }
    t !== void 0 && this.connect(t), this.update();
  }
};
var _r = class extends Fi {
  constructor(e, t) {
    super(e, t), this.screenSpacePanning = false, this.mouseButtons.LEFT = MOUSE.PAN, this.mouseButtons.RIGHT = MOUSE.ROTATE, this.touches.ONE = TOUCH.PAN, this.touches.TWO = TOUCH.DOLLY_ROTATE;
  }
};
var vr = class extends Loader {
  constructor(e) {
    super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(t) {
      return new br(t);
    }), this.register(function(t) {
      return new Cr(t);
    }), this.register(function(t) {
      return new Ir(t);
    }), this.register(function(t) {
      return new Dr(t);
    }), this.register(function(t) {
      return new Mr(t);
    }), this.register(function(t) {
      return new Sr(t);
    }), this.register(function(t) {
      return new Pr(t);
    }), this.register(function(t) {
      return new Or(t);
    }), this.register(function(t) {
      return new wr(t);
    }), this.register(function(t) {
      return new Lr(t);
    }), this.register(function(t) {
      return new Ar(t);
    }), this.register(function(t) {
      return new Rr(t);
    }), this.register(function(t) {
      return new Er(t);
    }), this.register(function(t) {
      return new kr(t);
    }), this.register(function(t) {
      return new Fr(t);
    });
  }
  load(e, t, s, n) {
    const i = this;
    let o;
    this.resourcePath !== "" ? o = this.resourcePath : this.path !== "" ? o = this.path : o = LoaderUtils.extractUrlBase(e), this.manager.itemStart(e);
    const r = function(c) {
      n ? n(c) : console.error(c), i.manager.itemError(e), i.manager.itemEnd(e);
    }, a = new FileLoader(this.manager);
    a.setPath(this.path), a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(
      e,
      function(c) {
        try {
          i.parse(
            c,
            o,
            function(u) {
              t(u), i.manager.itemEnd(e);
            },
            r
          );
        } catch (u) {
          r(u);
        }
      },
      s,
      r
    );
  }
  setDRACOLoader(e) {
    return this.dracoLoader = e, this;
  }
  setDDSLoader() {
    throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".');
  }
  setKTX2Loader(e) {
    return this.ktx2Loader = e, this;
  }
  setMeshoptDecoder(e) {
    return this.meshoptDecoder = e, this;
  }
  register(e) {
    return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this;
  }
  unregister(e) {
    return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
  }
  parse(e, t, s, n) {
    let i;
    const o = {}, r = {};
    if (typeof e == "string")
      i = JSON.parse(e);
    else if (e instanceof ArrayBuffer)
      if (LoaderUtils.decodeText(new Uint8Array(e.slice(0, 4))) === Ui) {
        try {
          o[ve.KHR_BINARY_GLTF] = new Ur(e);
        } catch (u) {
          n && n(u);
          return;
        }
        i = JSON.parse(o[ve.KHR_BINARY_GLTF].content);
      } else
        i = JSON.parse(LoaderUtils.decodeText(new Uint8Array(e)));
    else
      i = e;
    if (i.asset === void 0 || i.asset.version[0] < 2) {
      n && n(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
      return;
    }
    const a = new Wr(i, {
      path: t || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder
    });
    a.fileLoader.setRequestHeader(this.requestHeader);
    for (let c = 0; c < this.pluginCallbacks.length; c++) {
      const u = this.pluginCallbacks[c](a);
      r[u.name] = u, o[u.name] = true;
    }
    if (i.extensionsUsed)
      for (let c = 0; c < i.extensionsUsed.length; ++c) {
        const u = i.extensionsUsed[c], h = i.extensionsRequired || [];
        switch (u) {
          case ve.KHR_MATERIALS_UNLIT:
            o[u] = new xr();
            break;
          case ve.KHR_DRACO_MESH_COMPRESSION:
            o[u] = new Br(i, this.dracoLoader);
            break;
          case ve.KHR_TEXTURE_TRANSFORM:
            o[u] = new Nr();
            break;
          case ve.KHR_MESH_QUANTIZATION:
            o[u] = new zr();
            break;
          default:
            h.indexOf(u) >= 0 && r[u] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + u + '".');
        }
      }
    a.setExtensions(o), a.setPlugins(r), a.parse(s, n);
  }
  parseAsync(e, t) {
    const s = this;
    return new Promise(function(n, i) {
      s.parse(e, t, n, i);
    });
  }
};
function Tr() {
  let l = {};
  return {
    get: function(e) {
      return l[e];
    },
    add: function(e, t) {
      l[e] = t;
    },
    remove: function(e) {
      delete l[e];
    },
    removeAll: function() {
      l = {};
    }
  };
}
var ve = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
var Er = class {
  constructor(e) {
    this.parser = e, this.name = ve.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const e = this.parser, t = this.parser.json.nodes || [];
    for (let s = 0, n = t.length; s < n; s++) {
      const i = t[s];
      i.extensions && i.extensions[this.name] && i.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, i.extensions[this.name].light);
    }
  }
  _loadLight(e) {
    const t = this.parser, s = "light:" + e;
    let n = t.cache.get(s);
    if (n)
      return n;
    const i = t.json, a = ((i.extensions && i.extensions[this.name] || {}).lights || [])[e];
    let c;
    const u = new Color(16777215);
    a.color !== void 0 && u.fromArray(a.color);
    const h = a.range !== void 0 ? a.range : 0;
    switch (a.type) {
      case "directional":
        c = new DirectionalLight(u), c.target.position.set(0, 0, -1), c.add(c.target);
        break;
      case "point":
        c = new PointLight(u), c.distance = h;
        break;
      case "spot":
        c = new SpotLight(u), c.distance = h, a.spot = a.spot || {}, a.spot.innerConeAngle = a.spot.innerConeAngle !== void 0 ? a.spot.innerConeAngle : 0, a.spot.outerConeAngle = a.spot.outerConeAngle !== void 0 ? a.spot.outerConeAngle : Math.PI / 4, c.angle = a.spot.outerConeAngle, c.penumbra = 1 - a.spot.innerConeAngle / a.spot.outerConeAngle, c.target.position.set(0, 0, -1), c.add(c.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + a.type);
    }
    return c.position.set(0, 0, 0), c.decay = 2, Mt(c, a), a.intensity !== void 0 && (c.intensity = a.intensity), c.name = t.createUniqueName(a.name || "light_" + e), n = Promise.resolve(c), t.cache.add(s, n), n;
  }
  getDependency(e, t) {
    if (e === "light")
      return this._loadLight(t);
  }
  createNodeAttachment(e) {
    const t = this, s = this.parser, i = s.json.nodes[e], r = (i.extensions && i.extensions[this.name] || {}).light;
    return r === void 0 ? null : this._loadLight(r).then(function(a) {
      return s._getNodeRef(t.cache, r, a);
    });
  }
};
var xr = class {
  constructor() {
    this.name = ve.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return MeshBasicMaterial;
  }
  extendParams(e, t, s) {
    const n = [];
    e.color = new Color(1, 1, 1), e.opacity = 1;
    const i = t.pbrMetallicRoughness;
    if (i) {
      if (Array.isArray(i.baseColorFactor)) {
        const o = i.baseColorFactor;
        e.color.fromArray(o), e.opacity = o[3];
      }
      i.baseColorTexture !== void 0 && n.push(s.assignTexture(e, "map", i.baseColorTexture, 3001));
    }
    return Promise.all(n);
  }
};
var wr = class {
  constructor(e) {
    this.parser = e, this.name = ve.KHR_MATERIALS_EMISSIVE_STRENGTH;
  }
  extendMaterialParams(e, t) {
    const n = this.parser.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const i = n.extensions[this.name].emissiveStrength;
    return i !== void 0 && (t.emissiveIntensity = i), Promise.resolve();
  }
};
var br = class {
  constructor(e) {
    this.parser = e, this.name = ve.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(e) {
    const s = this.parser.json.materials[e];
    return !s.extensions || !s.extensions[this.name] ? null : MeshPhysicalMaterial;
  }
  extendMaterialParams(e, t) {
    const s = this.parser, n = s.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const i = [], o = n.extensions[this.name];
    if (o.clearcoatFactor !== void 0 && (t.clearcoat = o.clearcoatFactor), o.clearcoatTexture !== void 0 && i.push(s.assignTexture(t, "clearcoatMap", o.clearcoatTexture)), o.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = o.clearcoatRoughnessFactor), o.clearcoatRoughnessTexture !== void 0 && i.push(s.assignTexture(t, "clearcoatRoughnessMap", o.clearcoatRoughnessTexture)), o.clearcoatNormalTexture !== void 0 && (i.push(s.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)), o.clearcoatNormalTexture.scale !== void 0)) {
      const r = o.clearcoatNormalTexture.scale;
      t.clearcoatNormalScale = new Vector2(r, r);
    }
    return Promise.all(i);
  }
};
var Ar = class {
  constructor(e) {
    this.parser = e, this.name = ve.KHR_MATERIALS_IRIDESCENCE;
  }
  getMaterialType(e) {
    const s = this.parser.json.materials[e];
    return !s.extensions || !s.extensions[this.name] ? null : MeshPhysicalMaterial;
  }
  extendMaterialParams(e, t) {
    const s = this.parser, n = s.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const i = [], o = n.extensions[this.name];
    return o.iridescenceFactor !== void 0 && (t.iridescence = o.iridescenceFactor), o.iridescenceTexture !== void 0 && i.push(s.assignTexture(t, "iridescenceMap", o.iridescenceTexture)), o.iridescenceIor !== void 0 && (t.iridescenceIOR = o.iridescenceIor), t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [100, 400]), o.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum), o.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum), o.iridescenceThicknessTexture !== void 0 && i.push(
      s.assignTexture(t, "iridescenceThicknessMap", o.iridescenceThicknessTexture)
    ), Promise.all(i);
  }
};
var Mr = class {
  constructor(e) {
    this.parser = e, this.name = ve.KHR_MATERIALS_SHEEN;
  }
  getMaterialType(e) {
    const s = this.parser.json.materials[e];
    return !s.extensions || !s.extensions[this.name] ? null : MeshPhysicalMaterial;
  }
  extendMaterialParams(e, t) {
    const s = this.parser, n = s.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const i = [];
    t.sheenColor = new Color(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
    const o = n.extensions[this.name];
    return o.sheenColorFactor !== void 0 && t.sheenColor.fromArray(o.sheenColorFactor), o.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = o.sheenRoughnessFactor), o.sheenColorTexture !== void 0 && i.push(s.assignTexture(t, "sheenColorMap", o.sheenColorTexture, 3001)), o.sheenRoughnessTexture !== void 0 && i.push(s.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture)), Promise.all(i);
  }
};
var Sr = class {
  constructor(e) {
    this.parser = e, this.name = ve.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(e) {
    const s = this.parser.json.materials[e];
    return !s.extensions || !s.extensions[this.name] ? null : MeshPhysicalMaterial;
  }
  extendMaterialParams(e, t) {
    const s = this.parser, n = s.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const i = [], o = n.extensions[this.name];
    return o.transmissionFactor !== void 0 && (t.transmission = o.transmissionFactor), o.transmissionTexture !== void 0 && i.push(s.assignTexture(t, "transmissionMap", o.transmissionTexture)), Promise.all(i);
  }
};
var Pr = class {
  constructor(e) {
    this.parser = e, this.name = ve.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(e) {
    const s = this.parser.json.materials[e];
    return !s.extensions || !s.extensions[this.name] ? null : MeshPhysicalMaterial;
  }
  extendMaterialParams(e, t) {
    const s = this.parser, n = s.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const i = [], o = n.extensions[this.name];
    t.thickness = o.thicknessFactor !== void 0 ? o.thicknessFactor : 0, o.thicknessTexture !== void 0 && i.push(s.assignTexture(t, "thicknessMap", o.thicknessTexture)), t.attenuationDistance = o.attenuationDistance || 1 / 0;
    const r = o.attenuationColor || [1, 1, 1];
    return t.attenuationColor = new Color(r[0], r[1], r[2]), Promise.all(i);
  }
};
var Or = class {
  constructor(e) {
    this.parser = e, this.name = ve.KHR_MATERIALS_IOR;
  }
  getMaterialType(e) {
    const s = this.parser.json.materials[e];
    return !s.extensions || !s.extensions[this.name] ? null : MeshPhysicalMaterial;
  }
  extendMaterialParams(e, t) {
    const n = this.parser.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const i = n.extensions[this.name];
    return t.ior = i.ior !== void 0 ? i.ior : 1.5, Promise.resolve();
  }
};
var Lr = class {
  constructor(e) {
    this.parser = e, this.name = ve.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(e) {
    const s = this.parser.json.materials[e];
    return !s.extensions || !s.extensions[this.name] ? null : MeshPhysicalMaterial;
  }
  extendMaterialParams(e, t) {
    const s = this.parser, n = s.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const i = [], o = n.extensions[this.name];
    t.specularIntensity = o.specularFactor !== void 0 ? o.specularFactor : 1, o.specularTexture !== void 0 && i.push(s.assignTexture(t, "specularIntensityMap", o.specularTexture));
    const r = o.specularColorFactor || [1, 1, 1];
    return t.specularColor = new Color(r[0], r[1], r[2]), o.specularColorTexture !== void 0 && i.push(
      s.assignTexture(t, "specularColorMap", o.specularColorTexture, 3001)
      // sRGBEncoding
    ), Promise.all(i);
  }
};
var Rr = class {
  constructor(e) {
    this.parser = e, this.name = ve.KHR_MATERIALS_ANISOTROPY;
  }
  getMaterialType(e) {
    const s = this.parser.json.materials[e];
    return !s.extensions || !s.extensions[this.name] ? null : MeshPhysicalMaterial;
  }
  extendMaterialParams(e, t) {
    const s = this.parser, n = s.json.materials[e];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const i = [], o = n.extensions[this.name];
    return o.anisotropyStrength !== void 0 && (t.anisotropy = o.anisotropyStrength), o.anisotropyRotation !== void 0 && (t.anisotropyRotation = o.anisotropyRotation), o.anisotropyTexture !== void 0 && i.push(s.assignTexture(t, "anisotropyMap", o.anisotropyTexture)), Promise.all(i);
  }
};
var Cr = class {
  constructor(e) {
    this.parser = e, this.name = ve.KHR_TEXTURE_BASISU;
  }
  loadTexture(e) {
    const t = this.parser, s = t.json, n = s.textures[e];
    if (!n.extensions || !n.extensions[this.name])
      return null;
    const i = n.extensions[this.name], o = t.options.ktx2Loader;
    if (!o) {
      if (s.extensionsRequired && s.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      return null;
    }
    return t.loadTextureImage(e, i.source, o);
  }
};
var Ir = class {
  constructor(e) {
    this.parser = e, this.name = ve.EXT_TEXTURE_WEBP, this.isSupported = null;
  }
  loadTexture(e) {
    const t = this.name, s = this.parser, n = s.json, i = n.textures[e];
    if (!i.extensions || !i.extensions[t])
      return null;
    const o = i.extensions[t], r = n.images[o.source];
    let a = s.textureLoader;
    if (r.uri) {
      const c = s.options.manager.getHandler(r.uri);
      c !== null && (a = c);
    }
    return this.detectSupport().then(function(c) {
      if (c)
        return s.loadTextureImage(e, o.source, a);
      if (n.extensionsRequired && n.extensionsRequired.indexOf(t) >= 0)
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      return s.loadTexture(e);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e) {
      const t = new Image();
      t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
        e(t.height === 1);
      };
    })), this.isSupported;
  }
};
var Dr = class {
  constructor(e) {
    this.parser = e, this.name = ve.EXT_TEXTURE_AVIF, this.isSupported = null;
  }
  loadTexture(e) {
    const t = this.name, s = this.parser, n = s.json, i = n.textures[e];
    if (!i.extensions || !i.extensions[t])
      return null;
    const o = i.extensions[t], r = n.images[o.source];
    let a = s.textureLoader;
    if (r.uri) {
      const c = s.options.manager.getHandler(r.uri);
      c !== null && (a = c);
    }
    return this.detectSupport().then(function(c) {
      if (c)
        return s.loadTextureImage(e, o.source, a);
      if (n.extensionsRequired && n.extensionsRequired.indexOf(t) >= 0)
        throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
      return s.loadTexture(e);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e) {
      const t = new Image();
      t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", t.onload = t.onerror = function() {
        e(t.height === 1);
      };
    })), this.isSupported;
  }
};
var kr = class {
  constructor(e) {
    this.name = ve.EXT_MESHOPT_COMPRESSION, this.parser = e;
  }
  loadBufferView(e) {
    const t = this.parser.json, s = t.bufferViews[e];
    if (s.extensions && s.extensions[this.name]) {
      const n = s.extensions[this.name], i = this.parser.getDependency("buffer", n.buffer), o = this.parser.options.meshoptDecoder;
      if (!o || !o.supported) {
        if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        return null;
      }
      return i.then(function(r) {
        const a = n.byteOffset || 0, c = n.byteLength || 0, u = n.count, h = n.byteStride, d = new Uint8Array(r, a, c);
        return o.decodeGltfBufferAsync ? o.decodeGltfBufferAsync(u, h, d, n.mode, n.filter).then(function(f) {
          return f.buffer;
        }) : o.ready.then(function() {
          const f = new ArrayBuffer(u * h);
          return o.decodeGltfBuffer(
            new Uint8Array(f),
            u,
            h,
            d,
            n.mode,
            n.filter
          ), f;
        });
      });
    } else
      return null;
  }
};
var Fr = class {
  constructor(e) {
    this.name = ve.EXT_MESH_GPU_INSTANCING, this.parser = e;
  }
  createNodeMesh(e) {
    const t = this.parser.json, s = t.nodes[e];
    if (!s.extensions || !s.extensions[this.name] || s.mesh === void 0)
      return null;
    const n = t.meshes[s.mesh];
    for (const c of n.primitives)
      if (c.mode !== Qe.TRIANGLES && c.mode !== Qe.TRIANGLE_STRIP && c.mode !== Qe.TRIANGLE_FAN && c.mode !== void 0)
        return null;
    const o = s.extensions[this.name].attributes, r = [], a = {};
    for (const c in o)
      r.push(
        this.parser.getDependency("accessor", o[c]).then((u) => (a[c] = u, a[c]))
      );
    return r.length < 1 ? null : (r.push(this.parser.createNodeMesh(e)), Promise.all(r).then((c) => {
      const u = c.pop(), h = u.isGroup ? u.children : [u], d = c[0].count, f = [];
      for (const E of h) {
        const v = new Matrix4(), g = new Vector3(), x = new Quaternion(), M = new Vector3(1, 1, 1), y = new InstancedMesh(E.geometry, E.material, d);
        for (let m = 0; m < d; m++)
          a.TRANSLATION && g.fromBufferAttribute(a.TRANSLATION, m), a.ROTATION && x.fromBufferAttribute(a.ROTATION, m), a.SCALE && M.fromBufferAttribute(a.SCALE, m), y.setMatrixAt(m, v.compose(g, x, M));
        for (const m in a)
          m !== "TRANSLATION" && m !== "ROTATION" && m !== "SCALE" && E.geometry.setAttribute(m, a[m]);
        Object3D.prototype.copy.call(y, E), this.parser.assignFinalMaterial(y), f.push(y);
      }
      return u.isGroup ? (u.clear(), u.add(...f), u) : f[0];
    }));
  }
};
var Ui = "glTF";
var ss = 12;
var Gn = { JSON: 1313821514, BIN: 5130562 };
var Ur = class {
  constructor(e) {
    this.name = ve.KHR_BINARY_GLTF, this.content = null, this.body = null;
    const t = new DataView(e, 0, ss);
    if (this.header = {
      magic: LoaderUtils.decodeText(new Uint8Array(e.slice(0, 4))),
      version: t.getUint32(4, true),
      length: t.getUint32(8, true)
    }, this.header.magic !== Ui)
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const s = this.header.length - ss, n = new DataView(e, ss);
    let i = 0;
    for (; i < s; ) {
      const o = n.getUint32(i, true);
      i += 4;
      const r = n.getUint32(i, true);
      if (i += 4, r === Gn.JSON) {
        const a = new Uint8Array(e, ss + i, o);
        this.content = LoaderUtils.decodeText(a);
      } else if (r === Gn.BIN) {
        const a = ss + i;
        this.body = e.slice(a, a + o);
      }
      i += o;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
};
var Br = class {
  constructor(e, t) {
    if (!t)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    this.name = ve.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload();
  }
  decodePrimitive(e, t) {
    const s = this.json, n = this.dracoLoader, i = e.extensions[this.name].bufferView, o = e.extensions[this.name].attributes, r = {}, a = {}, c = {};
    for (const u in o) {
      const h = An[u] || u.toLowerCase();
      r[h] = o[u];
    }
    for (const u in e.attributes) {
      const h = An[u] || u.toLowerCase();
      if (o[u] !== void 0) {
        const d = s.accessors[e.attributes[u]], f = es[d.componentType];
        c[h] = f.name, a[h] = d.normalized === true;
      }
    }
    return t.getDependency("bufferView", i).then(function(u) {
      return new Promise(function(h) {
        n.decodeDracoFile(
          u,
          function(d) {
            for (const f in d.attributes) {
              const E = d.attributes[f], v = a[f];
              v !== void 0 && (E.normalized = v);
            }
            h(d);
          },
          r,
          c
        );
      });
    });
  }
};
var Nr = class {
  constructor() {
    this.name = ve.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e, t) {
    return (t.texCoord === void 0 || t.texCoord === e.channel) && t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(), t.texCoord !== void 0 && (e.channel = t.texCoord), t.offset !== void 0 && e.offset.fromArray(t.offset), t.rotation !== void 0 && (e.rotation = t.rotation), t.scale !== void 0 && e.repeat.fromArray(t.scale), e.needsUpdate = true), e;
  }
};
var zr = class {
  constructor() {
    this.name = ve.KHR_MESH_QUANTIZATION;
  }
};
var Bi = class extends Interpolant {
  constructor(e, t, s, n) {
    super(e, t, s, n);
  }
  copySampleValue_(e) {
    const t = this.resultBuffer, s = this.sampleValues, n = this.valueSize, i = e * n * 3 + n;
    for (let o = 0; o !== n; o++)
      t[o] = s[i + o];
    return t;
  }
  interpolate_(e, t, s, n) {
    const i = this.resultBuffer, o = this.sampleValues, r = this.valueSize, a = r * 2, c = r * 3, u = n - t, h = (s - t) / u, d = h * h, f = d * h, E = e * c, v = E - c, g = -2 * f + 3 * d, x = f - d, M = 1 - g, y = x - d + h;
    for (let m = 0; m !== r; m++) {
      const A = o[v + m + r], b = o[v + m + a] * u, _ = o[E + m + r], T = o[E + m] * u;
      i[m] = M * A + y * b + g * _ + x * T;
    }
    return i;
  }
};
var Hr = new Quaternion();
var Vr = class extends Bi {
  interpolate_(e, t, s, n) {
    const i = super.interpolate_(e, t, s, n);
    return Hr.fromArray(i).normalize().toArray(i), i;
  }
};
var Qe = {
  FLOAT: 5126,
  //FLOAT_MAT2: 35674,
  FLOAT_MAT3: 35675,
  FLOAT_MAT4: 35676,
  FLOAT_VEC2: 35664,
  FLOAT_VEC3: 35665,
  FLOAT_VEC4: 35666,
  LINEAR: 9729,
  REPEAT: 10497,
  SAMPLER_2D: 35678,
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  UNSIGNED_BYTE: 5121,
  UNSIGNED_SHORT: 5123
};
var es = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
var jn = {
  9728: NearestFilter,
  9729: LinearFilter,
  9984: NearestMipmapNearestFilter,
  9985: LinearMipmapNearestFilter,
  9986: NearestMipmapLinearFilter,
  9987: LinearMipmapLinearFilter
};
var Yn = {
  33071: ClampToEdgeWrapping,
  33648: MirroredRepeatWrapping,
  10497: RepeatWrapping
};
var Qs = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};
var An = {
  POSITION: "position",
  NORMAL: "normal",
  TANGENT: "tangent",
  // uv => uv1, 4 uv channels
  // https://github.com/mrdoob/three.js/pull/25943
  // https://github.com/mrdoob/three.js/pull/25788
  ...REVISION.replace(/\D+/g, "") >= 152 ? {
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv1",
    TEXCOORD_2: "uv2",
    TEXCOORD_3: "uv3"
  } : {
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv2"
  },
  COLOR_0: "color",
  WEIGHTS_0: "skinWeight",
  JOINTS_0: "skinIndex"
};
var Et = {
  scale: "scale",
  translation: "position",
  rotation: "quaternion",
  weights: "morphTargetInfluences"
};
var Gr = {
  CUBICSPLINE: void 0,
  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
  // keyframe track will be initialized with a default interpolation type, then modified.
  LINEAR: InterpolateLinear,
  STEP: InterpolateDiscrete
};
var qs = {
  OPAQUE: "OPAQUE",
  MASK: "MASK",
  BLEND: "BLEND"
};
function jr(l) {
  return l.DefaultMaterial === void 0 && (l.DefaultMaterial = new MeshStandardMaterial({
    color: 16777215,
    emissive: 0,
    metalness: 1,
    roughness: 1,
    transparent: false,
    depthTest: true,
    side: FrontSide
  })), l.DefaultMaterial;
}
function kt(l, e, t) {
  for (const s in t.extensions)
    l[s] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[s] = t.extensions[s]);
}
function Mt(l, e) {
  e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(l.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras));
}
function Yr(l, e, t) {
  let s = false, n = false, i = false;
  for (let c = 0, u = e.length; c < u; c++) {
    const h = e[c];
    if (h.POSITION !== void 0 && (s = true), h.NORMAL !== void 0 && (n = true), h.COLOR_0 !== void 0 && (i = true), s && n && i)
      break;
  }
  if (!s && !n && !i)
    return Promise.resolve(l);
  const o = [], r = [], a = [];
  for (let c = 0, u = e.length; c < u; c++) {
    const h = e[c];
    if (s) {
      const d = h.POSITION !== void 0 ? t.getDependency("accessor", h.POSITION) : l.attributes.position;
      o.push(d);
    }
    if (n) {
      const d = h.NORMAL !== void 0 ? t.getDependency("accessor", h.NORMAL) : l.attributes.normal;
      r.push(d);
    }
    if (i) {
      const d = h.COLOR_0 !== void 0 ? t.getDependency("accessor", h.COLOR_0) : l.attributes.color;
      a.push(d);
    }
  }
  return Promise.all([
    Promise.all(o),
    Promise.all(r),
    Promise.all(a)
  ]).then(function(c) {
    const u = c[0], h = c[1], d = c[2];
    return s && (l.morphAttributes.position = u), n && (l.morphAttributes.normal = h), i && (l.morphAttributes.color = d), l.morphTargetsRelative = true, l;
  });
}
function Xr(l, e) {
  if (l.updateMorphTargets(), e.weights !== void 0)
    for (let t = 0, s = e.weights.length; t < s; t++)
      l.morphTargetInfluences[t] = e.weights[t];
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    const t = e.extras.targetNames;
    if (l.morphTargetInfluences.length === t.length) {
      l.morphTargetDictionary = {};
      for (let s = 0, n = t.length; s < n; s++)
        l.morphTargetDictionary[t[s]] = s;
    } else
      console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
  }
}
function Zr(l) {
  let e;
  const t = l.extensions && l.extensions[ve.KHR_DRACO_MESH_COMPRESSION];
  if (t ? e = "draco:" + t.bufferView + ":" + t.indices + ":" + Js(t.attributes) : e = l.indices + ":" + Js(l.attributes) + ":" + l.mode, l.targets !== void 0)
    for (let s = 0, n = l.targets.length; s < n; s++)
      e += ":" + Js(l.targets[s]);
  return e;
}
function Js(l) {
  let e = "";
  const t = Object.keys(l).sort();
  for (let s = 0, n = t.length; s < n; s++)
    e += t[s] + ":" + l[t[s]] + ";";
  return e;
}
function Mn(l) {
  switch (l) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
function $r(l) {
  return l.search(/\.jpe?g($|\?)/i) > 0 || l.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : l.search(/\.webp($|\?)/i) > 0 || l.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png";
}
var Kr = new Matrix4();
var Wr = class {
  constructor(e = {}, t = {}) {
    this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new Tr(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
    let s = false, n = false, i = -1;
    typeof navigator < "u" && typeof navigator.userAgent < "u" && (s = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === true, n = navigator.userAgent.indexOf("Firefox") > -1, i = n ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), typeof createImageBitmap > "u" || s || n && i < 98 ? this.textureLoader = new TextureLoader(this.options.manager) : this.textureLoader = new ImageBitmapLoader(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new FileLoader(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(true);
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, t) {
    const s = this, n = this.json, i = this.extensions;
    this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function(o) {
      return o._markDefs && o._markDefs();
    }), Promise.all(
      this._invokeAll(function(o) {
        return o.beforeRoot && o.beforeRoot();
      })
    ).then(function() {
      return Promise.all([
        s.getDependencies("scene"),
        s.getDependencies("animation"),
        s.getDependencies("camera")
      ]);
    }).then(function(o) {
      const r = {
        scene: o[0][n.scene || 0],
        scenes: o[0],
        animations: o[1],
        cameras: o[2],
        asset: n.asset,
        parser: s,
        userData: {}
      };
      kt(i, r, n), Mt(r, n), Promise.all(
        s._invokeAll(function(a) {
          return a.afterRoot && a.afterRoot(r);
        })
      ).then(function() {
        e(r);
      });
    }).catch(t);
  }
  /**
   * Marks the special nodes/meshes in json for efficient parse.
   */
  _markDefs() {
    const e = this.json.nodes || [], t = this.json.skins || [], s = this.json.meshes || [];
    for (let n = 0, i = t.length; n < i; n++) {
      const o = t[n].joints;
      for (let r = 0, a = o.length; r < a; r++)
        e[o[r]].isBone = true;
    }
    for (let n = 0, i = e.length; n < i; n++) {
      const o = e[n];
      o.mesh !== void 0 && (this._addNodeRef(this.meshCache, o.mesh), o.skin !== void 0 && (s[o.mesh].isSkinnedMesh = true)), o.camera !== void 0 && this._addNodeRef(this.cameraCache, o.camera);
    }
  }
  /**
   * Counts references to shared node / Object3D resources. These resources
   * can be reused, or "instantiated", at multiple nodes in the scene
   * hierarchy. Mesh, Camera, and Light instances are instantiated and must
   * be marked. Non-scenegraph resources (like Materials, Geometries, and
   * Textures) can be reused directly and are not marked here.
   *
   * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
   */
  _addNodeRef(e, t) {
    t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
  }
  /** Returns a reference to a shared resource, cloning it if necessary. */
  _getNodeRef(e, t, s) {
    if (e.refs[t] <= 1)
      return s;
    const n = s.clone(), i = (o, r) => {
      const a = this.associations.get(o);
      a != null && this.associations.set(r, a);
      for (const [c, u] of o.children.entries())
        i(u, r.children[c]);
    };
    return i(s, n), n.name += "_instance_" + e.uses[t]++, n;
  }
  _invokeOne(e) {
    const t = Object.values(this.plugins);
    t.push(this);
    for (let s = 0; s < t.length; s++) {
      const n = e(t[s]);
      if (n)
        return n;
    }
    return null;
  }
  _invokeAll(e) {
    const t = Object.values(this.plugins);
    t.unshift(this);
    const s = [];
    for (let n = 0; n < t.length; n++) {
      const i = e(t[n]);
      i && s.push(i);
    }
    return s;
  }
  /**
   * Requests the specified dependency asynchronously, with caching.
   * @param {string} type
   * @param {number} index
   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
   */
  getDependency(e, t) {
    const s = e + ":" + t;
    let n = this.cache.get(s);
    if (!n) {
      switch (e) {
        case "scene":
          n = this.loadScene(t);
          break;
        case "node":
          n = this._invokeOne(function(i) {
            return i.loadNode && i.loadNode(t);
          });
          break;
        case "mesh":
          n = this._invokeOne(function(i) {
            return i.loadMesh && i.loadMesh(t);
          });
          break;
        case "accessor":
          n = this.loadAccessor(t);
          break;
        case "bufferView":
          n = this._invokeOne(function(i) {
            return i.loadBufferView && i.loadBufferView(t);
          });
          break;
        case "buffer":
          n = this.loadBuffer(t);
          break;
        case "material":
          n = this._invokeOne(function(i) {
            return i.loadMaterial && i.loadMaterial(t);
          });
          break;
        case "texture":
          n = this._invokeOne(function(i) {
            return i.loadTexture && i.loadTexture(t);
          });
          break;
        case "skin":
          n = this.loadSkin(t);
          break;
        case "animation":
          n = this._invokeOne(function(i) {
            return i.loadAnimation && i.loadAnimation(t);
          });
          break;
        case "camera":
          n = this.loadCamera(t);
          break;
        default:
          if (n = this._invokeOne(function(i) {
            return i != this && i.getDependency && i.getDependency(e, t);
          }), !n)
            throw new Error("Unknown type: " + e);
          break;
      }
      this.cache.add(s, n);
    }
    return n;
  }
  /**
   * Requests all dependencies of the specified type asynchronously, with caching.
   * @param {string} type
   * @return {Promise<Array<Object>>}
   */
  getDependencies(e) {
    let t = this.cache.get(e);
    if (!t) {
      const s = this, n = this.json[e + (e === "mesh" ? "es" : "s")] || [];
      t = Promise.all(
        n.map(function(i, o) {
          return s.getDependency(e, o);
        })
      ), this.cache.add(e, t);
    }
    return t;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBuffer(e) {
    const t = this.json.buffers[e], s = this.fileLoader;
    if (t.type && t.type !== "arraybuffer")
      throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
    if (t.uri === void 0 && e === 0)
      return Promise.resolve(this.extensions[ve.KHR_BINARY_GLTF].body);
    const n = this.options;
    return new Promise(function(i, o) {
      s.load(LoaderUtils.resolveURL(t.uri, n.path), i, void 0, function() {
        o(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'));
      });
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferViewIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBufferView(e) {
    const t = this.json.bufferViews[e];
    return this.getDependency("buffer", t.buffer).then(function(s) {
      const n = t.byteLength || 0, i = t.byteOffset || 0;
      return s.slice(i, i + n);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
   * @param {number} accessorIndex
   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
   */
  loadAccessor(e) {
    const t = this, s = this.json, n = this.json.accessors[e];
    if (n.bufferView === void 0 && n.sparse === void 0) {
      const o = Qs[n.type], r = es[n.componentType], a = n.normalized === true, c = new r(n.count * o);
      return Promise.resolve(new BufferAttribute(c, o, a));
    }
    const i = [];
    return n.bufferView !== void 0 ? i.push(this.getDependency("bufferView", n.bufferView)) : i.push(null), n.sparse !== void 0 && (i.push(this.getDependency("bufferView", n.sparse.indices.bufferView)), i.push(this.getDependency("bufferView", n.sparse.values.bufferView))), Promise.all(i).then(function(o) {
      const r = o[0], a = Qs[n.type], c = es[n.componentType], u = c.BYTES_PER_ELEMENT, h = u * a, d = n.byteOffset || 0, f = n.bufferView !== void 0 ? s.bufferViews[n.bufferView].byteStride : void 0, E = n.normalized === true;
      let v, g;
      if (f && f !== h) {
        const x = Math.floor(d / f), M = "InterleavedBuffer:" + n.bufferView + ":" + n.componentType + ":" + x + ":" + n.count;
        let y = t.cache.get(M);
        y || (v = new c(r, x * f, n.count * f / u), y = new InterleavedBuffer(v, f / u), t.cache.add(M, y)), g = new InterleavedBufferAttribute(
          y,
          a,
          d % f / u,
          E
        );
      } else
        r === null ? v = new c(n.count * a) : v = new c(r, d, n.count * a), g = new BufferAttribute(v, a, E);
      if (n.sparse !== void 0) {
        const x = Qs.SCALAR, M = es[n.sparse.indices.componentType], y = n.sparse.indices.byteOffset || 0, m = n.sparse.values.byteOffset || 0, A = new M(
          o[1],
          y,
          n.sparse.count * x
        ), b = new c(o[2], m, n.sparse.count * a);
        r !== null && (g = new BufferAttribute(
          g.array.slice(),
          g.itemSize,
          g.normalized
        ));
        for (let _ = 0, T = A.length; _ < T; _++) {
          const L2 = A[_];
          if (g.setX(L2, b[_ * a]), a >= 2 && g.setY(L2, b[_ * a + 1]), a >= 3 && g.setZ(L2, b[_ * a + 2]), a >= 4 && g.setW(L2, b[_ * a + 3]), a >= 5)
            throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
      }
      return g;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
   * @param {number} textureIndex
   * @return {Promise<THREE.Texture|null>}
   */
  loadTexture(e) {
    const t = this.json, s = this.options, i = t.textures[e].source, o = t.images[i];
    let r = this.textureLoader;
    if (o.uri) {
      const a = s.manager.getHandler(o.uri);
      a !== null && (r = a);
    }
    return this.loadTextureImage(e, i, r);
  }
  loadTextureImage(e, t, s) {
    const n = this, i = this.json, o = i.textures[e], r = i.images[t], a = (r.uri || r.bufferView) + ":" + o.sampler;
    if (this.textureCache[a])
      return this.textureCache[a];
    const c = this.loadImageSource(t, s).then(function(u) {
      u.flipY = false, u.name = o.name || r.name || "", u.name === "" && typeof r.uri == "string" && r.uri.startsWith("data:image/") === false && (u.name = r.uri);
      const d = (i.samplers || {})[o.sampler] || {};
      return u.magFilter = jn[d.magFilter] || LinearFilter, u.minFilter = jn[d.minFilter] || LinearMipmapLinearFilter, u.wrapS = Yn[d.wrapS] || RepeatWrapping, u.wrapT = Yn[d.wrapT] || RepeatWrapping, n.associations.set(u, { textures: e }), u;
    }).catch(function() {
      return null;
    });
    return this.textureCache[a] = c, c;
  }
  loadImageSource(e, t) {
    const s = this, n = this.json, i = this.options;
    if (this.sourceCache[e] !== void 0)
      return this.sourceCache[e].then((h) => h.clone());
    const o = n.images[e], r = self.URL || self.webkitURL;
    let a = o.uri || "", c = false;
    if (o.bufferView !== void 0)
      a = s.getDependency("bufferView", o.bufferView).then(function(h) {
        c = true;
        const d = new Blob([h], { type: o.mimeType });
        return a = r.createObjectURL(d), a;
      });
    else if (o.uri === void 0)
      throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
    const u = Promise.resolve(a).then(function(h) {
      return new Promise(function(d, f) {
        let E = d;
        t.isImageBitmapLoader === true && (E = function(v) {
          const g = new Texture(v);
          g.needsUpdate = true, d(g);
        }), t.load(LoaderUtils.resolveURL(h, i.path), E, void 0, f);
      });
    }).then(function(h) {
      return c === true && r.revokeObjectURL(a), h.userData.mimeType = o.mimeType || $r(o.uri), h;
    }).catch(function(h) {
      throw console.error("THREE.GLTFLoader: Couldn't load texture", a), h;
    });
    return this.sourceCache[e] = u, u;
  }
  /**
   * Asynchronously assigns a texture to the given material parameters.
   * @param {Object} materialParams
   * @param {string} mapName
   * @param {Object} mapDef
   * @return {Promise<Texture>}
   */
  assignTexture(e, t, s, n) {
    const i = this;
    return this.getDependency("texture", s.index).then(function(o) {
      if (!o)
        return null;
      if (s.texCoord !== void 0 && s.texCoord > 0 && (o = o.clone(), o.channel = s.texCoord), i.extensions[ve.KHR_TEXTURE_TRANSFORM]) {
        const r = s.extensions !== void 0 ? s.extensions[ve.KHR_TEXTURE_TRANSFORM] : void 0;
        if (r) {
          const a = i.associations.get(o);
          o = i.extensions[ve.KHR_TEXTURE_TRANSFORM].extendTexture(o, r), i.associations.set(o, a);
        }
      }
      return n !== void 0 && ("colorSpace" in o ? o.colorSpace = n === 3001 ? "srgb" : "srgb-linear" : o.encoding = n), e[t] = o, o;
    });
  }
  /**
   * Assigns final material to a Mesh, Line, or Points instance. The instance
   * already has a material (generated from the glTF material options alone)
   * but reuse of the same glTF material may require multiple threejs materials
   * to accommodate different primitive types, defines, etc. New materials will
   * be created if necessary, and reused from a cache.
   * @param  {Object3D} mesh Mesh, Line, or Points instance.
   */
  assignFinalMaterial(e) {
    const t = e.geometry;
    let s = e.material;
    const n = t.attributes.tangent === void 0, i = t.attributes.color !== void 0, o = t.attributes.normal === void 0;
    if (e.isPoints) {
      const r = "PointsMaterial:" + s.uuid;
      let a = this.cache.get(r);
      a || (a = new PointsMaterial(), Material.prototype.copy.call(a, s), a.color.copy(s.color), a.map = s.map, a.sizeAttenuation = false, this.cache.add(r, a)), s = a;
    } else if (e.isLine) {
      const r = "LineBasicMaterial:" + s.uuid;
      let a = this.cache.get(r);
      a || (a = new LineBasicMaterial(), Material.prototype.copy.call(a, s), a.color.copy(s.color), a.map = s.map, this.cache.add(r, a)), s = a;
    }
    if (n || i || o) {
      let r = "ClonedMaterial:" + s.uuid + ":";
      n && (r += "derivative-tangents:"), i && (r += "vertex-colors:"), o && (r += "flat-shading:");
      let a = this.cache.get(r);
      a || (a = s.clone(), i && (a.vertexColors = true), o && (a.flatShading = true), n && (a.normalScale && (a.normalScale.y *= -1), a.clearcoatNormalScale && (a.clearcoatNormalScale.y *= -1)), this.cache.add(r, a), this.associations.set(a, this.associations.get(s))), s = a;
    }
    e.material = s;
  }
  getMaterialType() {
    return MeshStandardMaterial;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
   * @param {number} materialIndex
   * @return {Promise<Material>}
   */
  loadMaterial(e) {
    const t = this, s = this.json, n = this.extensions, i = s.materials[e];
    let o;
    const r = {}, a = i.extensions || {}, c = [];
    if (a[ve.KHR_MATERIALS_UNLIT]) {
      const h = n[ve.KHR_MATERIALS_UNLIT];
      o = h.getMaterialType(), c.push(h.extendParams(r, i, t));
    } else {
      const h = i.pbrMetallicRoughness || {};
      if (r.color = new Color(1, 1, 1), r.opacity = 1, Array.isArray(h.baseColorFactor)) {
        const d = h.baseColorFactor;
        r.color.fromArray(d), r.opacity = d[3];
      }
      h.baseColorTexture !== void 0 && c.push(t.assignTexture(r, "map", h.baseColorTexture, 3001)), r.metalness = h.metallicFactor !== void 0 ? h.metallicFactor : 1, r.roughness = h.roughnessFactor !== void 0 ? h.roughnessFactor : 1, h.metallicRoughnessTexture !== void 0 && (c.push(t.assignTexture(r, "metalnessMap", h.metallicRoughnessTexture)), c.push(t.assignTexture(r, "roughnessMap", h.metallicRoughnessTexture))), o = this._invokeOne(function(d) {
        return d.getMaterialType && d.getMaterialType(e);
      }), c.push(
        Promise.all(
          this._invokeAll(function(d) {
            return d.extendMaterialParams && d.extendMaterialParams(e, r);
          })
        )
      );
    }
    i.doubleSided === true && (r.side = DoubleSide);
    const u = i.alphaMode || qs.OPAQUE;
    if (u === qs.BLEND ? (r.transparent = true, r.depthWrite = false) : (r.transparent = false, u === qs.MASK && (r.alphaTest = i.alphaCutoff !== void 0 ? i.alphaCutoff : 0.5)), i.normalTexture !== void 0 && o !== MeshBasicMaterial && (c.push(t.assignTexture(r, "normalMap", i.normalTexture)), r.normalScale = new Vector2(1, 1), i.normalTexture.scale !== void 0)) {
      const h = i.normalTexture.scale;
      r.normalScale.set(h, h);
    }
    return i.occlusionTexture !== void 0 && o !== MeshBasicMaterial && (c.push(t.assignTexture(r, "aoMap", i.occlusionTexture)), i.occlusionTexture.strength !== void 0 && (r.aoMapIntensity = i.occlusionTexture.strength)), i.emissiveFactor !== void 0 && o !== MeshBasicMaterial && (r.emissive = new Color().fromArray(i.emissiveFactor)), i.emissiveTexture !== void 0 && o !== MeshBasicMaterial && c.push(t.assignTexture(r, "emissiveMap", i.emissiveTexture, 3001)), Promise.all(c).then(function() {
      const h = new o(r);
      return i.name && (h.name = i.name), Mt(h, i), t.associations.set(h, { materials: e }), i.extensions && kt(n, h, i), h;
    });
  }
  /** When Object3D instances are targeted by animation, they need unique names. */
  createUniqueName(e) {
    const t = PropertyBinding.sanitizeNodeName(e || "");
    return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
   *
   * Creates BufferGeometries from primitives.
   *
   * @param {Array<GLTF.Primitive>} primitives
   * @return {Promise<Array<BufferGeometry>>}
   */
  loadGeometries(e) {
    const t = this, s = this.extensions, n = this.primitiveCache;
    function i(r) {
      return s[ve.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(r, t).then(function(a) {
        return Xn(a, r, t);
      });
    }
    const o = [];
    for (let r = 0, a = e.length; r < a; r++) {
      const c = e[r], u = Zr(c), h = n[u];
      if (h)
        o.push(h.promise);
      else {
        let d;
        c.extensions && c.extensions[ve.KHR_DRACO_MESH_COMPRESSION] ? d = i(c) : d = Xn(new BufferGeometry(), c, t), n[u] = { primitive: c, promise: d }, o.push(d);
      }
    }
    return Promise.all(o);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
   * @param {number} meshIndex
   * @return {Promise<Group|Mesh|SkinnedMesh>}
   */
  loadMesh(e) {
    const t = this, s = this.json, n = this.extensions, i = s.meshes[e], o = i.primitives, r = [];
    for (let a = 0, c = o.length; a < c; a++) {
      const u = o[a].material === void 0 ? jr(this.cache) : this.getDependency("material", o[a].material);
      r.push(u);
    }
    return r.push(t.loadGeometries(o)), Promise.all(r).then(function(a) {
      const c = a.slice(0, a.length - 1), u = a[a.length - 1], h = [];
      for (let f = 0, E = u.length; f < E; f++) {
        const v = u[f], g = o[f];
        let x;
        const M = c[f];
        if (g.mode === Qe.TRIANGLES || g.mode === Qe.TRIANGLE_STRIP || g.mode === Qe.TRIANGLE_FAN || g.mode === void 0)
          x = i.isSkinnedMesh === true ? new SkinnedMesh(v, M) : new Mesh(v, M), x.isSkinnedMesh === true && x.normalizeSkinWeights(), g.mode === Qe.TRIANGLE_STRIP ? x.geometry = zn(x.geometry, TriangleStripDrawMode) : g.mode === Qe.TRIANGLE_FAN && (x.geometry = zn(x.geometry, TriangleFanDrawMode));
        else if (g.mode === Qe.LINES)
          x = new LineSegments(v, M);
        else if (g.mode === Qe.LINE_STRIP)
          x = new Line(v, M);
        else if (g.mode === Qe.LINE_LOOP)
          x = new LineLoop(v, M);
        else if (g.mode === Qe.POINTS)
          x = new Points(v, M);
        else
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + g.mode);
        Object.keys(x.geometry.morphAttributes).length > 0 && Xr(x, i), x.name = t.createUniqueName(i.name || "mesh_" + e), Mt(x, i), g.extensions && kt(n, x, g), t.assignFinalMaterial(x), h.push(x);
      }
      for (let f = 0, E = h.length; f < E; f++)
        t.associations.set(h[f], {
          meshes: e,
          primitives: f
        });
      if (h.length === 1)
        return i.extensions && kt(n, h[0], i), h[0];
      const d = new Group();
      i.extensions && kt(n, d, i), t.associations.set(d, { meshes: e });
      for (let f = 0, E = h.length; f < E; f++)
        d.add(h[f]);
      return d;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
   * @param {number} cameraIndex
   * @return {Promise<THREE.Camera>}
   */
  loadCamera(e) {
    let t;
    const s = this.json.cameras[e], n = s[s.type];
    if (!n) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return s.type === "perspective" ? t = new PerspectiveCamera(
      MathUtils.radToDeg(n.yfov),
      n.aspectRatio || 1,
      n.znear || 1,
      n.zfar || 2e6
    ) : s.type === "orthographic" && (t = new OrthographicCamera(-n.xmag, n.xmag, n.ymag, -n.ymag, n.znear, n.zfar)), s.name && (t.name = this.createUniqueName(s.name)), Mt(t, s), Promise.resolve(t);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
   * @param {number} skinIndex
   * @return {Promise<Skeleton>}
   */
  loadSkin(e) {
    const t = this.json.skins[e], s = [];
    for (let n = 0, i = t.joints.length; n < i; n++)
      s.push(this._loadNodeShallow(t.joints[n]));
    return t.inverseBindMatrices !== void 0 ? s.push(this.getDependency("accessor", t.inverseBindMatrices)) : s.push(null), Promise.all(s).then(function(n) {
      const i = n.pop(), o = n, r = [], a = [];
      for (let c = 0, u = o.length; c < u; c++) {
        const h = o[c];
        if (h) {
          r.push(h);
          const d = new Matrix4();
          i !== null && d.fromArray(i.array, c * 16), a.push(d);
        } else
          console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[c]);
      }
      return new Skeleton(r, a);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
   * @param {number} animationIndex
   * @return {Promise<AnimationClip>}
   */
  loadAnimation(e) {
    const s = this.json.animations[e], n = s.name ? s.name : "animation_" + e, i = [], o = [], r = [], a = [], c = [];
    for (let u = 0, h = s.channels.length; u < h; u++) {
      const d = s.channels[u], f = s.samplers[d.sampler], E = d.target, v = E.node, g = s.parameters !== void 0 ? s.parameters[f.input] : f.input, x = s.parameters !== void 0 ? s.parameters[f.output] : f.output;
      E.node !== void 0 && (i.push(this.getDependency("node", v)), o.push(this.getDependency("accessor", g)), r.push(this.getDependency("accessor", x)), a.push(f), c.push(E));
    }
    return Promise.all([
      Promise.all(i),
      Promise.all(o),
      Promise.all(r),
      Promise.all(a),
      Promise.all(c)
    ]).then(function(u) {
      const h = u[0], d = u[1], f = u[2], E = u[3], v = u[4], g = [];
      for (let x = 0, M = h.length; x < M; x++) {
        const y = h[x], m = d[x], A = f[x], b = E[x], _ = v[x];
        if (y === void 0)
          continue;
        y.updateMatrix();
        let T;
        switch (Et[_.path]) {
          case Et.weights:
            T = NumberKeyframeTrack;
            break;
          case Et.rotation:
            T = QuaternionKeyframeTrack;
            break;
          case Et.position:
          case Et.scale:
          default:
            T = VectorKeyframeTrack;
            break;
        }
        const L2 = y.name ? y.name : y.uuid, B = b.interpolation !== void 0 ? Gr[b.interpolation] : InterpolateLinear, k = [];
        Et[_.path] === Et.weights ? y.traverse(function($) {
          $.morphTargetInfluences && k.push($.name ? $.name : $.uuid);
        }) : k.push(L2);
        let N = A.array;
        if (A.normalized) {
          const $ = Mn(N.constructor), Q = new Float32Array(N.length);
          for (let Z = 0, me = N.length; Z < me; Z++)
            Q[Z] = N[Z] * $;
          N = Q;
        }
        for (let $ = 0, Q = k.length; $ < Q; $++) {
          const Z = new T(
            k[$] + "." + Et[_.path],
            m.array,
            N,
            B
          );
          b.interpolation === "CUBICSPLINE" && (Z.createInterpolant = function(X) {
            const z = this instanceof QuaternionKeyframeTrack ? Vr : Bi;
            return new z(this.times, this.values, this.getValueSize() / 3, X);
          }, Z.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true), g.push(Z);
        }
      }
      return new AnimationClip(n, void 0, g);
    });
  }
  createNodeMesh(e) {
    const t = this.json, s = this, n = t.nodes[e];
    return n.mesh === void 0 ? null : s.getDependency("mesh", n.mesh).then(function(i) {
      const o = s._getNodeRef(s.meshCache, n.mesh, i);
      return n.weights !== void 0 && o.traverse(function(r) {
        if (r.isMesh)
          for (let a = 0, c = n.weights.length; a < c; a++)
            r.morphTargetInfluences[a] = n.weights[a];
      }), o;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
   * @param {number} nodeIndex
   * @return {Promise<Object3D>}
   */
  loadNode(e) {
    const t = this.json, s = this, n = t.nodes[e], i = s._loadNodeShallow(e), o = [], r = n.children || [];
    for (let c = 0, u = r.length; c < u; c++)
      o.push(s.getDependency("node", r[c]));
    const a = n.skin === void 0 ? Promise.resolve(null) : s.getDependency("skin", n.skin);
    return Promise.all([i, Promise.all(o), a]).then(function(c) {
      const u = c[0], h = c[1], d = c[2];
      d !== null && u.traverse(function(f) {
        f.isSkinnedMesh && f.bind(d, Kr);
      });
      for (let f = 0, E = h.length; f < E; f++)
        u.add(h[f]);
      return u;
    });
  }
  // ._loadNodeShallow() parses a single node.
  // skin and child nodes are created and added in .loadNode() (no '_' prefix).
  _loadNodeShallow(e) {
    const t = this.json, s = this.extensions, n = this;
    if (this.nodeCache[e] !== void 0)
      return this.nodeCache[e];
    const i = t.nodes[e], o = i.name ? n.createUniqueName(i.name) : "", r = [], a = n._invokeOne(function(c) {
      return c.createNodeMesh && c.createNodeMesh(e);
    });
    return a && r.push(a), i.camera !== void 0 && r.push(
      n.getDependency("camera", i.camera).then(function(c) {
        return n._getNodeRef(n.cameraCache, i.camera, c);
      })
    ), n._invokeAll(function(c) {
      return c.createNodeAttachment && c.createNodeAttachment(e);
    }).forEach(function(c) {
      r.push(c);
    }), this.nodeCache[e] = Promise.all(r).then(function(c) {
      let u;
      if (i.isBone === true ? u = new Bone() : c.length > 1 ? u = new Group() : c.length === 1 ? u = c[0] : u = new Object3D(), u !== c[0])
        for (let h = 0, d = c.length; h < d; h++)
          u.add(c[h]);
      if (i.name && (u.userData.name = i.name, u.name = o), Mt(u, i), i.extensions && kt(s, u, i), i.matrix !== void 0) {
        const h = new Matrix4();
        h.fromArray(i.matrix), u.applyMatrix4(h);
      } else
        i.translation !== void 0 && u.position.fromArray(i.translation), i.rotation !== void 0 && u.quaternion.fromArray(i.rotation), i.scale !== void 0 && u.scale.fromArray(i.scale);
      return n.associations.has(u) || n.associations.set(u, {}), n.associations.get(u).nodes = e, u;
    }), this.nodeCache[e];
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
   * @param {number} sceneIndex
   * @return {Promise<Group>}
   */
  loadScene(e) {
    const t = this.extensions, s = this.json.scenes[e], n = this, i = new Group();
    s.name && (i.name = n.createUniqueName(s.name)), Mt(i, s), s.extensions && kt(t, i, s);
    const o = s.nodes || [], r = [];
    for (let a = 0, c = o.length; a < c; a++)
      r.push(n.getDependency("node", o[a]));
    return Promise.all(r).then(function(a) {
      for (let u = 0, h = a.length; u < h; u++)
        i.add(a[u]);
      const c = (u) => {
        const h = /* @__PURE__ */ new Map();
        for (const [d, f] of n.associations)
          (d instanceof Material || d instanceof Texture) && h.set(d, f);
        return u.traverse((d) => {
          const f = n.associations.get(d);
          f != null && h.set(d, f);
        }), h;
      };
      return n.associations = c(i), i;
    });
  }
};
function Qr(l, e, t) {
  const s = e.attributes, n = new Box3();
  if (s.POSITION !== void 0) {
    const r = t.json.accessors[s.POSITION], a = r.min, c = r.max;
    if (a !== void 0 && c !== void 0) {
      if (n.set(new Vector3(a[0], a[1], a[2]), new Vector3(c[0], c[1], c[2])), r.normalized) {
        const u = Mn(es[r.componentType]);
        n.min.multiplyScalar(u), n.max.multiplyScalar(u);
      }
    } else {
      console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      return;
    }
  } else
    return;
  const i = e.targets;
  if (i !== void 0) {
    const r = new Vector3(), a = new Vector3();
    for (let c = 0, u = i.length; c < u; c++) {
      const h = i[c];
      if (h.POSITION !== void 0) {
        const d = t.json.accessors[h.POSITION], f = d.min, E = d.max;
        if (f !== void 0 && E !== void 0) {
          if (a.setX(Math.max(Math.abs(f[0]), Math.abs(E[0]))), a.setY(Math.max(Math.abs(f[1]), Math.abs(E[1]))), a.setZ(Math.max(Math.abs(f[2]), Math.abs(E[2]))), d.normalized) {
            const v = Mn(es[d.componentType]);
            a.multiplyScalar(v);
          }
          r.max(a);
        } else
          console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      }
    }
    n.expandByVector(r);
  }
  l.boundingBox = n;
  const o = new Sphere();
  n.getCenter(o.center), o.radius = n.min.distanceTo(n.max) / 2, l.boundingSphere = o;
}
function Xn(l, e, t) {
  const s = e.attributes, n = [];
  function i(o, r) {
    return t.getDependency("accessor", o).then(function(a) {
      l.setAttribute(r, a);
    });
  }
  for (const o in s) {
    const r = An[o] || o.toLowerCase();
    r in l.attributes || n.push(i(s[o], r));
  }
  if (e.indices !== void 0 && !l.index) {
    const o = t.getDependency("accessor", e.indices).then(function(r) {
      l.setIndex(r);
    });
    n.push(o);
  }
  return Mt(l, e), Qr(l, e, t), Promise.all(n).then(function() {
    return e.targets !== void 0 ? Yr(l, e.targets, t) : l;
  });
}
var Zn = class extends ExtrudeGeometry {
  constructor(e, t = {}) {
    const {
      bevelEnabled: s = false,
      bevelSize: n = 8,
      bevelThickness: i = 10,
      font: o,
      height: r = 50,
      size: a = 100,
      lineHeight: c = 1,
      letterSpacing: u = 0,
      ...h
    } = t;
    if (o === void 0)
      super();
    else {
      const d = o.generateShapes(e, a, { lineHeight: c, letterSpacing: u });
      super(d, { ...h, bevelEnabled: s, bevelSize: n, bevelThickness: i, depth: r });
    }
    this.type = "TextGeometry";
  }
};
var qr = {
  uniforms: {
    tDiffuse: { value: null },
    h: { value: 1 / 512 }
  },
  vertexShader: (
    /* glsl */
    `
      varying vec2 vUv;

      void main() {

        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

      }
  `
  ),
  fragmentShader: (
    /* glsl */
    `
    uniform sampler2D tDiffuse;
    uniform float h;

    varying vec2 vUv;

    void main() {

    	vec4 sum = vec4( 0.0 );

    	sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;
    	sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;
    	sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;
    	sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;
    	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;

    	gl_FragColor = sum;

    }
  `
  )
};
var Jr = {
  uniforms: {
    tDiffuse: { value: null },
    v: { value: 1 / 512 }
  },
  vertexShader: (
    /* glsl */
    `
    varying vec2 vUv;

    void main() {

      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

    }
  `
  ),
  fragmentShader: (
    /* glsl */
    `

  uniform sampler2D tDiffuse;
  uniform float v;

  varying vec2 vUv;

  void main() {

    vec4 sum = vec4( 0.0 );

    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;

    gl_FragColor = sum;

  }
  `
  )
};
function Ni(l, e, t) {
  const s = t.length - l - 1;
  if (e >= t[s])
    return s - 1;
  if (e <= t[l])
    return l;
  let n = l, i = s, o = Math.floor((n + i) / 2);
  for (; e < t[o] || e >= t[o + 1]; )
    e < t[o] ? i = o : n = o, o = Math.floor((n + i) / 2);
  return o;
}
function ea(l, e, t, s) {
  const n = [], i = [], o = [];
  n[0] = 1;
  for (let r = 1; r <= t; ++r) {
    i[r] = e - s[l + 1 - r], o[r] = s[l + r] - e;
    let a = 0;
    for (let c = 0; c < r; ++c) {
      const u = o[c + 1], h = i[r - c], d = n[c] / (u + h);
      n[c] = a + u * d, a = h * d;
    }
    n[r] = a;
  }
  return n;
}
function ta(l, e, t, s) {
  const n = Ni(l, s, e), i = ea(n, s, l, e), o = new Vector4(0, 0, 0, 0);
  for (let r = 0; r <= l; ++r) {
    const a = t[n - l + r], c = i[r], u = a.w * c;
    o.x += a.x * u, o.y += a.y * u, o.z += a.z * u, o.w += a.w * c;
  }
  return o;
}
function sa(l, e, t, s, n) {
  const i = [];
  for (let h = 0; h <= t; ++h)
    i[h] = 0;
  const o = [];
  for (let h = 0; h <= s; ++h)
    o[h] = i.slice(0);
  const r = [];
  for (let h = 0; h <= t; ++h)
    r[h] = i.slice(0);
  r[0][0] = 1;
  const a = i.slice(0), c = i.slice(0);
  for (let h = 1; h <= t; ++h) {
    a[h] = e - n[l + 1 - h], c[h] = n[l + h] - e;
    let d = 0;
    for (let f = 0; f < h; ++f) {
      const E = c[f + 1], v = a[h - f];
      r[h][f] = E + v;
      const g = r[f][h - 1] / r[h][f];
      r[f][h] = d + E * g, d = v * g;
    }
    r[h][h] = d;
  }
  for (let h = 0; h <= t; ++h)
    o[0][h] = r[h][t];
  for (let h = 0; h <= t; ++h) {
    let d = 0, f = 1;
    const E = [];
    for (let v = 0; v <= t; ++v)
      E[v] = i.slice(0);
    E[0][0] = 1;
    for (let v = 1; v <= s; ++v) {
      let g = 0;
      const x = h - v, M = t - v;
      h >= v && (E[f][0] = E[d][0] / r[M + 1][x], g = E[f][0] * r[x][M]);
      const y = x >= -1 ? 1 : -x, m = h - 1 <= M ? v - 1 : t - h;
      for (let b = y; b <= m; ++b)
        E[f][b] = (E[d][b] - E[d][b - 1]) / r[M + 1][x + b], g += E[f][b] * r[x + b][M];
      h <= M && (E[f][v] = -E[d][v - 1] / r[M + 1][h], g += E[f][v] * r[h][M]), o[v][h] = g;
      const A = d;
      d = f, f = A;
    }
  }
  let u = t;
  for (let h = 1; h <= s; ++h) {
    for (let d = 0; d <= t; ++d)
      o[h][d] *= u;
    u *= t - h;
  }
  return o;
}
function na(l, e, t, s, n) {
  const i = n < l ? n : l, o = [], r = Ni(l, s, e), a = sa(r, s, l, i, e), c = [];
  for (let u = 0; u < t.length; ++u) {
    const h = t[u].clone(), d = h.w;
    h.x *= d, h.y *= d, h.z *= d, c[u] = h;
  }
  for (let u = 0; u <= i; ++u) {
    const h = c[r - l].clone().multiplyScalar(a[u][0]);
    for (let d = 1; d <= l; ++d)
      h.add(c[r - l + d].clone().multiplyScalar(a[u][d]));
    o[u] = h;
  }
  for (let u = i + 1; u <= n + 1; ++u)
    o[u] = new Vector4(0, 0, 0);
  return o;
}
function ia(l, e) {
  let t = 1;
  for (let n = 2; n <= l; ++n)
    t *= n;
  let s = 1;
  for (let n = 2; n <= e; ++n)
    s *= n;
  for (let n = 2; n <= l - e; ++n)
    s *= n;
  return t / s;
}
function oa(l) {
  const e = l.length, t = [], s = [];
  for (let i = 0; i < e; ++i) {
    const o = l[i];
    t[i] = new Vector3(o.x, o.y, o.z), s[i] = o.w;
  }
  const n = [];
  for (let i = 0; i < e; ++i) {
    const o = t[i].clone();
    for (let r = 1; r <= i; ++r)
      o.sub(n[i - r].clone().multiplyScalar(ia(i, r) * s[r]));
    n[i] = o.divideScalar(s[0]);
  }
  return n;
}
function ra(l, e, t, s, n) {
  const i = na(l, e, t, s, n);
  return oa(i);
}
var $n = class extends Curve {
  constructor(e, t, s, n, i) {
    super(), this.degree = e, this.knots = t, this.controlPoints = [], this.startKnot = n || 0, this.endKnot = i || this.knots.length - 1;
    for (let o = 0; o < s.length; ++o) {
      const r = s[o];
      this.controlPoints[o] = new Vector4(r.x, r.y, r.z, r.w);
    }
  }
  getPoint(e, t) {
    const s = t || new Vector3(), n = this.knots[this.startKnot] + e * (this.knots[this.endKnot] - this.knots[this.startKnot]), i = ta(this.degree, this.knots, this.controlPoints, n);
    return i.w != 1 && i.divideScalar(i.w), s.set(i.x, i.y, i.z);
  }
  getTangent(e, t) {
    const s = t || new Vector3(), n = this.knots[0] + e * (this.knots[this.knots.length - 1] - this.knots[0]), i = ra(this.degree, this.knots, this.controlPoints, n, 1);
    return s.copy(i[1]).normalize(), s;
  }
};
var ye;
var De;
var je;
var aa = class extends Loader {
  constructor(e) {
    super(e);
  }
  load(e, t, s, n) {
    const i = this, o = i.path === "" ? LoaderUtils.extractUrlBase(e) : i.path, r = new FileLoader(this.manager);
    r.setPath(i.path), r.setResponseType("arraybuffer"), r.setRequestHeader(i.requestHeader), r.setWithCredentials(i.withCredentials), r.load(
      e,
      function(a) {
        try {
          t(i.parse(a, o));
        } catch (c) {
          n ? n(c) : console.error(c), i.manager.itemError(e);
        }
      },
      s,
      n
    );
  }
  parse(e, t) {
    if (da(e))
      ye = new pa().parse(e);
    else {
      const n = Gi(e);
      if (!fa(n))
        throw new Error("THREE.FBXLoader: Unknown format.");
      if (Wn(n) < 7e3)
        throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + Wn(n));
      ye = new ua().parse(n);
    }
    const s = new TextureLoader(this.manager).setPath(this.resourcePath || t).setCrossOrigin(this.crossOrigin);
    return new la(s, this.manager).parse(ye);
  }
};
var la = class {
  constructor(e, t) {
    this.textureLoader = e, this.manager = t;
  }
  parse() {
    De = this.parseConnections();
    const e = this.parseImages(), t = this.parseTextures(e), s = this.parseMaterials(t), n = this.parseDeformers(), i = new ca().parse(n);
    return this.parseScene(n, i, s), je;
  }
  // Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )
  // and details the connection type
  parseConnections() {
    const e = /* @__PURE__ */ new Map();
    return "Connections" in ye && ye.Connections.connections.forEach(function(s) {
      const n = s[0], i = s[1], o = s[2];
      e.has(n) || e.set(n, {
        parents: [],
        children: []
      });
      const r = { ID: i, relationship: o };
      e.get(n).parents.push(r), e.has(i) || e.set(i, {
        parents: [],
        children: []
      });
      const a = { ID: n, relationship: o };
      e.get(i).children.push(a);
    }), e;
  }
  // Parse FBXTree.Objects.Video for embedded image data
  // These images are connected to textures in FBXTree.Objects.Textures
  // via FBXTree.Connections.
  parseImages() {
    const e = {}, t = {};
    if ("Video" in ye.Objects) {
      const s = ye.Objects.Video;
      for (const n in s) {
        const i = s[n], o = parseInt(n);
        if (e[o] = i.RelativeFilename || i.Filename, "Content" in i) {
          const r = i.Content instanceof ArrayBuffer && i.Content.byteLength > 0, a = typeof i.Content == "string" && i.Content !== "";
          if (r || a) {
            const c = this.parseImage(s[n]);
            t[i.RelativeFilename || i.Filename] = c;
          }
        }
      }
    }
    for (const s in e) {
      const n = e[s];
      t[n] !== void 0 ? e[s] = t[n] : e[s] = e[s].split("\\").pop();
    }
    return e;
  }
  // Parse embedded image data in FBXTree.Video.Content
  parseImage(e) {
    const t = e.Content, s = e.RelativeFilename || e.Filename, n = s.slice(s.lastIndexOf(".") + 1).toLowerCase();
    let i;
    switch (n) {
      case "bmp":
        i = "image/bmp";
        break;
      case "jpg":
      case "jpeg":
        i = "image/jpeg";
        break;
      case "png":
        i = "image/png";
        break;
      case "tif":
        i = "image/tiff";
        break;
      case "tga":
        this.manager.getHandler(".tga") === null && console.warn("FBXLoader: TGA loader not found, skipping ", s), i = "image/tga";
        break;
      default:
        console.warn('FBXLoader: Image type "' + n + '" is not supported.');
        return;
    }
    if (typeof t == "string")
      return "data:" + i + ";base64," + t;
    {
      const o = new Uint8Array(t);
      return window.URL.createObjectURL(new Blob([o], { type: i }));
    }
  }
  // Parse nodes in FBXTree.Objects.Texture
  // These contain details such as UV scaling, cropping, rotation etc and are connected
  // to images in FBXTree.Objects.Video
  parseTextures(e) {
    const t = /* @__PURE__ */ new Map();
    if ("Texture" in ye.Objects) {
      const s = ye.Objects.Texture;
      for (const n in s) {
        const i = this.parseTexture(s[n], e);
        t.set(parseInt(n), i);
      }
    }
    return t;
  }
  // Parse individual node in FBXTree.Objects.Texture
  parseTexture(e, t) {
    const s = this.loadTexture(e, t);
    s.ID = e.id, s.name = e.attrName;
    const n = e.WrapModeU, i = e.WrapModeV, o = n !== void 0 ? n.value : 0, r = i !== void 0 ? i.value : 0;
    if (s.wrapS = o === 0 ? RepeatWrapping : ClampToEdgeWrapping, s.wrapT = r === 0 ? RepeatWrapping : ClampToEdgeWrapping, "Scaling" in e) {
      const a = e.Scaling.value;
      s.repeat.x = a[0], s.repeat.y = a[1];
    }
    return s;
  }
  // load a texture specified as a blob or data URI, or via an external URL using TextureLoader
  loadTexture(e, t) {
    let s;
    const n = this.textureLoader.path, i = De.get(e.id).children;
    i !== void 0 && i.length > 0 && t[i[0].ID] !== void 0 && (s = t[i[0].ID], (s.indexOf("blob:") === 0 || s.indexOf("data:") === 0) && this.textureLoader.setPath(void 0));
    let o;
    const r = e.FileName.slice(-3).toLowerCase();
    if (r === "tga") {
      const a = this.manager.getHandler(".tga");
      a === null ? (console.warn("FBXLoader: TGA loader not found, creating placeholder texture for", e.RelativeFilename), o = new Texture()) : (a.setPath(this.textureLoader.path), o = a.load(s));
    } else
      r === "psd" ? (console.warn(
        "FBXLoader: PSD textures are not supported, creating placeholder texture for",
        e.RelativeFilename
      ), o = new Texture()) : o = this.textureLoader.load(s);
    return this.textureLoader.setPath(n), o;
  }
  // Parse nodes in FBXTree.Objects.Material
  parseMaterials(e) {
    const t = /* @__PURE__ */ new Map();
    if ("Material" in ye.Objects) {
      const s = ye.Objects.Material;
      for (const n in s) {
        const i = this.parseMaterial(s[n], e);
        i !== null && t.set(parseInt(n), i);
      }
    }
    return t;
  }
  // Parse single node in FBXTree.Objects.Material
  // Materials are connected to texture maps in FBXTree.Objects.Textures
  // FBX format currently only supports Lambert and Phong shading models
  parseMaterial(e, t) {
    const s = e.id, n = e.attrName;
    let i = e.ShadingModel;
    if (typeof i == "object" && (i = i.value), !De.has(s))
      return null;
    const o = this.parseParameters(e, t, s);
    let r;
    switch (i.toLowerCase()) {
      case "phong":
        r = new MeshPhongMaterial();
        break;
      case "lambert":
        r = new MeshLambertMaterial();
        break;
      default:
        console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', i), r = new MeshPhongMaterial();
        break;
    }
    return r.setValues(o), r.name = n, r;
  }
  // Parse FBX material and return parameters suitable for a three.js material
  // Also parse the texture map and return any textures associated with the material
  parseParameters(e, t, s) {
    const n = {};
    e.BumpFactor && (n.bumpScale = e.BumpFactor.value), e.Diffuse ? n.color = new Color().fromArray(e.Diffuse.value) : e.DiffuseColor && (e.DiffuseColor.type === "Color" || e.DiffuseColor.type === "ColorRGB") && (n.color = new Color().fromArray(e.DiffuseColor.value)), e.DisplacementFactor && (n.displacementScale = e.DisplacementFactor.value), e.Emissive ? n.emissive = new Color().fromArray(e.Emissive.value) : e.EmissiveColor && (e.EmissiveColor.type === "Color" || e.EmissiveColor.type === "ColorRGB") && (n.emissive = new Color().fromArray(e.EmissiveColor.value)), e.EmissiveFactor && (n.emissiveIntensity = parseFloat(e.EmissiveFactor.value)), e.Opacity && (n.opacity = parseFloat(e.Opacity.value)), n.opacity < 1 && (n.transparent = true), e.ReflectionFactor && (n.reflectivity = e.ReflectionFactor.value), e.Shininess && (n.shininess = e.Shininess.value), e.Specular ? n.specular = new Color().fromArray(e.Specular.value) : e.SpecularColor && e.SpecularColor.type === "Color" && (n.specular = new Color().fromArray(e.SpecularColor.value));
    const i = this;
    return De.get(s).children.forEach(function(o) {
      const r = o.relationship;
      switch (r) {
        case "Bump":
          n.bumpMap = i.getTexture(t, o.ID);
          break;
        case "Maya|TEX_ao_map":
          n.aoMap = i.getTexture(t, o.ID);
          break;
        case "DiffuseColor":
        case "Maya|TEX_color_map":
          n.map = i.getTexture(t, o.ID), n.map !== void 0 && ("colorSpace" in n.map ? n.map.colorSpace = "srgb" : n.map.encoding = 3001);
          break;
        case "DisplacementColor":
          n.displacementMap = i.getTexture(t, o.ID);
          break;
        case "EmissiveColor":
          n.emissiveMap = i.getTexture(t, o.ID), n.emissiveMap !== void 0 && ("colorSpace" in n.emissiveMap ? n.emissiveMap.colorSpace = "srgb" : n.emissiveMap.encoding = 3001);
          break;
        case "NormalMap":
        case "Maya|TEX_normal_map":
          n.normalMap = i.getTexture(t, o.ID);
          break;
        case "ReflectionColor":
          n.envMap = i.getTexture(t, o.ID), n.envMap !== void 0 && (n.envMap.mapping = EquirectangularReflectionMapping, "colorSpace" in n.envMap ? n.envMap.colorSpace = "srgb" : n.envMap.encoding = 3001);
          break;
        case "SpecularColor":
          n.specularMap = i.getTexture(t, o.ID), n.specularMap !== void 0 && ("colorSpace" in n.specularMap ? n.specularMap.colorSpace = "srgb" : n.specularMap.encoding = 3001);
          break;
        case "TransparentColor":
        case "TransparencyFactor":
          n.alphaMap = i.getTexture(t, o.ID), n.transparent = true;
          break;
        case "AmbientColor":
        case "ShininessExponent":
        case "SpecularFactor":
        case "VectorDisplacementColor":
        default:
          console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", r);
          break;
      }
    }), n;
  }
  // get a texture from the textureMap for use by a material.
  getTexture(e, t) {
    return "LayeredTexture" in ye.Objects && t in ye.Objects.LayeredTexture && (console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."), t = De.get(t).children[0].ID), e.get(t);
  }
  // Parse nodes in FBXTree.Objects.Deformer
  // Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here
  // Generates map of Skeleton-like objects for use later when generating and binding skeletons.
  parseDeformers() {
    const e = {}, t = {};
    if ("Deformer" in ye.Objects) {
      const s = ye.Objects.Deformer;
      for (const n in s) {
        const i = s[n], o = De.get(parseInt(n));
        if (i.attrType === "Skin") {
          const r = this.parseSkeleton(o, s);
          r.ID = n, o.parents.length > 1 && console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."), r.geometryID = o.parents[0].ID, e[n] = r;
        } else if (i.attrType === "BlendShape") {
          const r = {
            id: n
          };
          r.rawTargets = this.parseMorphTargets(o, s), r.id = n, o.parents.length > 1 && console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."), t[n] = r;
        }
      }
    }
    return {
      skeletons: e,
      morphTargets: t
    };
  }
  // Parse single nodes in FBXTree.Objects.Deformer
  // The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'
  // Each skin node represents a skeleton and each cluster node represents a bone
  parseSkeleton(e, t) {
    const s = [];
    return e.children.forEach(function(n) {
      const i = t[n.ID];
      if (i.attrType !== "Cluster")
        return;
      const o = {
        ID: n.ID,
        indices: [],
        weights: [],
        transformLink: new Matrix4().fromArray(i.TransformLink.a)
        // transform: new Matrix4().fromArray( boneNode.Transform.a ),
        // linkMode: boneNode.Mode,
      };
      "Indexes" in i && (o.indices = i.Indexes.a, o.weights = i.Weights.a), s.push(o);
    }), {
      rawBones: s,
      bones: []
    };
  }
  // The top level morph deformer node has type "BlendShape" and sub nodes have type "BlendShapeChannel"
  parseMorphTargets(e, t) {
    const s = [];
    for (let n = 0; n < e.children.length; n++) {
      const i = e.children[n], o = t[i.ID], r = {
        name: o.attrName,
        initialWeight: o.DeformPercent,
        id: o.id,
        fullWeights: o.FullWeights.a
      };
      if (o.attrType !== "BlendShapeChannel")
        return;
      r.geoID = De.get(parseInt(i.ID)).children.filter(function(a) {
        return a.relationship === void 0;
      })[0].ID, s.push(r);
    }
    return s;
  }
  // create the main Group() to be returned by the loader
  parseScene(e, t, s) {
    je = new Group();
    const n = this.parseModels(e.skeletons, t, s), i = ye.Objects.Model, o = this;
    n.forEach(function(a) {
      const c = i[a.ID];
      o.setLookAtProperties(a, c), De.get(a.ID).parents.forEach(function(h) {
        const d = n.get(h.ID);
        d !== void 0 && d.add(a);
      }), a.parent === null && je.add(a);
    }), this.bindSkeleton(e.skeletons, t, n), this.createAmbientLight(), je.traverse(function(a) {
      if (a.userData.transformData) {
        a.parent && (a.userData.transformData.parentMatrix = a.parent.matrix, a.userData.transformData.parentMatrixWorld = a.parent.matrixWorld);
        const c = Hi(a.userData.transformData);
        a.applyMatrix4(c), a.updateWorldMatrix();
      }
    });
    const r = new ha().parse();
    je.children.length === 1 && je.children[0].isGroup && (je.children[0].animations = r, je = je.children[0]), je.animations = r;
  }
  // parse nodes in FBXTree.Objects.Model
  parseModels(e, t, s) {
    const n = /* @__PURE__ */ new Map(), i = ye.Objects.Model;
    for (const o in i) {
      const r = parseInt(o), a = i[o], c = De.get(r);
      let u = this.buildSkeleton(c, e, r, a.attrName);
      if (!u) {
        switch (a.attrType) {
          case "Camera":
            u = this.createCamera(c);
            break;
          case "Light":
            u = this.createLight(c);
            break;
          case "Mesh":
            u = this.createMesh(c, t, s);
            break;
          case "NurbsCurve":
            u = this.createCurve(c, t);
            break;
          case "LimbNode":
          case "Root":
            u = new Bone();
            break;
          case "Null":
          default:
            u = new Group();
            break;
        }
        u.name = a.attrName ? PropertyBinding.sanitizeNodeName(a.attrName) : "", u.ID = r;
      }
      this.getTransformData(u, a), n.set(r, u);
    }
    return n;
  }
  buildSkeleton(e, t, s, n) {
    let i = null;
    return e.parents.forEach(function(o) {
      for (const r in t) {
        const a = t[r];
        a.rawBones.forEach(function(c, u) {
          if (c.ID === o.ID) {
            const h = i;
            i = new Bone(), i.matrixWorld.copy(c.transformLink), i.name = n ? PropertyBinding.sanitizeNodeName(n) : "", i.ID = s, a.bones[u] = i, h !== null && i.add(h);
          }
        });
      }
    }), i;
  }
  // create a PerspectiveCamera or OrthographicCamera
  createCamera(e) {
    let t, s;
    if (e.children.forEach(function(n) {
      const i = ye.Objects.NodeAttribute[n.ID];
      i !== void 0 && (s = i);
    }), s === void 0)
      t = new Object3D();
    else {
      let n = 0;
      s.CameraProjectionType !== void 0 && s.CameraProjectionType.value === 1 && (n = 1);
      let i = 1;
      s.NearPlane !== void 0 && (i = s.NearPlane.value / 1e3);
      let o = 1e3;
      s.FarPlane !== void 0 && (o = s.FarPlane.value / 1e3);
      let r = window.innerWidth, a = window.innerHeight;
      s.AspectWidth !== void 0 && s.AspectHeight !== void 0 && (r = s.AspectWidth.value, a = s.AspectHeight.value);
      const c = r / a;
      let u = 45;
      s.FieldOfView !== void 0 && (u = s.FieldOfView.value);
      const h = s.FocalLength ? s.FocalLength.value : null;
      switch (n) {
        case 0:
          t = new PerspectiveCamera(u, c, i, o), h !== null && t.setFocalLength(h);
          break;
        case 1:
          t = new OrthographicCamera(
            -r / 2,
            r / 2,
            a / 2,
            -a / 2,
            i,
            o
          );
          break;
        default:
          console.warn("THREE.FBXLoader: Unknown camera type " + n + "."), t = new Object3D();
          break;
      }
    }
    return t;
  }
  // Create a DirectionalLight, PointLight or SpotLight
  createLight(e) {
    let t, s;
    if (e.children.forEach(function(n) {
      const i = ye.Objects.NodeAttribute[n.ID];
      i !== void 0 && (s = i);
    }), s === void 0)
      t = new Object3D();
    else {
      let n;
      s.LightType === void 0 ? n = 0 : n = s.LightType.value;
      let i = 16777215;
      s.Color !== void 0 && (i = new Color().fromArray(s.Color.value));
      let o = s.Intensity === void 0 ? 1 : s.Intensity.value / 100;
      s.CastLightOnObject !== void 0 && s.CastLightOnObject.value === 0 && (o = 0);
      let r = 0;
      s.FarAttenuationEnd !== void 0 && (s.EnableFarAttenuation !== void 0 && s.EnableFarAttenuation.value === 0 ? r = 0 : r = s.FarAttenuationEnd.value);
      const a = 1;
      switch (n) {
        case 0:
          t = new PointLight(i, o, r, a);
          break;
        case 1:
          t = new DirectionalLight(i, o);
          break;
        case 2:
          let c = Math.PI / 3;
          s.InnerAngle !== void 0 && (c = MathUtils.degToRad(s.InnerAngle.value));
          let u = 0;
          s.OuterAngle !== void 0 && (u = MathUtils.degToRad(s.OuterAngle.value), u = Math.max(u, 1)), t = new SpotLight(i, o, r, c, u, a);
          break;
        default:
          console.warn(
            "THREE.FBXLoader: Unknown light type " + s.LightType.value + ", defaulting to a PointLight."
          ), t = new PointLight(i, o);
          break;
      }
      s.CastShadows !== void 0 && s.CastShadows.value === 1 && (t.castShadow = true);
    }
    return t;
  }
  createMesh(e, t, s) {
    let n, i = null, o = null;
    const r = [];
    return e.children.forEach(function(a) {
      t.has(a.ID) && (i = t.get(a.ID)), s.has(a.ID) && r.push(s.get(a.ID));
    }), r.length > 1 ? o = r : r.length > 0 ? o = r[0] : (o = new MeshPhongMaterial({ color: 13421772 }), r.push(o)), "color" in i.attributes && r.forEach(function(a) {
      a.vertexColors = true;
    }), i.FBX_Deformer ? (n = new SkinnedMesh(i, o), n.normalizeSkinWeights()) : n = new Mesh(i, o), n;
  }
  createCurve(e, t) {
    const s = e.children.reduce(function(i, o) {
      return t.has(o.ID) && (i = t.get(o.ID)), i;
    }, null), n = new LineBasicMaterial({ color: 3342591, linewidth: 1 });
    return new Line(s, n);
  }
  // parse the model node for transform data
  getTransformData(e, t) {
    const s = {};
    "InheritType" in t && (s.inheritType = parseInt(t.InheritType.value)), "RotationOrder" in t ? s.eulerOrder = Vi(t.RotationOrder.value) : s.eulerOrder = "ZYX", "Lcl_Translation" in t && (s.translation = t.Lcl_Translation.value), "PreRotation" in t && (s.preRotation = t.PreRotation.value), "Lcl_Rotation" in t && (s.rotation = t.Lcl_Rotation.value), "PostRotation" in t && (s.postRotation = t.PostRotation.value), "Lcl_Scaling" in t && (s.scale = t.Lcl_Scaling.value), "ScalingOffset" in t && (s.scalingOffset = t.ScalingOffset.value), "ScalingPivot" in t && (s.scalingPivot = t.ScalingPivot.value), "RotationOffset" in t && (s.rotationOffset = t.RotationOffset.value), "RotationPivot" in t && (s.rotationPivot = t.RotationPivot.value), e.userData.transformData = s;
  }
  setLookAtProperties(e, t) {
    "LookAtProperty" in t && De.get(e.ID).children.forEach(function(n) {
      if (n.relationship === "LookAtProperty") {
        const i = ye.Objects.Model[n.ID];
        if ("Lcl_Translation" in i) {
          const o = i.Lcl_Translation.value;
          e.target !== void 0 ? (e.target.position.fromArray(o), je.add(e.target)) : e.lookAt(new Vector3().fromArray(o));
        }
      }
    });
  }
  bindSkeleton(e, t, s) {
    const n = this.parsePoseNodes();
    for (const i in e) {
      const o = e[i];
      De.get(parseInt(o.ID)).parents.forEach(function(a) {
        if (t.has(a.ID)) {
          const c = a.ID;
          De.get(c).parents.forEach(function(h) {
            s.has(h.ID) && s.get(h.ID).bind(new Skeleton(o.bones), n[h.ID]);
          });
        }
      });
    }
  }
  parsePoseNodes() {
    const e = {};
    if ("Pose" in ye.Objects) {
      const t = ye.Objects.Pose;
      for (const s in t)
        if (t[s].attrType === "BindPose" && t[s].NbPoseNodes > 0) {
          const n = t[s].PoseNode;
          Array.isArray(n) ? n.forEach(function(i) {
            e[i.Node] = new Matrix4().fromArray(i.Matrix.a);
          }) : e[n.Node] = new Matrix4().fromArray(n.Matrix.a);
        }
    }
    return e;
  }
  // Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light
  createAmbientLight() {
    if ("GlobalSettings" in ye && "AmbientColor" in ye.GlobalSettings) {
      const e = ye.GlobalSettings.AmbientColor.value, t = e[0], s = e[1], n = e[2];
      if (t !== 0 || s !== 0 || n !== 0) {
        const i = new Color(t, s, n);
        je.add(new AmbientLight(i, 1));
      }
    }
  }
};
var ca = class {
  // Parse nodes in FBXTree.Objects.Geometry
  parse(e) {
    const t = /* @__PURE__ */ new Map();
    if ("Geometry" in ye.Objects) {
      const s = ye.Objects.Geometry;
      for (const n in s) {
        const i = De.get(parseInt(n)), o = this.parseGeometry(i, s[n], e);
        t.set(parseInt(n), o);
      }
    }
    return t;
  }
  // Parse single node in FBXTree.Objects.Geometry
  parseGeometry(e, t, s) {
    switch (t.attrType) {
      case "Mesh":
        return this.parseMeshGeometry(e, t, s);
      case "NurbsCurve":
        return this.parseNurbsGeometry(t);
    }
  }
  // Parse single node mesh geometry in FBXTree.Objects.Geometry
  parseMeshGeometry(e, t, s) {
    const n = s.skeletons, i = [], o = e.parents.map(function(h) {
      return ye.Objects.Model[h.ID];
    });
    if (o.length === 0)
      return;
    const r = e.children.reduce(function(h, d) {
      return n[d.ID] !== void 0 && (h = n[d.ID]), h;
    }, null);
    e.children.forEach(function(h) {
      s.morphTargets[h.ID] !== void 0 && i.push(s.morphTargets[h.ID]);
    });
    const a = o[0], c = {};
    "RotationOrder" in a && (c.eulerOrder = Vi(a.RotationOrder.value)), "InheritType" in a && (c.inheritType = parseInt(a.InheritType.value)), "GeometricTranslation" in a && (c.translation = a.GeometricTranslation.value), "GeometricRotation" in a && (c.rotation = a.GeometricRotation.value), "GeometricScaling" in a && (c.scale = a.GeometricScaling.value);
    const u = Hi(c);
    return this.genGeometry(t, r, i, u);
  }
  // Generate a BufferGeometry from a node in FBXTree.Objects.Geometry
  genGeometry(e, t, s, n) {
    const i = new BufferGeometry();
    e.attrName && (i.name = e.attrName);
    const o = this.parseGeoNode(e, t), r = this.genBuffers(o), a = new Float32BufferAttribute(r.vertex, 3);
    if (a.applyMatrix4(n), i.setAttribute("position", a), r.colors.length > 0 && i.setAttribute("color", new Float32BufferAttribute(r.colors, 3)), t && (i.setAttribute("skinIndex", new Uint16BufferAttribute(r.weightsIndices, 4)), i.setAttribute("skinWeight", new Float32BufferAttribute(r.vertexWeights, 4)), i.FBX_Deformer = t), r.normal.length > 0) {
      const c = new Matrix3().getNormalMatrix(n), u = new Float32BufferAttribute(r.normal, 3);
      u.applyNormalMatrix(c), i.setAttribute("normal", u);
    }
    if (r.uvs.forEach(function(c, u) {
      let h = "uv" + (u + 1).toString();
      u === 0 && (h = "uv"), i.setAttribute(h, new Float32BufferAttribute(r.uvs[u], 2));
    }), o.material && o.material.mappingType !== "AllSame") {
      let c = r.materialIndex[0], u = 0;
      if (r.materialIndex.forEach(function(h, d) {
        h !== c && (i.addGroup(u, d - u, c), c = h, u = d);
      }), i.groups.length > 0) {
        const h = i.groups[i.groups.length - 1], d = h.start + h.count;
        d !== r.materialIndex.length && i.addGroup(d, r.materialIndex.length - d, c);
      }
      i.groups.length === 0 && i.addGroup(0, r.materialIndex.length, r.materialIndex[0]);
    }
    return this.addMorphTargets(i, e, s, n), i;
  }
  parseGeoNode(e, t) {
    const s = {};
    if (s.vertexPositions = e.Vertices !== void 0 ? e.Vertices.a : [], s.vertexIndices = e.PolygonVertexIndex !== void 0 ? e.PolygonVertexIndex.a : [], e.LayerElementColor && (s.color = this.parseVertexColors(e.LayerElementColor[0])), e.LayerElementMaterial && (s.material = this.parseMaterialIndices(e.LayerElementMaterial[0])), e.LayerElementNormal && (s.normal = this.parseNormals(e.LayerElementNormal[0])), e.LayerElementUV) {
      s.uv = [];
      let n = 0;
      for (; e.LayerElementUV[n]; )
        e.LayerElementUV[n].UV && s.uv.push(this.parseUVs(e.LayerElementUV[n])), n++;
    }
    return s.weightTable = {}, t !== null && (s.skeleton = t, t.rawBones.forEach(function(n, i) {
      n.indices.forEach(function(o, r) {
        s.weightTable[o] === void 0 && (s.weightTable[o] = []), s.weightTable[o].push({
          id: i,
          weight: n.weights[r]
        });
      });
    })), s;
  }
  genBuffers(e) {
    const t = {
      vertex: [],
      normal: [],
      colors: [],
      uvs: [],
      materialIndex: [],
      vertexWeights: [],
      weightsIndices: []
    };
    let s = 0, n = 0, i = false, o = [], r = [], a = [], c = [], u = [], h = [];
    const d = this;
    return e.vertexIndices.forEach(function(f, E) {
      let v, g = false;
      f < 0 && (f = f ^ -1, g = true);
      let x = [], M = [];
      if (o.push(f * 3, f * 3 + 1, f * 3 + 2), e.color) {
        const y = Ps(E, s, f, e.color);
        a.push(y[0], y[1], y[2]);
      }
      if (e.skeleton) {
        if (e.weightTable[f] !== void 0 && e.weightTable[f].forEach(function(y) {
          M.push(y.weight), x.push(y.id);
        }), M.length > 4) {
          i || (console.warn(
            "THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."
          ), i = true);
          const y = [0, 0, 0, 0], m = [0, 0, 0, 0];
          M.forEach(function(A, b) {
            let _ = A, T = x[b];
            m.forEach(function(L2, B, k) {
              if (_ > L2) {
                k[B] = _, _ = L2;
                const N = y[B];
                y[B] = T, T = N;
              }
            });
          }), x = y, M = m;
        }
        for (; M.length < 4; )
          M.push(0), x.push(0);
        for (let y = 0; y < 4; ++y)
          u.push(M[y]), h.push(x[y]);
      }
      if (e.normal) {
        const y = Ps(E, s, f, e.normal);
        r.push(y[0], y[1], y[2]);
      }
      e.material && e.material.mappingType !== "AllSame" && (v = Ps(E, s, f, e.material)[0]), e.uv && e.uv.forEach(function(y, m) {
        const A = Ps(E, s, f, y);
        c[m] === void 0 && (c[m] = []), c[m].push(A[0]), c[m].push(A[1]);
      }), n++, g && (d.genFace(
        t,
        e,
        o,
        v,
        r,
        a,
        c,
        u,
        h,
        n
      ), s++, n = 0, o = [], r = [], a = [], c = [], u = [], h = []);
    }), t;
  }
  // Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris
  genFace(e, t, s, n, i, o, r, a, c, u) {
    for (let h = 2; h < u; h++)
      e.vertex.push(t.vertexPositions[s[0]]), e.vertex.push(t.vertexPositions[s[1]]), e.vertex.push(t.vertexPositions[s[2]]), e.vertex.push(t.vertexPositions[s[(h - 1) * 3]]), e.vertex.push(t.vertexPositions[s[(h - 1) * 3 + 1]]), e.vertex.push(t.vertexPositions[s[(h - 1) * 3 + 2]]), e.vertex.push(t.vertexPositions[s[h * 3]]), e.vertex.push(t.vertexPositions[s[h * 3 + 1]]), e.vertex.push(t.vertexPositions[s[h * 3 + 2]]), t.skeleton && (e.vertexWeights.push(a[0]), e.vertexWeights.push(a[1]), e.vertexWeights.push(a[2]), e.vertexWeights.push(a[3]), e.vertexWeights.push(a[(h - 1) * 4]), e.vertexWeights.push(a[(h - 1) * 4 + 1]), e.vertexWeights.push(a[(h - 1) * 4 + 2]), e.vertexWeights.push(a[(h - 1) * 4 + 3]), e.vertexWeights.push(a[h * 4]), e.vertexWeights.push(a[h * 4 + 1]), e.vertexWeights.push(a[h * 4 + 2]), e.vertexWeights.push(a[h * 4 + 3]), e.weightsIndices.push(c[0]), e.weightsIndices.push(c[1]), e.weightsIndices.push(c[2]), e.weightsIndices.push(c[3]), e.weightsIndices.push(c[(h - 1) * 4]), e.weightsIndices.push(c[(h - 1) * 4 + 1]), e.weightsIndices.push(c[(h - 1) * 4 + 2]), e.weightsIndices.push(c[(h - 1) * 4 + 3]), e.weightsIndices.push(c[h * 4]), e.weightsIndices.push(c[h * 4 + 1]), e.weightsIndices.push(c[h * 4 + 2]), e.weightsIndices.push(c[h * 4 + 3])), t.color && (e.colors.push(o[0]), e.colors.push(o[1]), e.colors.push(o[2]), e.colors.push(o[(h - 1) * 3]), e.colors.push(o[(h - 1) * 3 + 1]), e.colors.push(o[(h - 1) * 3 + 2]), e.colors.push(o[h * 3]), e.colors.push(o[h * 3 + 1]), e.colors.push(o[h * 3 + 2])), t.material && t.material.mappingType !== "AllSame" && (e.materialIndex.push(n), e.materialIndex.push(n), e.materialIndex.push(n)), t.normal && (e.normal.push(i[0]), e.normal.push(i[1]), e.normal.push(i[2]), e.normal.push(i[(h - 1) * 3]), e.normal.push(i[(h - 1) * 3 + 1]), e.normal.push(i[(h - 1) * 3 + 2]), e.normal.push(i[h * 3]), e.normal.push(i[h * 3 + 1]), e.normal.push(i[h * 3 + 2])), t.uv && t.uv.forEach(function(d, f) {
        e.uvs[f] === void 0 && (e.uvs[f] = []), e.uvs[f].push(r[f][0]), e.uvs[f].push(r[f][1]), e.uvs[f].push(r[f][(h - 1) * 2]), e.uvs[f].push(r[f][(h - 1) * 2 + 1]), e.uvs[f].push(r[f][h * 2]), e.uvs[f].push(r[f][h * 2 + 1]);
      });
  }
  addMorphTargets(e, t, s, n) {
    if (s.length === 0)
      return;
    e.morphTargetsRelative = true, e.morphAttributes.position = [];
    const i = this;
    s.forEach(function(o) {
      o.rawTargets.forEach(function(r) {
        const a = ye.Objects.Geometry[r.geoID];
        a !== void 0 && i.genMorphGeometry(e, t, a, n, r.name);
      });
    });
  }
  // a morph geometry node is similar to a standard  node, and the node is also contained
  // in FBXTree.Objects.Geometry, however it can only have attributes for position, normal
  // and a special attribute Index defining which vertices of the original geometry are affected
  // Normal and position attributes only have data for the vertices that are affected by the morph
  genMorphGeometry(e, t, s, n, i) {
    const o = t.PolygonVertexIndex !== void 0 ? t.PolygonVertexIndex.a : [], r = s.Vertices !== void 0 ? s.Vertices.a : [], a = s.Indexes !== void 0 ? s.Indexes.a : [], c = e.attributes.position.count * 3, u = new Float32Array(c);
    for (let E = 0; E < a.length; E++) {
      const v = a[E] * 3;
      u[v] = r[E * 3], u[v + 1] = r[E * 3 + 1], u[v + 2] = r[E * 3 + 2];
    }
    const h = {
      vertexIndices: o,
      vertexPositions: u
    }, d = this.genBuffers(h), f = new Float32BufferAttribute(d.vertex, 3);
    f.name = i || s.attrName, f.applyMatrix4(n), e.morphAttributes.position.push(f);
  }
  // Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists
  parseNormals(e) {
    const t = e.MappingInformationType, s = e.ReferenceInformationType, n = e.Normals.a;
    let i = [];
    return s === "IndexToDirect" && ("NormalIndex" in e ? i = e.NormalIndex.a : "NormalsIndex" in e && (i = e.NormalsIndex.a)), {
      dataSize: 3,
      buffer: n,
      indices: i,
      mappingType: t,
      referenceType: s
    };
  }
  // Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists
  parseUVs(e) {
    const t = e.MappingInformationType, s = e.ReferenceInformationType, n = e.UV.a;
    let i = [];
    return s === "IndexToDirect" && (i = e.UVIndex.a), {
      dataSize: 2,
      buffer: n,
      indices: i,
      mappingType: t,
      referenceType: s
    };
  }
  // Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists
  parseVertexColors(e) {
    const t = e.MappingInformationType, s = e.ReferenceInformationType, n = e.Colors.a;
    let i = [];
    return s === "IndexToDirect" && (i = e.ColorIndex.a), {
      dataSize: 4,
      buffer: n,
      indices: i,
      mappingType: t,
      referenceType: s
    };
  }
  // Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists
  parseMaterialIndices(e) {
    const t = e.MappingInformationType, s = e.ReferenceInformationType;
    if (t === "NoMappingInformation")
      return {
        dataSize: 1,
        buffer: [0],
        indices: [0],
        mappingType: "AllSame",
        referenceType: s
      };
    const n = e.Materials.a, i = [];
    for (let o = 0; o < n.length; ++o)
      i.push(o);
    return {
      dataSize: 1,
      buffer: n,
      indices: i,
      mappingType: t,
      referenceType: s
    };
  }
  // Generate a NurbGeometry from a node in FBXTree.Objects.Geometry
  parseNurbsGeometry(e) {
    if ($n === void 0)
      return console.error(
        "THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry."
      ), new BufferGeometry();
    const t = parseInt(e.Order);
    if (isNaN(t))
      return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", e.Order, e.id), new BufferGeometry();
    const s = t - 1, n = e.KnotVector.a, i = [], o = e.Points.a;
    for (let h = 0, d = o.length; h < d; h += 4)
      i.push(new Vector4().fromArray(o, h));
    let r, a;
    if (e.Form === "Closed")
      i.push(i[0]);
    else if (e.Form === "Periodic") {
      r = s, a = n.length - 1 - r;
      for (let h = 0; h < s; ++h)
        i.push(i[h]);
    }
    const u = new $n(s, n, i, r, a).getPoints(i.length * 12);
    return new BufferGeometry().setFromPoints(u);
  }
};
var ha = class {
  // take raw animation clips and turn them into three.js animation clips
  parse() {
    const e = [], t = this.parseClips();
    if (t !== void 0)
      for (const s in t) {
        const n = t[s], i = this.addClip(n);
        e.push(i);
      }
    return e;
  }
  parseClips() {
    if (ye.Objects.AnimationCurve === void 0)
      return;
    const e = this.parseAnimationCurveNodes();
    this.parseAnimationCurves(e);
    const t = this.parseAnimationLayers(e);
    return this.parseAnimStacks(t);
  }
  // parse nodes in FBXTree.Objects.AnimationCurveNode
  // each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )
  // and is referenced by an AnimationLayer
  parseAnimationCurveNodes() {
    const e = ye.Objects.AnimationCurveNode, t = /* @__PURE__ */ new Map();
    for (const s in e) {
      const n = e[s];
      if (n.attrName.match(/S|R|T|DeformPercent/) !== null) {
        const i = {
          id: n.id,
          attr: n.attrName,
          curves: {}
        };
        t.set(i.id, i);
      }
    }
    return t;
  }
  // parse nodes in FBXTree.Objects.AnimationCurve and connect them up to
  // previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated
  // axis ( e.g. times and values of x rotation)
  parseAnimationCurves(e) {
    const t = ye.Objects.AnimationCurve;
    for (const s in t) {
      const n = {
        id: t[s].id,
        times: t[s].KeyTime.a.map(ma),
        values: t[s].KeyValueFloat.a
      }, i = De.get(n.id);
      if (i !== void 0) {
        const o = i.parents[0].ID, r = i.parents[0].relationship;
        r.match(/X/) ? e.get(o).curves.x = n : r.match(/Y/) ? e.get(o).curves.y = n : r.match(/Z/) ? e.get(o).curves.z = n : r.match(/d|DeformPercent/) && e.has(o) && (e.get(o).curves.morph = n);
      }
    }
  }
  // parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references
  // to various AnimationCurveNodes and is referenced by an AnimationStack node
  // note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack
  parseAnimationLayers(e) {
    const t = ye.Objects.AnimationLayer, s = /* @__PURE__ */ new Map();
    for (const n in t) {
      const i = [], o = De.get(parseInt(n));
      o !== void 0 && (o.children.forEach(function(a, c) {
        if (e.has(a.ID)) {
          const u = e.get(a.ID);
          if (u.curves.x !== void 0 || u.curves.y !== void 0 || u.curves.z !== void 0) {
            if (i[c] === void 0) {
              const h = De.get(a.ID).parents.filter(function(d) {
                return d.relationship !== void 0;
              })[0].ID;
              if (h !== void 0) {
                const d = ye.Objects.Model[h.toString()];
                if (d === void 0) {
                  console.warn("THREE.FBXLoader: Encountered a unused curve.", a);
                  return;
                }
                const f = {
                  modelName: d.attrName ? PropertyBinding.sanitizeNodeName(d.attrName) : "",
                  ID: d.id,
                  initialPosition: [0, 0, 0],
                  initialRotation: [0, 0, 0],
                  initialScale: [1, 1, 1]
                };
                je.traverse(function(E) {
                  E.ID === d.id && (f.transform = E.matrix, E.userData.transformData && (f.eulerOrder = E.userData.transformData.eulerOrder));
                }), f.transform || (f.transform = new Matrix4()), "PreRotation" in d && (f.preRotation = d.PreRotation.value), "PostRotation" in d && (f.postRotation = d.PostRotation.value), i[c] = f;
              }
            }
            i[c] && (i[c][u.attr] = u);
          } else if (u.curves.morph !== void 0) {
            if (i[c] === void 0) {
              const h = De.get(a.ID).parents.filter(function(x) {
                return x.relationship !== void 0;
              })[0].ID, d = De.get(h).parents[0].ID, f = De.get(d).parents[0].ID, E = De.get(f).parents[0].ID, v = ye.Objects.Model[E], g = {
                modelName: v.attrName ? PropertyBinding.sanitizeNodeName(v.attrName) : "",
                morphName: ye.Objects.Deformer[h].attrName
              };
              i[c] = g;
            }
            i[c][u.attr] = u;
          }
        }
      }), s.set(parseInt(n), i));
    }
    return s;
  }
  // parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation
  // hierarchy. Each Stack node will be used to create a AnimationClip
  parseAnimStacks(e) {
    const t = ye.Objects.AnimationStack, s = {};
    for (const n in t) {
      const i = De.get(parseInt(n)).children;
      i.length > 1 && console.warn(
        "THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers."
      );
      const o = e.get(i[0].ID);
      s[n] = {
        name: t[n].attrName,
        layer: o
      };
    }
    return s;
  }
  addClip(e) {
    let t = [];
    const s = this;
    return e.layer.forEach(function(n) {
      t = t.concat(s.generateTracks(n));
    }), new AnimationClip(e.name, -1, t);
  }
  generateTracks(e) {
    const t = [];
    let s = new Vector3(), n = new Quaternion(), i = new Vector3();
    if (e.transform && e.transform.decompose(s, n, i), s = s.toArray(), n = new Euler().setFromQuaternion(n, e.eulerOrder).toArray(), i = i.toArray(), e.T !== void 0 && Object.keys(e.T.curves).length > 0) {
      const o = this.generateVectorTrack(
        e.modelName,
        e.T.curves,
        s,
        "position"
      );
      o !== void 0 && t.push(o);
    }
    if (e.R !== void 0 && Object.keys(e.R.curves).length > 0) {
      const o = this.generateRotationTrack(
        e.modelName,
        e.R.curves,
        n,
        e.preRotation,
        e.postRotation,
        e.eulerOrder
      );
      o !== void 0 && t.push(o);
    }
    if (e.S !== void 0 && Object.keys(e.S.curves).length > 0) {
      const o = this.generateVectorTrack(e.modelName, e.S.curves, i, "scale");
      o !== void 0 && t.push(o);
    }
    if (e.DeformPercent !== void 0) {
      const o = this.generateMorphTrack(e);
      o !== void 0 && t.push(o);
    }
    return t;
  }
  generateVectorTrack(e, t, s, n) {
    const i = this.getTimesForAllAxes(t), o = this.getKeyframeTrackValues(i, t, s);
    return new VectorKeyframeTrack(e + "." + n, i, o);
  }
  generateRotationTrack(e, t, s, n, i, o) {
    t.x !== void 0 && (this.interpolateRotations(t.x), t.x.values = t.x.values.map(MathUtils.degToRad)), t.y !== void 0 && (this.interpolateRotations(t.y), t.y.values = t.y.values.map(MathUtils.degToRad)), t.z !== void 0 && (this.interpolateRotations(t.z), t.z.values = t.z.values.map(MathUtils.degToRad));
    const r = this.getTimesForAllAxes(t), a = this.getKeyframeTrackValues(r, t, s);
    n !== void 0 && (n = n.map(MathUtils.degToRad), n.push(o), n = new Euler().fromArray(n), n = new Quaternion().setFromEuler(n)), i !== void 0 && (i = i.map(MathUtils.degToRad), i.push(o), i = new Euler().fromArray(i), i = new Quaternion().setFromEuler(i).invert());
    const c = new Quaternion(), u = new Euler(), h = [];
    for (let d = 0; d < a.length; d += 3)
      u.set(a[d], a[d + 1], a[d + 2], o), c.setFromEuler(u), n !== void 0 && c.premultiply(n), i !== void 0 && c.multiply(i), c.toArray(h, d / 3 * 4);
    return new QuaternionKeyframeTrack(e + ".quaternion", r, h);
  }
  generateMorphTrack(e) {
    const t = e.DeformPercent.curves.morph, s = t.values.map(function(i) {
      return i / 100;
    }), n = je.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];
    return new NumberKeyframeTrack(
      e.modelName + ".morphTargetInfluences[" + n + "]",
      t.times,
      s
    );
  }
  // For all animated objects, times are defined separately for each axis
  // Here we'll combine the times into one sorted array without duplicates
  getTimesForAllAxes(e) {
    let t = [];
    if (e.x !== void 0 && (t = t.concat(e.x.times)), e.y !== void 0 && (t = t.concat(e.y.times)), e.z !== void 0 && (t = t.concat(e.z.times)), t = t.sort(function(s, n) {
      return s - n;
    }), t.length > 1) {
      let s = 1, n = t[0];
      for (let i = 1; i < t.length; i++) {
        const o = t[i];
        o !== n && (t[s] = o, n = o, s++);
      }
      t = t.slice(0, s);
    }
    return t;
  }
  getKeyframeTrackValues(e, t, s) {
    const n = s, i = [];
    let o = -1, r = -1, a = -1;
    return e.forEach(function(c) {
      if (t.x && (o = t.x.times.indexOf(c)), t.y && (r = t.y.times.indexOf(c)), t.z && (a = t.z.times.indexOf(c)), o !== -1) {
        const u = t.x.values[o];
        i.push(u), n[0] = u;
      } else
        i.push(n[0]);
      if (r !== -1) {
        const u = t.y.values[r];
        i.push(u), n[1] = u;
      } else
        i.push(n[1]);
      if (a !== -1) {
        const u = t.z.values[a];
        i.push(u), n[2] = u;
      } else
        i.push(n[2]);
    }), i;
  }
  // Rotations are defined as Euler angles which can have values  of any size
  // These will be converted to quaternions which don't support values greater than
  // PI, so we'll interpolate large rotations
  interpolateRotations(e) {
    for (let t = 1; t < e.values.length; t++) {
      const s = e.values[t - 1], n = e.values[t] - s, i = Math.abs(n);
      if (i >= 180) {
        const o = i / 180, r = n / o;
        let a = s + r;
        const c = e.times[t - 1], h = (e.times[t] - c) / o;
        let d = c + h;
        const f = [], E = [];
        for (; d < e.times[t]; )
          f.push(d), d += h, E.push(a), a += r;
        e.times = Qn(e.times, t, f), e.values = Qn(e.values, t, E);
      }
    }
  }
};
var ua = class {
  getPrevNode() {
    return this.nodeStack[this.currentIndent - 2];
  }
  getCurrentNode() {
    return this.nodeStack[this.currentIndent - 1];
  }
  getCurrentProp() {
    return this.currentProp;
  }
  pushStack(e) {
    this.nodeStack.push(e), this.currentIndent += 1;
  }
  popStack() {
    this.nodeStack.pop(), this.currentIndent -= 1;
  }
  setCurrentProp(e, t) {
    this.currentProp = e, this.currentPropName = t;
  }
  parse(e) {
    this.currentIndent = 0, this.allNodes = new zi(), this.nodeStack = [], this.currentProp = [], this.currentPropName = "";
    const t = this, s = e.split(/[\r\n]+/);
    return s.forEach(function(n, i) {
      const o = n.match(/^[\s\t]*;/), r = n.match(/^[\s\t]*$/);
      if (o || r)
        return;
      const a = n.match("^\\t{" + t.currentIndent + "}(\\w+):(.*){", ""), c = n.match("^\\t{" + t.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)"), u = n.match("^\\t{" + (t.currentIndent - 1) + "}}");
      a ? t.parseNodeBegin(n, a) : c ? t.parseNodeProperty(n, c, s[++i]) : u ? t.popStack() : n.match(/^[^\s\t}]/) && t.parseNodePropertyContinued(n);
    }), this.allNodes;
  }
  parseNodeBegin(e, t) {
    const s = t[1].trim().replace(/^"/, "").replace(/"$/, ""), n = t[2].split(",").map(function(a) {
      return a.trim().replace(/^"/, "").replace(/"$/, "");
    }), i = { name: s }, o = this.parseNodeAttr(n), r = this.getCurrentNode();
    this.currentIndent === 0 ? this.allNodes.add(s, i) : s in r ? (s === "PoseNode" ? r.PoseNode.push(i) : r[s].id !== void 0 && (r[s] = {}, r[s][r[s].id] = r[s]), o.id !== "" && (r[s][o.id] = i)) : typeof o.id == "number" ? (r[s] = {}, r[s][o.id] = i) : s !== "Properties70" && (s === "PoseNode" ? r[s] = [i] : r[s] = i), typeof o.id == "number" && (i.id = o.id), o.name !== "" && (i.attrName = o.name), o.type !== "" && (i.attrType = o.type), this.pushStack(i);
  }
  parseNodeAttr(e) {
    let t = e[0];
    e[0] !== "" && (t = parseInt(e[0]), isNaN(t) && (t = e[0]));
    let s = "", n = "";
    return e.length > 1 && (s = e[1].replace(/^(\w+)::/, ""), n = e[2]), { id: t, name: s, type: n };
  }
  parseNodeProperty(e, t, s) {
    let n = t[1].replace(/^"/, "").replace(/"$/, "").trim(), i = t[2].replace(/^"/, "").replace(/"$/, "").trim();
    n === "Content" && i === "," && (i = s.replace(/"/g, "").replace(/,$/, "").trim());
    const o = this.getCurrentNode();
    if (o.name === "Properties70") {
      this.parseNodeSpecialProperty(e, n, i);
      return;
    }
    if (n === "C") {
      const a = i.split(",").slice(1), c = parseInt(a[0]), u = parseInt(a[1]);
      let h = i.split(",").slice(3);
      h = h.map(function(d) {
        return d.trim().replace(/^"/, "");
      }), n = "connections", i = [c, u], ya(i, h), o[n] === void 0 && (o[n] = []);
    }
    n === "Node" && (o.id = i), n in o && Array.isArray(o[n]) ? o[n].push(i) : n !== "a" ? o[n] = i : o.a = i, this.setCurrentProp(o, n), n === "a" && i.slice(-1) !== "," && (o.a = tn(i));
  }
  parseNodePropertyContinued(e) {
    const t = this.getCurrentNode();
    t.a += e, e.slice(-1) !== "," && (t.a = tn(t.a));
  }
  // parse "Property70"
  parseNodeSpecialProperty(e, t, s) {
    const n = s.split('",').map(function(u) {
      return u.trim().replace(/^\"/, "").replace(/\s/, "_");
    }), i = n[0], o = n[1], r = n[2], a = n[3];
    let c = n[4];
    switch (o) {
      case "int":
      case "enum":
      case "bool":
      case "ULongLong":
      case "double":
      case "Number":
      case "FieldOfView":
        c = parseFloat(c);
        break;
      case "Color":
      case "ColorRGB":
      case "Vector3D":
      case "Lcl_Translation":
      case "Lcl_Rotation":
      case "Lcl_Scaling":
        c = tn(c);
        break;
    }
    this.getPrevNode()[i] = {
      type: o,
      type2: r,
      flag: a,
      value: c
    }, this.setCurrentProp(this.getPrevNode(), i);
  }
};
var pa = class {
  parse(e) {
    const t = new Kn(e);
    t.skip(23);
    const s = t.getUint32();
    if (s < 6400)
      throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + s);
    const n = new zi();
    for (; !this.endOfContent(t); ) {
      const i = this.parseNode(t, s);
      i !== null && n.add(i.name, i);
    }
    return n;
  }
  // Check if reader has reached the end of content.
  endOfContent(e) {
    return e.size() % 16 === 0 ? (e.getOffset() + 160 + 16 & -16) >= e.size() : e.getOffset() + 160 + 16 >= e.size();
  }
  // recursively parse nodes until the end of the file is reached
  parseNode(e, t) {
    const s = {}, n = t >= 7500 ? e.getUint64() : e.getUint32(), i = t >= 7500 ? e.getUint64() : e.getUint32();
    t >= 7500 ? e.getUint64() : e.getUint32();
    const o = e.getUint8(), r = e.getString(o);
    if (n === 0)
      return null;
    const a = [];
    for (let d = 0; d < i; d++)
      a.push(this.parseProperty(e));
    const c = a.length > 0 ? a[0] : "", u = a.length > 1 ? a[1] : "", h = a.length > 2 ? a[2] : "";
    for (s.singleProperty = i === 1 && e.getOffset() === n; n > e.getOffset(); ) {
      const d = this.parseNode(e, t);
      d !== null && this.parseSubNode(r, s, d);
    }
    return s.propertyList = a, typeof c == "number" && (s.id = c), u !== "" && (s.attrName = u), h !== "" && (s.attrType = h), r !== "" && (s.name = r), s;
  }
  parseSubNode(e, t, s) {
    if (s.singleProperty === true) {
      const n = s.propertyList[0];
      Array.isArray(n) ? (t[s.name] = s, s.a = n) : t[s.name] = n;
    } else if (e === "Connections" && s.name === "C") {
      const n = [];
      s.propertyList.forEach(function(i, o) {
        o !== 0 && n.push(i);
      }), t.connections === void 0 && (t.connections = []), t.connections.push(n);
    } else if (s.name === "Properties70")
      Object.keys(s).forEach(function(i) {
        t[i] = s[i];
      });
    else if (e === "Properties70" && s.name === "P") {
      let n = s.propertyList[0], i = s.propertyList[1];
      const o = s.propertyList[2], r = s.propertyList[3];
      let a;
      n.indexOf("Lcl ") === 0 && (n = n.replace("Lcl ", "Lcl_")), i.indexOf("Lcl ") === 0 && (i = i.replace("Lcl ", "Lcl_")), i === "Color" || i === "ColorRGB" || i === "Vector" || i === "Vector3D" || i.indexOf("Lcl_") === 0 ? a = [s.propertyList[4], s.propertyList[5], s.propertyList[6]] : a = s.propertyList[4], t[n] = {
        type: i,
        type2: o,
        flag: r,
        value: a
      };
    } else
      t[s.name] === void 0 ? typeof s.id == "number" ? (t[s.name] = {}, t[s.name][s.id] = s) : t[s.name] = s : s.name === "PoseNode" ? (Array.isArray(t[s.name]) || (t[s.name] = [t[s.name]]), t[s.name].push(s)) : t[s.name][s.id] === void 0 && (t[s.name][s.id] = s);
  }
  parseProperty(e) {
    const t = e.getString(1);
    let s;
    switch (t) {
      case "C":
        return e.getBoolean();
      case "D":
        return e.getFloat64();
      case "F":
        return e.getFloat32();
      case "I":
        return e.getInt32();
      case "L":
        return e.getInt64();
      case "R":
        return s = e.getUint32(), e.getArrayBuffer(s);
      case "S":
        return s = e.getUint32(), e.getString(s);
      case "Y":
        return e.getInt16();
      case "b":
      case "c":
      case "d":
      case "f":
      case "i":
      case "l":
        const n = e.getUint32(), i = e.getUint32(), o = e.getUint32();
        if (i === 0)
          switch (t) {
            case "b":
            case "c":
              return e.getBooleanArray(n);
            case "d":
              return e.getFloat64Array(n);
            case "f":
              return e.getFloat32Array(n);
            case "i":
              return e.getInt32Array(n);
            case "l":
              return e.getInt64Array(n);
          }
        const r = nr(new Uint8Array(e.getArrayBuffer(o))), a = new Kn(r.buffer);
        switch (t) {
          case "b":
          case "c":
            return a.getBooleanArray(n);
          case "d":
            return a.getFloat64Array(n);
          case "f":
            return a.getFloat32Array(n);
          case "i":
            return a.getInt32Array(n);
          case "l":
            return a.getInt64Array(n);
        }
      default:
        throw new Error("THREE.FBXLoader: Unknown property type " + t);
    }
  }
};
var Kn = class {
  constructor(e, t) {
    this.dv = new DataView(e), this.offset = 0, this.littleEndian = t !== void 0 ? t : true;
  }
  getOffset() {
    return this.offset;
  }
  size() {
    return this.dv.buffer.byteLength;
  }
  skip(e) {
    this.offset += e;
  }
  // seems like true/false representation depends on exporter.
  // true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)
  // then sees LSB.
  getBoolean() {
    return (this.getUint8() & 1) === 1;
  }
  getBooleanArray(e) {
    const t = [];
    for (let s = 0; s < e; s++)
      t.push(this.getBoolean());
    return t;
  }
  getUint8() {
    const e = this.dv.getUint8(this.offset);
    return this.offset += 1, e;
  }
  getInt16() {
    const e = this.dv.getInt16(this.offset, this.littleEndian);
    return this.offset += 2, e;
  }
  getInt32() {
    const e = this.dv.getInt32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  getInt32Array(e) {
    const t = [];
    for (let s = 0; s < e; s++)
      t.push(this.getInt32());
    return t;
  }
  getUint32() {
    const e = this.dv.getUint32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  // JavaScript doesn't support 64-bit integer so calculate this here
  // 1 << 32 will return 1 so using multiply operation instead here.
  // There's a possibility that this method returns wrong value if the value
  // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.
  // TODO: safely handle 64-bit integer
  getInt64() {
    let e, t;
    return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), t & 2147483648 ? (t = ~t & 4294967295, e = ~e & 4294967295, e === 4294967295 && (t = t + 1 & 4294967295), e = e + 1 & 4294967295, -(t * 4294967296 + e)) : t * 4294967296 + e;
  }
  getInt64Array(e) {
    const t = [];
    for (let s = 0; s < e; s++)
      t.push(this.getInt64());
    return t;
  }
  // Note: see getInt64() comment
  getUint64() {
    let e, t;
    return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), t * 4294967296 + e;
  }
  getFloat32() {
    const e = this.dv.getFloat32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  getFloat32Array(e) {
    const t = [];
    for (let s = 0; s < e; s++)
      t.push(this.getFloat32());
    return t;
  }
  getFloat64() {
    const e = this.dv.getFloat64(this.offset, this.littleEndian);
    return this.offset += 8, e;
  }
  getFloat64Array(e) {
    const t = [];
    for (let s = 0; s < e; s++)
      t.push(this.getFloat64());
    return t;
  }
  getArrayBuffer(e) {
    const t = this.dv.buffer.slice(this.offset, this.offset + e);
    return this.offset += e, t;
  }
  getString(e) {
    let t = [];
    for (let n = 0; n < e; n++)
      t[n] = this.getUint8();
    const s = t.indexOf(0);
    return s >= 0 && (t = t.slice(0, s)), LoaderUtils.decodeText(new Uint8Array(t));
  }
};
var zi = class {
  add(e, t) {
    this[e] = t;
  }
};
function da(l) {
  const e = "Kaydara FBX Binary  \0";
  return l.byteLength >= e.length && e === Gi(l, 0, e.length);
}
function fa(l) {
  const e = [
    "K",
    "a",
    "y",
    "d",
    "a",
    "r",
    "a",
    "\\",
    "F",
    "B",
    "X",
    "\\",
    "B",
    "i",
    "n",
    "a",
    "r",
    "y",
    "\\",
    "\\"
  ];
  let t = 0;
  function s(n) {
    const i = l[n - 1];
    return l = l.slice(t + n), t++, i;
  }
  for (let n = 0; n < e.length; ++n)
    if (s(1) === e[n])
      return false;
  return true;
}
function Wn(l) {
  const e = /FBXVersion: (\d+)/, t = l.match(e);
  if (t)
    return parseInt(t[1]);
  throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.");
}
function ma(l) {
  return l / 46186158e3;
}
var ga = [];
function Ps(l, e, t, s) {
  let n;
  switch (s.mappingType) {
    case "ByPolygonVertex":
      n = l;
      break;
    case "ByPolygon":
      n = e;
      break;
    case "ByVertice":
      n = t;
      break;
    case "AllSame":
      n = s.indices[0];
      break;
    default:
      console.warn("THREE.FBXLoader: unknown attribute mapping type " + s.mappingType);
  }
  s.referenceType === "IndexToDirect" && (n = s.indices[n]);
  const i = n * s.dataSize, o = i + s.dataSize;
  return _a(ga, s.buffer, i, o);
}
var en = new Euler();
var $t = new Vector3();
function Hi(l) {
  const e = new Matrix4(), t = new Matrix4(), s = new Matrix4(), n = new Matrix4(), i = new Matrix4(), o = new Matrix4(), r = new Matrix4(), a = new Matrix4(), c = new Matrix4(), u = new Matrix4(), h = new Matrix4(), d = new Matrix4(), f = l.inheritType ? l.inheritType : 0;
  if (l.translation && e.setPosition($t.fromArray(l.translation)), l.preRotation) {
    const B = l.preRotation.map(MathUtils.degToRad);
    B.push(l.eulerOrder), t.makeRotationFromEuler(en.fromArray(B));
  }
  if (l.rotation) {
    const B = l.rotation.map(MathUtils.degToRad);
    B.push(l.eulerOrder), s.makeRotationFromEuler(en.fromArray(B));
  }
  if (l.postRotation) {
    const B = l.postRotation.map(MathUtils.degToRad);
    B.push(l.eulerOrder), n.makeRotationFromEuler(en.fromArray(B)), n.invert();
  }
  l.scale && i.scale($t.fromArray(l.scale)), l.scalingOffset && r.setPosition($t.fromArray(l.scalingOffset)), l.scalingPivot && o.setPosition($t.fromArray(l.scalingPivot)), l.rotationOffset && a.setPosition($t.fromArray(l.rotationOffset)), l.rotationPivot && c.setPosition($t.fromArray(l.rotationPivot)), l.parentMatrixWorld && (h.copy(l.parentMatrix), u.copy(l.parentMatrixWorld));
  const E = t.clone().multiply(s).multiply(n), v = new Matrix4();
  v.extractRotation(u);
  const g = new Matrix4();
  g.copyPosition(u);
  const x = g.clone().invert().multiply(u), M = v.clone().invert().multiply(x), y = i, m = new Matrix4();
  if (f === 0)
    m.copy(v).multiply(E).multiply(M).multiply(y);
  else if (f === 1)
    m.copy(v).multiply(M).multiply(E).multiply(y);
  else {
    const k = new Matrix4().scale(new Vector3().setFromMatrixScale(h)).clone().invert(), N = M.clone().multiply(k);
    m.copy(v).multiply(E).multiply(N).multiply(y);
  }
  const A = c.clone().invert(), b = o.clone().invert();
  let _ = e.clone().multiply(a).multiply(c).multiply(t).multiply(s).multiply(n).multiply(A).multiply(r).multiply(o).multiply(i).multiply(b);
  const T = new Matrix4().copyPosition(_), L2 = u.clone().multiply(T);
  return d.copyPosition(L2), _ = d.clone().multiply(m), _.premultiply(u.invert()), _;
}
function Vi(l) {
  l = l || 0;
  const e = [
    "ZYX",
    // -> XYZ extrinsic
    "YZX",
    // -> XZY extrinsic
    "XZY",
    // -> YZX extrinsic
    "ZXY",
    // -> YXZ extrinsic
    "YXZ",
    // -> ZXY extrinsic
    "XYZ"
    // -> ZYX extrinsic
    //'SphericXYZ', // not possible to support
  ];
  return l === 6 ? (console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."), e[0]) : e[l];
}
function tn(l) {
  return l.split(",").map(function(t) {
    return parseFloat(t);
  });
}
function Gi(l, e, t) {
  return e === void 0 && (e = 0), t === void 0 && (t = l.byteLength), LoaderUtils.decodeText(new Uint8Array(l, e, t));
}
function ya(l, e) {
  for (let t = 0, s = l.length, n = e.length; t < n; t++, s++)
    l[s] = e[t];
}
function _a(l, e, t, s) {
  for (let n = t, i = 0; n < s; n++, i++)
    l[i] = e[n];
  return l;
}
function Qn(l, e, t) {
  return l.slice(0, e).concat(t).concat(l.slice(e));
}
var va = Object.defineProperty;
var Ta = (l, e, t) => e in l ? va(l, e, { enumerable: true, configurable: true, writable: true, value: t }) : l[e] = t;
var On = (l, e, t) => (Ta(l, typeof e != "symbol" ? e + "" : e, t), t);
var Ea = class extends Loader {
  constructor(e) {
    super(e);
  }
  load(e, t, s, n) {
    const i = new FileLoader(this.manager);
    i.setPath(this.path), i.setRequestHeader(this.requestHeader), i.setWithCredentials(this.withCredentials), i.load(
      e,
      (o) => {
        if (typeof o != "string")
          throw new Error("unsupported data type");
        const r = JSON.parse(o), a = this.parse(r);
        t && t(a);
      },
      s,
      n
    );
  }
  loadAsync(e, t) {
    return super.loadAsync(e, t);
  }
  parse(e) {
    return new Ln(e);
  }
};
var Ln = class {
  constructor(e) {
    On(this, "data"), this.data = e;
  }
  generateShapes(e, t = 100, s) {
    const n = [], i = { letterSpacing: 0, lineHeight: 1, ...s }, o = xa(e, t, this.data, i);
    for (let r = 0, a = o.length; r < a; r++)
      Array.prototype.push.apply(n, o[r].toShapes(false));
    return n;
  }
};
On(Ln, "isFont");
On(Ln, "type");
function xa(l, e, t, s) {
  const n = Array.from(l), i = e / t.resolution, o = (t.boundingBox.yMax - t.boundingBox.yMin + t.underlineThickness) * i, r = [];
  let a = 0, c = 0;
  for (let u = 0; u < n.length; u++) {
    const h = n[u];
    if (h === `
`)
      a = 0, c -= o * s.lineHeight;
    else {
      const d = wa(h, i, a, c, t);
      d && (a += d.offsetX + s.letterSpacing, r.push(d.path));
    }
  }
  return r;
}
function wa(l, e, t, s, n) {
  const i = n.glyphs[l] || n.glyphs["?"];
  if (!i) {
    console.error('THREE.Font: character "' + l + '" does not exists in font family ' + n.familyName + ".");
    return;
  }
  const o = new ShapePath();
  let r, a, c, u, h, d, f, E;
  if (i.o) {
    const v = i._cachedOutline || (i._cachedOutline = i.o.split(" "));
    for (let g = 0, x = v.length; g < x; )
      switch (v[g++]) {
        case "m":
          r = parseInt(v[g++]) * e + t, a = parseInt(v[g++]) * e + s, o.moveTo(r, a);
          break;
        case "l":
          r = parseInt(v[g++]) * e + t, a = parseInt(v[g++]) * e + s, o.lineTo(r, a);
          break;
        case "q":
          c = parseInt(v[g++]) * e + t, u = parseInt(v[g++]) * e + s, h = parseInt(v[g++]) * e + t, d = parseInt(v[g++]) * e + s, o.quadraticCurveTo(h, d, c, u);
          break;
        case "b":
          c = parseInt(v[g++]) * e + t, u = parseInt(v[g++]) * e + s, h = parseInt(v[g++]) * e + t, d = parseInt(v[g++]) * e + s, f = parseInt(v[g++]) * e + t, E = parseInt(v[g++]) * e + s, o.bezierCurveTo(h, d, f, E, c, u);
          break;
      }
  }
  return { offsetX: i.ha * e, path: o };
}
var ba = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Aa(l) {
  return l && l.__esModule && Object.prototype.hasOwnProperty.call(l, "default") ? l.default : l;
}
var Ma = class extends DataTextureLoader {
  constructor(e) {
    super(e), this.type = HalfFloatType;
  }
  // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html
  parse(e) {
    const r = function(y, m) {
      switch (y) {
        case 1:
          console.error("THREE.RGBELoader Read Error: " + (m || ""));
          break;
        case 2:
          console.error("THREE.RGBELoader Write Error: " + (m || ""));
          break;
        case 3:
          console.error("THREE.RGBELoader Bad File Format: " + (m || ""));
          break;
        default:
        case 4:
          console.error("THREE.RGBELoader: Error: " + (m || ""));
      }
      return -1;
    }, h = `
`, d = function(y, m, A) {
      m = m || 1024;
      let _ = y.pos, T = -1, L2 = 0, B = "", k = String.fromCharCode.apply(null, new Uint16Array(y.subarray(_, _ + 128)));
      for (; 0 > (T = k.indexOf(h)) && L2 < m && _ < y.byteLength; )
        B += k, L2 += k.length, _ += 128, k += String.fromCharCode.apply(null, new Uint16Array(y.subarray(_, _ + 128)));
      return -1 < T ? (A !== false && (y.pos += L2 + T + 1), B + k.slice(0, T)) : false;
    }, f = function(y) {
      const m = /^#\?(\S+)/, A = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/, b = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/, _ = /^\s*FORMAT=(\S+)\s*$/, T = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/, L2 = {
        valid: 0,
        string: "",
        comments: "",
        programtype: "RGBE",
        format: "",
        gamma: 1,
        exposure: 1,
        width: 0,
        height: 0
      };
      let B, k;
      if (y.pos >= y.byteLength || !(B = d(y)))
        return r(1, "no header found");
      if (!(k = B.match(m)))
        return r(3, "bad initial token");
      for (L2.valid |= 1, L2.programtype = k[1], L2.string += B + `
`; B = d(y), B !== false; ) {
        if (L2.string += B + `
`, B.charAt(0) === "#") {
          L2.comments += B + `
`;
          continue;
        }
        if ((k = B.match(A)) && (L2.gamma = parseFloat(k[1])), (k = B.match(b)) && (L2.exposure = parseFloat(k[1])), (k = B.match(_)) && (L2.valid |= 2, L2.format = k[1]), (k = B.match(T)) && (L2.valid |= 4, L2.height = parseInt(k[1], 10), L2.width = parseInt(k[2], 10)), L2.valid & 2 && L2.valid & 4)
          break;
      }
      return L2.valid & 2 ? L2.valid & 4 ? L2 : r(3, "missing image size specifier") : r(3, "missing format specifier");
    }, E = function(y, m, A) {
      const b = m;
      if (
        // run length encoding is not allowed so read flat
        b < 8 || b > 32767 || // this file is not run length encoded
        y[0] !== 2 || y[1] !== 2 || y[2] & 128
      )
        return new Uint8Array(y);
      if (b !== (y[2] << 8 | y[3]))
        return r(3, "wrong scanline width");
      const _ = new Uint8Array(4 * m * A);
      if (!_.length)
        return r(4, "unable to allocate buffer space");
      let T = 0, L2 = 0;
      const B = 4 * b, k = new Uint8Array(4), N = new Uint8Array(B);
      let $ = A;
      for (; $ > 0 && L2 < y.byteLength; ) {
        if (L2 + 4 > y.byteLength)
          return r(1);
        if (k[0] = y[L2++], k[1] = y[L2++], k[2] = y[L2++], k[3] = y[L2++], k[0] != 2 || k[1] != 2 || (k[2] << 8 | k[3]) != b)
          return r(3, "bad rgbe scanline format");
        let Q = 0, Z;
        for (; Q < B && L2 < y.byteLength; ) {
          Z = y[L2++];
          const X = Z > 128;
          if (X && (Z -= 128), Z === 0 || Q + Z > B)
            return r(3, "bad scanline data");
          if (X) {
            const z = y[L2++];
            for (let ce = 0; ce < Z; ce++)
              N[Q++] = z;
          } else
            N.set(y.subarray(L2, L2 + Z), Q), Q += Z, L2 += Z;
        }
        const me = b;
        for (let X = 0; X < me; X++) {
          let z = 0;
          _[T] = N[X + z], z += b, _[T + 1] = N[X + z], z += b, _[T + 2] = N[X + z], z += b, _[T + 3] = N[X + z], T += 4;
        }
        $--;
      }
      return _;
    }, v = function(y, m, A, b) {
      const _ = y[m + 3], T = Math.pow(2, _ - 128) / 255;
      A[b + 0] = y[m + 0] * T, A[b + 1] = y[m + 1] * T, A[b + 2] = y[m + 2] * T, A[b + 3] = 1;
    }, g = function(y, m, A, b) {
      const _ = y[m + 3], T = Math.pow(2, _ - 128) / 255;
      A[b + 0] = DataUtils.toHalfFloat(Math.min(y[m + 0] * T, 65504)), A[b + 1] = DataUtils.toHalfFloat(Math.min(y[m + 1] * T, 65504)), A[b + 2] = DataUtils.toHalfFloat(Math.min(y[m + 2] * T, 65504)), A[b + 3] = DataUtils.toHalfFloat(1);
    }, x = new Uint8Array(e);
    x.pos = 0;
    const M = f(x);
    if (M !== -1) {
      const y = M.width, m = M.height, A = E(x.subarray(x.pos), y, m);
      if (A !== -1) {
        let b, _, T;
        switch (this.type) {
          case FloatType:
            T = A.length / 4;
            const L2 = new Float32Array(T * 4);
            for (let k = 0; k < T; k++)
              v(A, k * 4, L2, k * 4);
            b = L2, _ = FloatType;
            break;
          case HalfFloatType:
            T = A.length / 4;
            const B = new Uint16Array(T * 4);
            for (let k = 0; k < T; k++)
              g(A, k * 4, B, k * 4);
            b = B, _ = HalfFloatType;
            break;
          default:
            console.error("THREE.RGBELoader: unsupported type: ", this.type);
            break;
        }
        return {
          width: y,
          height: m,
          data: b,
          header: M.string,
          gamma: M.gamma,
          exposure: M.exposure,
          type: _
        };
      }
    }
    return null;
  }
  setDataType(e) {
    return this.type = e, this;
  }
  load(e, t, s, n) {
    function i(o, r) {
      switch (o.type) {
        case FloatType:
        case HalfFloatType:
          "colorSpace" in o ? o.colorSpace = "srgb-linear" : o.encoding = 3e3, o.minFilter = LinearFilter, o.magFilter = LinearFilter, o.generateMipmaps = false, o.flipY = true;
          break;
      }
      t && t(o, r);
    }
    return super.load(e, i, s, n);
  }
};
var ps = class _ps extends Loader {
  constructor(e) {
    super(e), this.defaultDPI = 90, this.defaultUnit = "px";
  }
  load(e, t, s, n) {
    const i = this, o = new FileLoader(i.manager);
    o.setPath(i.path), o.setRequestHeader(i.requestHeader), o.setWithCredentials(i.withCredentials), o.load(
      e,
      function(r) {
        try {
          t(i.parse(r));
        } catch (a) {
          n ? n(a) : console.error(a), i.manager.itemError(e);
        }
      },
      s,
      n
    );
  }
  parse(e) {
    const t = this;
    function s(I, O) {
      if (I.nodeType !== 1)
        return;
      const p = m(I);
      let R = true, H = null;
      switch (I.nodeName) {
        case "svg":
          break;
        case "style":
          i(I);
          break;
        case "g":
          O = E(I, O);
          break;
        case "path":
          O = E(I, O), I.hasAttribute("d") && (H = n(I));
          break;
        case "rect":
          O = E(I, O), H = a(I);
          break;
        case "polygon":
          O = E(I, O), H = c(I);
          break;
        case "polyline":
          O = E(I, O), H = u(I);
          break;
        case "circle":
          O = E(I, O), H = h(I);
          break;
        case "ellipse":
          O = E(I, O), H = d(I);
          break;
        case "line":
          O = E(I, O), H = f(I);
          break;
        case "defs":
          R = false;
          break;
        case "mask":
          R = false;
          break;
        case "use":
          O = E(I, O);
          const S = I.href.baseVal.substring(1), V = I.viewportElement.getElementById(S);
          V ? s(V, O) : console.warn("SVGLoader: 'use node' references non-existent node id: " + S);
          break;
      }
      if (H && (O.fill !== void 0 && O.fill !== "none" && H.color.setStyle(O.fill), b(H, ce), B.push(H), H.userData = { node: I, style: O }), R) {
        const S = I.childNodes;
        for (let V = 0; V < S.length; V++)
          s(S[V], O);
      }
      p && (N.pop(), N.length > 0 ? ce.copy(N[N.length - 1]) : ce.identity());
    }
    function n(I) {
      const O = new ShapePath(), p = new Vector2(), R = new Vector2(), H = new Vector2();
      let S = true, V = false;
      const J = I.getAttribute("d").match(/[a-df-z][^a-df-z]*/gi);
      for (let te = 0, K = J.length; te < K; te++) {
        const Te = J[te], j = Te.charAt(0), W = Te.substr(1).trim();
        S === true && (V = true, S = false);
        let P;
        switch (j) {
          case "M":
            P = g(W);
            for (let w = 0, q = P.length; w < q; w += 2)
              p.x = P[w + 0], p.y = P[w + 1], R.x = p.x, R.y = p.y, w === 0 ? O.moveTo(p.x, p.y) : O.lineTo(p.x, p.y), w === 0 && H.copy(p);
            break;
          case "H":
            P = g(W);
            for (let w = 0, q = P.length; w < q; w++)
              p.x = P[w], R.x = p.x, R.y = p.y, O.lineTo(p.x, p.y), w === 0 && V === true && H.copy(p);
            break;
          case "V":
            P = g(W);
            for (let w = 0, q = P.length; w < q; w++)
              p.y = P[w], R.x = p.x, R.y = p.y, O.lineTo(p.x, p.y), w === 0 && V === true && H.copy(p);
            break;
          case "L":
            P = g(W);
            for (let w = 0, q = P.length; w < q; w += 2)
              p.x = P[w + 0], p.y = P[w + 1], R.x = p.x, R.y = p.y, O.lineTo(p.x, p.y), w === 0 && V === true && H.copy(p);
            break;
          case "C":
            P = g(W);
            for (let w = 0, q = P.length; w < q; w += 6)
              O.bezierCurveTo(
                P[w + 0],
                P[w + 1],
                P[w + 2],
                P[w + 3],
                P[w + 4],
                P[w + 5]
              ), R.x = P[w + 2], R.y = P[w + 3], p.x = P[w + 4], p.y = P[w + 5], w === 0 && V === true && H.copy(p);
            break;
          case "S":
            P = g(W);
            for (let w = 0, q = P.length; w < q; w += 4)
              O.bezierCurveTo(
                v(p.x, R.x),
                v(p.y, R.y),
                P[w + 0],
                P[w + 1],
                P[w + 2],
                P[w + 3]
              ), R.x = P[w + 0], R.y = P[w + 1], p.x = P[w + 2], p.y = P[w + 3], w === 0 && V === true && H.copy(p);
            break;
          case "Q":
            P = g(W);
            for (let w = 0, q = P.length; w < q; w += 4)
              O.quadraticCurveTo(P[w + 0], P[w + 1], P[w + 2], P[w + 3]), R.x = P[w + 0], R.y = P[w + 1], p.x = P[w + 2], p.y = P[w + 3], w === 0 && V === true && H.copy(p);
            break;
          case "T":
            P = g(W);
            for (let w = 0, q = P.length; w < q; w += 2) {
              const ge = v(p.x, R.x), Oe = v(p.y, R.y);
              O.quadraticCurveTo(ge, Oe, P[w + 0], P[w + 1]), R.x = ge, R.y = Oe, p.x = P[w + 0], p.y = P[w + 1], w === 0 && V === true && H.copy(p);
            }
            break;
          case "A":
            P = g(W, [3, 4], 7);
            for (let w = 0, q = P.length; w < q; w += 7) {
              if (P[w + 5] == p.x && P[w + 6] == p.y)
                continue;
              const ge = p.clone();
              p.x = P[w + 5], p.y = P[w + 6], R.x = p.x, R.y = p.y, o(
                O,
                P[w],
                P[w + 1],
                P[w + 2],
                P[w + 3],
                P[w + 4],
                ge,
                p
              ), w === 0 && V === true && H.copy(p);
            }
            break;
          case "m":
            P = g(W);
            for (let w = 0, q = P.length; w < q; w += 2)
              p.x += P[w + 0], p.y += P[w + 1], R.x = p.x, R.y = p.y, w === 0 ? O.moveTo(p.x, p.y) : O.lineTo(p.x, p.y), w === 0 && H.copy(p);
            break;
          case "h":
            P = g(W);
            for (let w = 0, q = P.length; w < q; w++)
              p.x += P[w], R.x = p.x, R.y = p.y, O.lineTo(p.x, p.y), w === 0 && V === true && H.copy(p);
            break;
          case "v":
            P = g(W);
            for (let w = 0, q = P.length; w < q; w++)
              p.y += P[w], R.x = p.x, R.y = p.y, O.lineTo(p.x, p.y), w === 0 && V === true && H.copy(p);
            break;
          case "l":
            P = g(W);
            for (let w = 0, q = P.length; w < q; w += 2)
              p.x += P[w + 0], p.y += P[w + 1], R.x = p.x, R.y = p.y, O.lineTo(p.x, p.y), w === 0 && V === true && H.copy(p);
            break;
          case "c":
            P = g(W);
            for (let w = 0, q = P.length; w < q; w += 6)
              O.bezierCurveTo(
                p.x + P[w + 0],
                p.y + P[w + 1],
                p.x + P[w + 2],
                p.y + P[w + 3],
                p.x + P[w + 4],
                p.y + P[w + 5]
              ), R.x = p.x + P[w + 2], R.y = p.y + P[w + 3], p.x += P[w + 4], p.y += P[w + 5], w === 0 && V === true && H.copy(p);
            break;
          case "s":
            P = g(W);
            for (let w = 0, q = P.length; w < q; w += 4)
              O.bezierCurveTo(
                v(p.x, R.x),
                v(p.y, R.y),
                p.x + P[w + 0],
                p.y + P[w + 1],
                p.x + P[w + 2],
                p.y + P[w + 3]
              ), R.x = p.x + P[w + 0], R.y = p.y + P[w + 1], p.x += P[w + 2], p.y += P[w + 3], w === 0 && V === true && H.copy(p);
            break;
          case "q":
            P = g(W);
            for (let w = 0, q = P.length; w < q; w += 4)
              O.quadraticCurveTo(
                p.x + P[w + 0],
                p.y + P[w + 1],
                p.x + P[w + 2],
                p.y + P[w + 3]
              ), R.x = p.x + P[w + 0], R.y = p.y + P[w + 1], p.x += P[w + 2], p.y += P[w + 3], w === 0 && V === true && H.copy(p);
            break;
          case "t":
            P = g(W);
            for (let w = 0, q = P.length; w < q; w += 2) {
              const ge = v(p.x, R.x), Oe = v(p.y, R.y);
              O.quadraticCurveTo(ge, Oe, p.x + P[w + 0], p.y + P[w + 1]), R.x = ge, R.y = Oe, p.x = p.x + P[w + 0], p.y = p.y + P[w + 1], w === 0 && V === true && H.copy(p);
            }
            break;
          case "a":
            P = g(W, [3, 4], 7);
            for (let w = 0, q = P.length; w < q; w += 7) {
              if (P[w + 5] == 0 && P[w + 6] == 0)
                continue;
              const ge = p.clone();
              p.x += P[w + 5], p.y += P[w + 6], R.x = p.x, R.y = p.y, o(
                O,
                P[w],
                P[w + 1],
                P[w + 2],
                P[w + 3],
                P[w + 4],
                ge,
                p
              ), w === 0 && V === true && H.copy(p);
            }
            break;
          case "Z":
          case "z":
            O.currentPath.autoClose = true, O.currentPath.curves.length > 0 && (p.copy(H), O.currentPath.currentPoint.copy(p), S = true);
            break;
          default:
            console.warn(Te);
        }
        V = false;
      }
      return O;
    }
    function i(I) {
      if (!(!I.sheet || !I.sheet.cssRules || !I.sheet.cssRules.length))
        for (let O = 0; O < I.sheet.cssRules.length; O++) {
          const p = I.sheet.cssRules[O];
          if (p.type !== 1)
            continue;
          const R = p.selectorText.split(/,/gm).filter(Boolean).map((H) => H.trim());
          for (let H = 0; H < R.length; H++)
            k[R[H]] = Object.assign(k[R[H]] || {}, p.style);
        }
    }
    function o(I, O, p, R, H, S, V, ie) {
      if (O == 0 || p == 0) {
        I.lineTo(ie.x, ie.y);
        return;
      }
      R = R * Math.PI / 180, O = Math.abs(O), p = Math.abs(p);
      const J = (V.x - ie.x) / 2, te = (V.y - ie.y) / 2, K = Math.cos(R) * J + Math.sin(R) * te, Te = -Math.sin(R) * J + Math.cos(R) * te;
      let j = O * O, W = p * p;
      const P = K * K, w = Te * Te, q = P / j + w / W;
      if (q > 1) {
        const ws = Math.sqrt(q);
        O = ws * O, p = ws * p, j = O * O, W = p * p;
      }
      const ge = j * w + W * P, Oe = (j * W - ge) / ge;
      let ze = Math.sqrt(Math.max(0, Oe));
      H === S && (ze = -ze);
      const Ke = ze * O * Te / p, yt = -ze * p * K / O, ts = Math.cos(R) * Ke - Math.sin(R) * yt + (V.x + ie.x) / 2, Gs = Math.sin(R) * Ke + Math.cos(R) * yt + (V.y + ie.y) / 2, Es = r(1, 0, (K - Ke) / O, (Te - yt) / p), xs = r((K - Ke) / O, (Te - yt) / p, (-K - Ke) / O, (-Te - yt) / p) % (Math.PI * 2);
      I.currentPath.absellipse(ts, Gs, O, p, Es, Es + xs, S === 0, R);
    }
    function r(I, O, p, R) {
      const H = I * p + O * R, S = Math.sqrt(I * I + O * O) * Math.sqrt(p * p + R * R);
      let V = Math.acos(Math.max(-1, Math.min(1, H / S)));
      return I * R - O * p < 0 && (V = -V), V;
    }
    function a(I) {
      const O = y(I.getAttribute("x") || 0), p = y(I.getAttribute("y") || 0), R = y(I.getAttribute("rx") || I.getAttribute("ry") || 0), H = y(I.getAttribute("ry") || I.getAttribute("rx") || 0), S = y(I.getAttribute("width")), V = y(I.getAttribute("height")), ie = 1 - 0.551915024494, J = new ShapePath();
      return J.moveTo(O + R, p), J.lineTo(O + S - R, p), (R !== 0 || H !== 0) && J.bezierCurveTo(O + S - R * ie, p, O + S, p + H * ie, O + S, p + H), J.lineTo(O + S, p + V - H), (R !== 0 || H !== 0) && J.bezierCurveTo(O + S, p + V - H * ie, O + S - R * ie, p + V, O + S - R, p + V), J.lineTo(O + R, p + V), (R !== 0 || H !== 0) && J.bezierCurveTo(O + R * ie, p + V, O, p + V - H * ie, O, p + V - H), J.lineTo(O, p + H), (R !== 0 || H !== 0) && J.bezierCurveTo(O, p + H * ie, O + R * ie, p, O + R, p), J;
    }
    function c(I) {
      function O(S, V, ie) {
        const J = y(V), te = y(ie);
        H === 0 ? R.moveTo(J, te) : R.lineTo(J, te), H++;
      }
      const p = /(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g, R = new ShapePath();
      let H = 0;
      return I.getAttribute("points").replace(p, O), R.currentPath.autoClose = true, R;
    }
    function u(I) {
      function O(S, V, ie) {
        const J = y(V), te = y(ie);
        H === 0 ? R.moveTo(J, te) : R.lineTo(J, te), H++;
      }
      const p = /(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g, R = new ShapePath();
      let H = 0;
      return I.getAttribute("points").replace(p, O), R.currentPath.autoClose = false, R;
    }
    function h(I) {
      const O = y(I.getAttribute("cx") || 0), p = y(I.getAttribute("cy") || 0), R = y(I.getAttribute("r") || 0), H = new Path();
      H.absarc(O, p, R, 0, Math.PI * 2);
      const S = new ShapePath();
      return S.subPaths.push(H), S;
    }
    function d(I) {
      const O = y(I.getAttribute("cx") || 0), p = y(I.getAttribute("cy") || 0), R = y(I.getAttribute("rx") || 0), H = y(I.getAttribute("ry") || 0), S = new Path();
      S.absellipse(O, p, R, H, 0, Math.PI * 2);
      const V = new ShapePath();
      return V.subPaths.push(S), V;
    }
    function f(I) {
      const O = y(I.getAttribute("x1") || 0), p = y(I.getAttribute("y1") || 0), R = y(I.getAttribute("x2") || 0), H = y(I.getAttribute("y2") || 0), S = new ShapePath();
      return S.moveTo(O, p), S.lineTo(R, H), S.currentPath.autoClose = false, S;
    }
    function E(I, O) {
      O = Object.assign({}, O);
      let p = {};
      if (I.hasAttribute("class")) {
        const V = I.getAttribute("class").split(/\s/).filter(Boolean).map((ie) => ie.trim());
        for (let ie = 0; ie < V.length; ie++)
          p = Object.assign(p, k["." + V[ie]]);
      }
      I.hasAttribute("id") && (p = Object.assign(p, k["#" + I.getAttribute("id")]));
      function R(V, ie, J) {
        J === void 0 && (J = function(K) {
          return K.startsWith("url") && console.warn("SVGLoader: url access in attributes is not implemented."), K;
        }), I.hasAttribute(V) && (O[ie] = J(I.getAttribute(V))), p[V] && (O[ie] = J(p[V])), I.style && I.style[V] !== "" && (O[ie] = J(I.style[V]));
      }
      function H(V) {
        return Math.max(0, Math.min(1, y(V)));
      }
      function S(V) {
        return Math.max(0, y(V));
      }
      return R("fill", "fill"), R("fill-opacity", "fillOpacity", H), R("fill-rule", "fillRule"), R("opacity", "opacity", H), R("stroke", "stroke"), R("stroke-opacity", "strokeOpacity", H), R("stroke-width", "strokeWidth", S), R("stroke-linejoin", "strokeLineJoin"), R("stroke-linecap", "strokeLineCap"), R("stroke-miterlimit", "strokeMiterLimit", S), R("visibility", "visibility"), O;
    }
    function v(I, O) {
      return I - (O - I);
    }
    function g(I, O, p) {
      if (typeof I != "string")
        throw new TypeError("Invalid input: " + typeof I);
      const R = {
        SEPARATOR: /[ \t\r\n\,.\-+]/,
        WHITESPACE: /[ \t\r\n]/,
        DIGIT: /[\d]/,
        SIGN: /[-+]/,
        POINT: /\./,
        COMMA: /,/,
        EXP: /e/i,
        FLAGS: /[01]/
      }, H = 0, S = 1, V = 2, ie = 3;
      let J = H, te = true, K = "", Te = "";
      const j = [];
      function W(ge, Oe, ze) {
        const Ke = new SyntaxError('Unexpected character "' + ge + '" at index ' + Oe + ".");
        throw Ke.partial = ze, Ke;
      }
      function P() {
        K !== "" && (Te === "" ? j.push(Number(K)) : j.push(Number(K) * Math.pow(10, Number(Te)))), K = "", Te = "";
      }
      let w;
      const q = I.length;
      for (let ge = 0; ge < q; ge++) {
        if (w = I[ge], Array.isArray(O) && O.includes(j.length % p) && R.FLAGS.test(w)) {
          J = S, K = w, P();
          continue;
        }
        if (J === H) {
          if (R.WHITESPACE.test(w))
            continue;
          if (R.DIGIT.test(w) || R.SIGN.test(w)) {
            J = S, K = w;
            continue;
          }
          if (R.POINT.test(w)) {
            J = V, K = w;
            continue;
          }
          R.COMMA.test(w) && (te && W(w, ge, j), te = true);
        }
        if (J === S) {
          if (R.DIGIT.test(w)) {
            K += w;
            continue;
          }
          if (R.POINT.test(w)) {
            K += w, J = V;
            continue;
          }
          if (R.EXP.test(w)) {
            J = ie;
            continue;
          }
          R.SIGN.test(w) && K.length === 1 && R.SIGN.test(K[0]) && W(w, ge, j);
        }
        if (J === V) {
          if (R.DIGIT.test(w)) {
            K += w;
            continue;
          }
          if (R.EXP.test(w)) {
            J = ie;
            continue;
          }
          R.POINT.test(w) && K[K.length - 1] === "." && W(w, ge, j);
        }
        if (J === ie) {
          if (R.DIGIT.test(w)) {
            Te += w;
            continue;
          }
          if (R.SIGN.test(w)) {
            if (Te === "") {
              Te += w;
              continue;
            }
            Te.length === 1 && R.SIGN.test(Te) && W(w, ge, j);
          }
        }
        R.WHITESPACE.test(w) ? (P(), J = H, te = false) : R.COMMA.test(w) ? (P(), J = H, te = true) : R.SIGN.test(w) ? (P(), J = S, K = w) : R.POINT.test(w) ? (P(), J = V, K = w) : W(w, ge, j);
      }
      return P(), j;
    }
    const x = ["mm", "cm", "in", "pt", "pc", "px"], M = {
      mm: {
        mm: 1,
        cm: 0.1,
        in: 1 / 25.4,
        pt: 72 / 25.4,
        pc: 6 / 25.4,
        px: -1
      },
      cm: {
        mm: 10,
        cm: 1,
        in: 1 / 2.54,
        pt: 72 / 2.54,
        pc: 6 / 2.54,
        px: -1
      },
      in: {
        mm: 25.4,
        cm: 2.54,
        in: 1,
        pt: 72,
        pc: 6,
        px: -1
      },
      pt: {
        mm: 25.4 / 72,
        cm: 2.54 / 72,
        in: 1 / 72,
        pt: 1,
        pc: 6 / 72,
        px: -1
      },
      pc: {
        mm: 25.4 / 6,
        cm: 2.54 / 6,
        in: 1 / 6,
        pt: 72 / 6,
        pc: 1,
        px: -1
      },
      px: {
        px: 1
      }
    };
    function y(I) {
      let O = "px";
      if (typeof I == "string" || I instanceof String)
        for (let R = 0, H = x.length; R < H; R++) {
          const S = x[R];
          if (I.endsWith(S)) {
            O = S, I = I.substring(0, I.length - S.length);
            break;
          }
        }
      let p;
      return O === "px" && t.defaultUnit !== "px" ? p = M.in[t.defaultUnit] / t.defaultDPI : (p = M[O][t.defaultUnit], p < 0 && (p = M[O].in * t.defaultDPI)), p * parseFloat(I);
    }
    function m(I) {
      if (!(I.hasAttribute("transform") || I.nodeName === "use" && (I.hasAttribute("x") || I.hasAttribute("y"))))
        return null;
      const O = A(I);
      return N.length > 0 && O.premultiply(N[N.length - 1]), ce.copy(O), N.push(O), O;
    }
    function A(I) {
      const O = new Matrix3(), p = $;
      if (I.nodeName === "use" && (I.hasAttribute("x") || I.hasAttribute("y"))) {
        const R = y(I.getAttribute("x")), H = y(I.getAttribute("y"));
        O.translate(R, H);
      }
      if (I.hasAttribute("transform")) {
        const R = I.getAttribute("transform").split(")");
        for (let H = R.length - 1; H >= 0; H--) {
          const S = R[H].trim();
          if (S === "")
            continue;
          const V = S.indexOf("("), ie = S.length;
          if (V > 0 && V < ie) {
            const J = S.substr(0, V), te = g(S.substr(V + 1, ie - V - 1));
            switch (p.identity(), J) {
              case "translate":
                if (te.length >= 1) {
                  const K = te[0];
                  let Te = K;
                  te.length >= 2 && (Te = te[1]), p.translate(K, Te);
                }
                break;
              case "rotate":
                if (te.length >= 1) {
                  let K = 0, Te = 0, j = 0;
                  K = -te[0] * Math.PI / 180, te.length >= 3 && (Te = te[1], j = te[2]), Q.identity().translate(-Te, -j), Z.identity().rotate(K), me.multiplyMatrices(Z, Q), Q.identity().translate(Te, j), p.multiplyMatrices(Q, me);
                }
                break;
              case "scale":
                if (te.length >= 1) {
                  const K = te[0];
                  let Te = K;
                  te.length >= 2 && (Te = te[1]), p.scale(K, Te);
                }
                break;
              case "skewX":
                te.length === 1 && p.set(1, Math.tan(te[0] * Math.PI / 180), 0, 0, 1, 0, 0, 0, 1);
                break;
              case "skewY":
                te.length === 1 && p.set(1, 0, 0, Math.tan(te[0] * Math.PI / 180), 1, 0, 0, 0, 1);
                break;
              case "matrix":
                te.length === 6 && p.set(te[0], te[2], te[4], te[1], te[3], te[5], 0, 0, 1);
                break;
            }
          }
          O.premultiply(p);
        }
      }
      return O;
    }
    function b(I, O) {
      function p(S) {
        z.set(S.x, S.y, 1).applyMatrix3(O), S.set(z.x, z.y);
      }
      const R = _(O), H = I.subPaths;
      for (let S = 0, V = H.length; S < V; S++) {
        const J = H[S].curves;
        for (let te = 0; te < J.length; te++) {
          const K = J[te];
          K.isLineCurve ? (p(K.v1), p(K.v2)) : K.isCubicBezierCurve ? (p(K.v0), p(K.v1), p(K.v2), p(K.v3)) : K.isQuadraticBezierCurve ? (p(K.v0), p(K.v1), p(K.v2)) : K.isEllipseCurve && (R && console.warn("SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented."), X.set(K.aX, K.aY), p(X), K.aX = X.x, K.aY = X.y, K.xRadius *= T(O), K.yRadius *= L2(O));
        }
      }
    }
    function _(I) {
      return I.elements[1] !== 0 || I.elements[3] !== 0;
    }
    function T(I) {
      const O = I.elements;
      return Math.sqrt(O[0] * O[0] + O[1] * O[1]);
    }
    function L2(I) {
      const O = I.elements;
      return Math.sqrt(O[3] * O[3] + O[4] * O[4]);
    }
    const B = [], k = {}, N = [], $ = new Matrix3(), Q = new Matrix3(), Z = new Matrix3(), me = new Matrix3(), X = new Vector2(), z = new Vector3(), ce = new Matrix3(), se = new DOMParser().parseFromString(e, "image/svg+xml");
    return s(se.documentElement, {
      fill: "#000",
      fillOpacity: 1,
      strokeOpacity: 1,
      strokeWidth: 1,
      strokeLineJoin: "miter",
      strokeLineCap: "butt",
      strokeMiterLimit: 4
    }), { paths: B, xml: se.documentElement };
  }
  static createShapes(e) {
    const s = {
      ORIGIN: 0,
      DESTINATION: 1,
      BETWEEN: 2,
      LEFT: 3,
      RIGHT: 4,
      BEHIND: 5,
      BEYOND: 6
    }, n = {
      loc: s.ORIGIN,
      t: 0
    };
    function i(g, x, M, y) {
      const m = g.x, A = x.x, b = M.x, _ = y.x, T = g.y, L2 = x.y, B = M.y, k = y.y, N = (_ - b) * (T - B) - (k - B) * (m - b), $ = (A - m) * (T - B) - (L2 - T) * (m - b), Q = (k - B) * (A - m) - (_ - b) * (L2 - T), Z = N / Q, me = $ / Q;
      if (Q === 0 && N !== 0 || Z <= 0 || Z >= 1 || me < 0 || me > 1)
        return null;
      if (N === 0 && Q === 0) {
        for (let X = 0; X < 2; X++)
          if (o(X === 0 ? M : y, g, x), n.loc == s.ORIGIN) {
            const z = X === 0 ? M : y;
            return { x: z.x, y: z.y, t: n.t };
          } else if (n.loc == s.BETWEEN) {
            const z = +(m + n.t * (A - m)).toPrecision(10), ce = +(T + n.t * (L2 - T)).toPrecision(10);
            return { x: z, y: ce, t: n.t };
          }
        return null;
      } else {
        for (let ce = 0; ce < 2; ce++)
          if (o(ce === 0 ? M : y, g, x), n.loc == s.ORIGIN) {
            const se = ce === 0 ? M : y;
            return { x: se.x, y: se.y, t: n.t };
          }
        const X = +(m + Z * (A - m)).toPrecision(10), z = +(T + Z * (L2 - T)).toPrecision(10);
        return { x: X, y: z, t: Z };
      }
    }
    function o(g, x, M) {
      const y = M.x - x.x, m = M.y - x.y, A = g.x - x.x, b = g.y - x.y, _ = y * b - A * m;
      if (g.x === x.x && g.y === x.y) {
        n.loc = s.ORIGIN, n.t = 0;
        return;
      }
      if (g.x === M.x && g.y === M.y) {
        n.loc = s.DESTINATION, n.t = 1;
        return;
      }
      if (_ < -Number.EPSILON) {
        n.loc = s.LEFT;
        return;
      }
      if (_ > Number.EPSILON) {
        n.loc = s.RIGHT;
        return;
      }
      if (y * A < 0 || m * b < 0) {
        n.loc = s.BEHIND;
        return;
      }
      if (Math.sqrt(y * y + m * m) < Math.sqrt(A * A + b * b)) {
        n.loc = s.BEYOND;
        return;
      }
      let T;
      y !== 0 ? T = A / y : T = b / m, n.loc = s.BETWEEN, n.t = T;
    }
    function r(g, x) {
      const M = [], y = [];
      for (let m = 1; m < g.length; m++) {
        const A = g[m - 1], b = g[m];
        for (let _ = 1; _ < x.length; _++) {
          const T = x[_ - 1], L2 = x[_], B = i(A, b, T, L2);
          B !== null && M.find(
            (k) => k.t <= B.t + Number.EPSILON && k.t >= B.t - Number.EPSILON
          ) === void 0 && (M.push(B), y.push(new Vector2(B.x, B.y)));
        }
      }
      return y;
    }
    function a(g, x, M) {
      const y = new Vector2();
      x.getCenter(y);
      const m = [];
      return M.forEach((A) => {
        A.boundingBox.containsPoint(y) && r(g, A.points).forEach((_) => {
          m.push({ identifier: A.identifier, isCW: A.isCW, point: _ });
        });
      }), m.sort((A, b) => A.point.x - b.point.x), m;
    }
    function c(g, x, M, y, m) {
      (m == null || m === "") && (m = "nonzero");
      const A = new Vector2();
      g.boundingBox.getCenter(A);
      const b = [new Vector2(M, A.y), new Vector2(y, A.y)], _ = a(b, g.boundingBox, x);
      _.sort(($, Q) => $.point.x - Q.point.x);
      const T = [], L2 = [];
      _.forEach(($) => {
        $.identifier === g.identifier ? T.push($) : L2.push($);
      });
      const B = T[0].point.x, k = [];
      let N = 0;
      for (; N < L2.length && L2[N].point.x < B; )
        k.length > 0 && k[k.length - 1] === L2[N].identifier ? k.pop() : k.push(L2[N].identifier), N++;
      if (k.push(g.identifier), m === "evenodd") {
        const $ = k.length % 2 === 0, Q = k[k.length - 2];
        return { identifier: g.identifier, isHole: $, for: Q };
      } else if (m === "nonzero") {
        let $ = true, Q = null, Z = null;
        for (let me = 0; me < k.length; me++) {
          const X = k[me];
          $ ? (Z = x[X].isCW, $ = false, Q = X) : Z !== x[X].isCW && (Z = x[X].isCW, $ = true);
        }
        return { identifier: g.identifier, isHole: $, for: Q };
      } else
        console.warn('fill-rule: "' + m + '" is currently not implemented.');
    }
    let u = 0, h = 999999999, d = -999999999, f = e.subPaths.map((g) => {
      const x = g.getPoints();
      let M = -999999999, y = 999999999, m = -999999999, A = 999999999;
      for (let b = 0; b < x.length; b++) {
        const _ = x[b];
        _.y > M && (M = _.y), _.y < y && (y = _.y), _.x > m && (m = _.x), _.x < A && (A = _.x);
      }
      return d <= m && (d = m + 1), h >= A && (h = A - 1), {
        curves: g.curves,
        points: x,
        isCW: ShapeUtils.isClockWise(x),
        identifier: u++,
        boundingBox: new Box2(new Vector2(A, y), new Vector2(m, M))
      };
    });
    f = f.filter((g) => g.points.length > 1);
    const E = f.map(
      (g) => c(g, f, h, d, e.userData.style.fillRule)
    ), v = [];
    return f.forEach((g) => {
      if (!E[g.identifier].isHole) {
        const M = new Shape();
        M.curves = g.curves, E.filter((m) => m.isHole && m.for === g.identifier).forEach((m) => {
          const A = f[m.identifier], b = new Path();
          b.curves = A.curves, M.holes.push(b);
        }), v.push(M);
      }
    }), v;
  }
  static getStrokeStyle(e, t, s, n, i) {
    return e = e !== void 0 ? e : 1, t = t !== void 0 ? t : "#000", s = s !== void 0 ? s : "miter", n = n !== void 0 ? n : "butt", i = i !== void 0 ? i : 4, {
      strokeColor: t,
      strokeWidth: e,
      strokeLineJoin: s,
      strokeLineCap: n,
      strokeMiterLimit: i
    };
  }
  static pointsToStroke(e, t, s, n) {
    const i = [], o = [], r = [];
    if (_ps.pointsToStrokeWithBuffers(e, t, s, n, i, o, r) === 0)
      return null;
    const a = new BufferGeometry();
    return a.setAttribute("position", new Float32BufferAttribute(i, 3)), a.setAttribute("normal", new Float32BufferAttribute(o, 3)), a.setAttribute("uv", new Float32BufferAttribute(r, 2)), a;
  }
  static pointsToStrokeWithBuffers(e, t, s, n, i, o, r, a) {
    const c = new Vector2(), u = new Vector2(), h = new Vector2(), d = new Vector2(), f = new Vector2(), E = new Vector2(), v = new Vector2(), g = new Vector2(), x = new Vector2(), M = new Vector2(), y = new Vector2(), m = new Vector2(), A = new Vector2(), b = new Vector2(), _ = new Vector2(), T = new Vector2(), L2 = new Vector2();
    s = s !== void 0 ? s : 12, n = n !== void 0 ? n : 1e-3, a = a !== void 0 ? a : 0, e = Te(e);
    const B = e.length;
    if (B < 2)
      return 0;
    const k = e[0].equals(e[B - 1]);
    let N, $ = e[0], Q;
    const Z = t.strokeWidth / 2, me = 1 / (B - 1);
    let X = 0, z, ce, se, ae2, I = false, O = 0, p = a * 3, R = a * 2;
    H(e[0], e[1], c).multiplyScalar(Z), g.copy(e[0]).sub(c), x.copy(e[0]).add(c), M.copy(g), y.copy(x);
    for (let j = 1; j < B; j++) {
      N = e[j], j === B - 1 ? k ? Q = e[1] : Q = void 0 : Q = e[j + 1];
      const W = c;
      if (H($, N, W), h.copy(W).multiplyScalar(Z), m.copy(N).sub(h), A.copy(N).add(h), z = X + me, ce = false, Q !== void 0) {
        H(N, Q, u), h.copy(u).multiplyScalar(Z), b.copy(N).sub(h), _.copy(N).add(h), se = true, h.subVectors(Q, $), W.dot(h) < 0 && (se = false), j === 1 && (I = se), h.subVectors(Q, N), h.normalize();
        const P = Math.abs(W.dot(h));
        if (P !== 0) {
          const w = Z / P;
          h.multiplyScalar(-w), d.subVectors(N, $), f.copy(d).setLength(w).add(h), T.copy(f).negate();
          const q = f.length(), ge = d.length();
          d.divideScalar(ge), E.subVectors(Q, N);
          const Oe = E.length();
          switch (E.divideScalar(Oe), d.dot(T) < ge && E.dot(T) < Oe && (ce = true), L2.copy(f).add(N), T.add(N), ae2 = false, ce ? se ? (_.copy(T), A.copy(T)) : (b.copy(T), m.copy(T)) : ie(), t.strokeLineJoin) {
            case "bevel":
              J(se, ce, z);
              break;
            case "round":
              te(se, ce), se ? V(N, m, b, z, 0) : V(N, _, A, z, 1);
              break;
            case "miter":
            case "miter-clip":
            default:
              const ze = Z * t.strokeMiterLimit / q;
              if (ze < 1)
                if (t.strokeLineJoin !== "miter-clip") {
                  J(se, ce, z);
                  break;
                } else
                  te(se, ce), se ? (E.subVectors(L2, m).multiplyScalar(ze).add(m), v.subVectors(L2, b).multiplyScalar(ze).add(b), S(m, z, 0), S(E, z, 0), S(N, z, 0.5), S(N, z, 0.5), S(E, z, 0), S(v, z, 0), S(N, z, 0.5), S(v, z, 0), S(b, z, 0)) : (E.subVectors(L2, A).multiplyScalar(ze).add(A), v.subVectors(L2, _).multiplyScalar(ze).add(_), S(A, z, 1), S(E, z, 1), S(N, z, 0.5), S(N, z, 0.5), S(E, z, 1), S(v, z, 1), S(N, z, 0.5), S(v, z, 1), S(_, z, 1));
              else
                ce ? (se ? (S(x, X, 1), S(g, X, 0), S(L2, z, 0), S(x, X, 1), S(L2, z, 0), S(T, z, 1)) : (S(x, X, 1), S(g, X, 0), S(L2, z, 1), S(g, X, 0), S(T, z, 0), S(L2, z, 1)), se ? b.copy(L2) : _.copy(L2)) : se ? (S(m, z, 0), S(L2, z, 0), S(N, z, 0.5), S(N, z, 0.5), S(L2, z, 0), S(b, z, 0)) : (S(A, z, 1), S(L2, z, 1), S(N, z, 0.5), S(N, z, 0.5), S(L2, z, 1), S(_, z, 1)), ae2 = true;
              break;
          }
        } else
          ie();
      } else
        ie();
      !k && j === B - 1 && K(e[0], M, y, se, true, X), X = z, $ = N, g.copy(b), x.copy(_);
    }
    if (!k)
      K(N, m, A, se, false, z);
    else if (ce && i) {
      let j = L2, W = T;
      I !== se && (j = T, W = L2), se ? (ae2 || I) && (W.toArray(i, 0 * 3), W.toArray(i, 3 * 3), ae2 && j.toArray(i, 1 * 3)) : (ae2 || !I) && (W.toArray(i, 1 * 3), W.toArray(i, 3 * 3), ae2 && j.toArray(i, 0 * 3));
    }
    return O;
    function H(j, W, P) {
      return P.subVectors(W, j), P.set(-P.y, P.x).normalize();
    }
    function S(j, W, P) {
      i && (i[p] = j.x, i[p + 1] = j.y, i[p + 2] = 0, o && (o[p] = 0, o[p + 1] = 0, o[p + 2] = 1), p += 3, r && (r[R] = W, r[R + 1] = P, R += 2)), O += 3;
    }
    function V(j, W, P, w, q) {
      c.copy(W).sub(j).normalize(), u.copy(P).sub(j).normalize();
      let ge = Math.PI;
      const Oe = c.dot(u);
      Math.abs(Oe) < 1 && (ge = Math.abs(Math.acos(Oe))), ge /= s, h.copy(W);
      for (let ze = 0, Ke = s - 1; ze < Ke; ze++)
        d.copy(h).rotateAround(j, ge), S(h, w, q), S(d, w, q), S(j, w, 0.5), h.copy(d);
      S(d, w, q), S(P, w, q), S(j, w, 0.5);
    }
    function ie() {
      S(x, X, 1), S(g, X, 0), S(m, z, 0), S(x, X, 1), S(m, z, 1), S(A, z, 0);
    }
    function J(j, W, P) {
      W ? j ? (S(x, X, 1), S(g, X, 0), S(m, z, 0), S(x, X, 1), S(m, z, 0), S(T, z, 1), S(m, P, 0), S(b, P, 0), S(T, P, 0.5)) : (S(x, X, 1), S(g, X, 0), S(A, z, 1), S(g, X, 0), S(T, z, 0), S(A, z, 1), S(A, P, 1), S(_, P, 0), S(T, P, 0.5)) : j ? (S(m, P, 0), S(b, P, 0), S(N, P, 0.5)) : (S(A, P, 1), S(_, P, 0), S(N, P, 0.5));
    }
    function te(j, W) {
      W && (j ? (S(x, X, 1), S(g, X, 0), S(m, z, 0), S(x, X, 1), S(m, z, 0), S(T, z, 1), S(m, X, 0), S(N, z, 0.5), S(T, z, 1), S(N, z, 0.5), S(b, X, 0), S(T, z, 1)) : (S(x, X, 1), S(g, X, 0), S(A, z, 1), S(g, X, 0), S(T, z, 0), S(A, z, 1), S(A, X, 1), S(T, z, 0), S(N, z, 0.5), S(N, z, 0.5), S(T, z, 0), S(_, X, 1)));
    }
    function K(j, W, P, w, q, ge) {
      switch (t.strokeLineCap) {
        case "round":
          q ? V(j, P, W, ge, 0.5) : V(j, W, P, ge, 0.5);
          break;
        case "square":
          if (q)
            c.subVectors(W, j), u.set(c.y, -c.x), h.addVectors(c, u).add(j), d.subVectors(u, c).add(j), w ? (h.toArray(i, 1 * 3), d.toArray(i, 0 * 3), d.toArray(i, 3 * 3)) : (h.toArray(i, 1 * 3), h.toArray(i, 3 * 3), d.toArray(i, 0 * 3));
          else {
            c.subVectors(P, j), u.set(c.y, -c.x), h.addVectors(c, u).add(j), d.subVectors(u, c).add(j);
            const Oe = i.length;
            w ? (h.toArray(i, Oe - 1 * 3), d.toArray(i, Oe - 2 * 3), d.toArray(i, Oe - 4 * 3)) : (h.toArray(i, Oe - 2 * 3), d.toArray(i, Oe - 1 * 3), d.toArray(i, Oe - 4 * 3));
          }
          break;
      }
    }
    function Te(j) {
      let W = false;
      for (let w = 1, q = j.length - 1; w < q; w++)
        if (j[w].distanceTo(j[w + 1]) < n) {
          W = true;
          break;
        }
      if (!W)
        return j;
      const P = [];
      P.push(j[0]);
      for (let w = 1, q = j.length - 1; w < q; w++)
        j[w].distanceTo(j[w + 1]) >= n && P.push(j[w]);
      return P.push(j[j.length - 1]), P;
    }
  }
};
var sn = /* @__PURE__ */ new WeakMap();
var Sa = class extends Loader {
  constructor(e) {
    super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
      position: "POSITION",
      normal: "NORMAL",
      color: "COLOR",
      uv: "TEX_COORD"
    }, this.defaultAttributeTypes = {
      position: "Float32Array",
      normal: "Float32Array",
      color: "Float32Array",
      uv: "Float32Array"
    };
  }
  setDecoderPath(e) {
    return this.decoderPath = e, this;
  }
  setDecoderConfig(e) {
    return this.decoderConfig = e, this;
  }
  setWorkerLimit(e) {
    return this.workerLimit = e, this;
  }
  load(e, t, s, n) {
    const i = new FileLoader(this.manager);
    i.setPath(this.path), i.setResponseType("arraybuffer"), i.setRequestHeader(this.requestHeader), i.setWithCredentials(this.withCredentials), i.load(
      e,
      (o) => {
        const r = {
          attributeIDs: this.defaultAttributeIDs,
          attributeTypes: this.defaultAttributeTypes,
          useUniqueIDs: false
        };
        this.decodeGeometry(o, r).then(t).catch(n);
      },
      s,
      n
    );
  }
  /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */
  decodeDracoFile(e, t, s, n) {
    const i = {
      attributeIDs: s || this.defaultAttributeIDs,
      attributeTypes: n || this.defaultAttributeTypes,
      useUniqueIDs: !!s
    };
    this.decodeGeometry(e, i).then(t);
  }
  decodeGeometry(e, t) {
    for (const a in t.attributeTypes) {
      const c = t.attributeTypes[a];
      c.BYTES_PER_ELEMENT !== void 0 && (t.attributeTypes[a] = c.name);
    }
    const s = JSON.stringify(t);
    if (sn.has(e)) {
      const a = sn.get(e);
      if (a.key === s)
        return a.promise;
      if (e.byteLength === 0)
        throw new Error(
          "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
        );
    }
    let n;
    const i = this.workerNextTaskID++, o = e.byteLength, r = this._getWorker(i, o).then((a) => (n = a, new Promise((c, u) => {
      n._callbacks[i] = { resolve: c, reject: u }, n.postMessage({ type: "decode", id: i, taskConfig: t, buffer: e }, [e]);
    }))).then((a) => this._createGeometry(a.geometry));
    return r.catch(() => true).then(() => {
      n && i && this._releaseTask(n, i);
    }), sn.set(e, {
      key: s,
      promise: r
    }), r;
  }
  _createGeometry(e) {
    const t = new BufferGeometry();
    e.index && t.setIndex(new BufferAttribute(e.index.array, 1));
    for (let s = 0; s < e.attributes.length; s++) {
      const n = e.attributes[s], i = n.name, o = n.array, r = n.itemSize;
      t.setAttribute(i, new BufferAttribute(o, r));
    }
    return t;
  }
  _loadLibrary(e, t) {
    const s = new FileLoader(this.manager);
    return s.setPath(this.decoderPath), s.setResponseType(t), s.setWithCredentials(this.withCredentials), new Promise((n, i) => {
      s.load(e, n, void 0, i);
    });
  }
  preload() {
    return this._initDecoder(), this;
  }
  _initDecoder() {
    if (this.decoderPending)
      return this.decoderPending;
    const e = typeof WebAssembly != "object" || this.decoderConfig.type === "js", t = [];
    return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then((s) => {
      const n = s[0];
      e || (this.decoderConfig.wasmBinary = s[1]);
      const i = Pa.toString(), o = [
        "/* draco decoder */",
        n,
        "",
        "/* worker */",
        i.substring(i.indexOf("{") + 1, i.lastIndexOf("}"))
      ].join(`
`);
      this.workerSourceURL = URL.createObjectURL(new Blob([o]));
    }), this.decoderPending;
  }
  _getWorker(e, t) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const n = new Worker(this.workerSourceURL);
        n._callbacks = {}, n._taskCosts = {}, n._taskLoad = 0, n.postMessage({ type: "init", decoderConfig: this.decoderConfig }), n.onmessage = function(i) {
          const o = i.data;
          switch (o.type) {
            case "decode":
              n._callbacks[o.id].resolve(o);
              break;
            case "error":
              n._callbacks[o.id].reject(o);
              break;
            default:
              console.error('THREE.DRACOLoader: Unexpected message, "' + o.type + '"');
          }
        }, this.workerPool.push(n);
      } else
        this.workerPool.sort(function(n, i) {
          return n._taskLoad > i._taskLoad ? -1 : 1;
        });
      const s = this.workerPool[this.workerPool.length - 1];
      return s._taskCosts[e] = t, s._taskLoad += t, s;
    });
  }
  _releaseTask(e, t) {
    e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t];
  }
  debug() {
    console.log(
      "Task load: ",
      this.workerPool.map((e) => e._taskLoad)
    );
  }
  dispose() {
    for (let e = 0; e < this.workerPool.length; ++e)
      this.workerPool[e].terminate();
    return this.workerPool.length = 0, this;
  }
};
function Pa() {
  let l, e;
  onmessage = function(o) {
    const r = o.data;
    switch (r.type) {
      case "init":
        l = r.decoderConfig, e = new Promise(function(u) {
          l.onModuleLoaded = function(h) {
            u({ draco: h });
          }, DracoDecoderModule(l);
        });
        break;
      case "decode":
        const a = r.buffer, c = r.taskConfig;
        e.then((u) => {
          const h = u.draco, d = new h.Decoder(), f = new h.DecoderBuffer();
          f.Init(new Int8Array(a), a.byteLength);
          try {
            const E = t(h, d, f, c), v = E.attributes.map((g) => g.array.buffer);
            E.index && v.push(E.index.array.buffer), self.postMessage({ type: "decode", id: r.id, geometry: E }, v);
          } catch (E) {
            console.error(E), self.postMessage({ type: "error", id: r.id, error: E.message });
          } finally {
            h.destroy(f), h.destroy(d);
          }
        });
        break;
    }
  };
  function t(o, r, a, c) {
    const u = c.attributeIDs, h = c.attributeTypes;
    let d, f;
    const E = r.GetEncodedGeometryType(a);
    if (E === o.TRIANGULAR_MESH)
      d = new o.Mesh(), f = r.DecodeBufferToMesh(a, d);
    else if (E === o.POINT_CLOUD)
      d = new o.PointCloud(), f = r.DecodeBufferToPointCloud(a, d);
    else
      throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
    if (!f.ok() || d.ptr === 0)
      throw new Error("THREE.DRACOLoader: Decoding failed: " + f.error_msg());
    const v = { index: null, attributes: [] };
    for (const g in u) {
      const x = self[h[g]];
      let M, y;
      if (c.useUniqueIDs)
        y = u[g], M = r.GetAttributeByUniqueId(d, y);
      else {
        if (y = r.GetAttributeId(d, o[u[g]]), y === -1)
          continue;
        M = r.GetAttribute(d, y);
      }
      v.attributes.push(n(o, r, d, g, x, M));
    }
    return E === o.TRIANGULAR_MESH && (v.index = s(o, r, d)), o.destroy(d), v;
  }
  function s(o, r, a) {
    const u = a.num_faces() * 3, h = u * 4, d = o._malloc(h);
    r.GetTrianglesUInt32Array(a, h, d);
    const f = new Uint32Array(o.HEAPF32.buffer, d, u).slice();
    return o._free(d), { array: f, itemSize: 1 };
  }
  function n(o, r, a, c, u, h) {
    const d = h.num_components(), E = a.num_points() * d, v = E * u.BYTES_PER_ELEMENT, g = i(o, u), x = o._malloc(v);
    r.GetAttributeDataArrayForAllPoints(a, h, g, v, x);
    const M = new u(o.HEAPF32.buffer, x, E).slice();
    return o._free(x), {
      name: c,
      array: M,
      itemSize: d
    };
  }
  function i(o, r) {
    switch (r) {
      case Float32Array:
        return o.DT_FLOAT32;
      case Int8Array:
        return o.DT_INT8;
      case Int16Array:
        return o.DT_INT16;
      case Int32Array:
        return o.DT_INT32;
      case Uint8Array:
        return o.DT_UINT8;
      case Uint16Array:
        return o.DT_UINT16;
      case Uint32Array:
        return o.DT_UINT32;
    }
  }
}
var Oa = ["args", "center"];
var gc = defineComponent({
  __name: "Text3D",
  props: {
    font: {},
    text: {},
    size: { default: 0.5 },
    height: { default: 0.2 },
    curveSegments: { default: 5 },
    bevelEnabled: { type: Boolean, default: true },
    bevelThickness: { default: 0.05 },
    bevelSize: { default: 0.02 },
    bevelOffset: { default: 0 },
    bevelSegments: { default: 4 },
    center: { type: Boolean, default: false },
    needUpdates: { type: Boolean, default: false }
  },
  async setup(l, { expose: e }) {
    let t, s;
    const n = l, {
      center: i,
      font: o,
      text: r,
      needUpdates: a,
      size: c,
      height: u,
      curveSegments: h,
      bevelEnabled: d,
      bevelThickness: f,
      bevelSize: E,
      bevelOffset: v,
      bevelSegments: g
    } = toRefs(n), { extend: x } = nt();
    x({ TextGeometry: Zn });
    const M = new Ea(), y = useSlots(), m = computed(() => {
      var T;
      return r != null && r.value ? r.value : y.default ? (T = y.default()[0].children) == null ? void 0 : T.trim() : a.value ? "" : "TresJS";
    }), A = shallowRef();
    e({
      value: A
    });
    const b = ([t, s] = withAsyncContext(() => new Promise((T, L2) => {
      try {
        typeof o.value == "string" ? M.load(o.value, (B) => {
          T(B);
        }) : T(o.value);
      } catch (B) {
        L2(console.error("cientos", B));
      }
    })), t = await t, s(), t), _ = computed(() => ({
      font: b,
      size: toValue(c),
      height: toValue(u),
      curveSegments: toValue(h),
      bevelEnabled: toValue(d),
      bevelThickness: toValue(f),
      bevelSize: toValue(E),
      bevelOffset: toValue(v),
      bevelSegments: toValue(g)
    }));
    return watchEffect(() => {
      A.value && a.value && (A.value.geometry.dispose(), A.value.geometry = new Zn(m.value, _.value), i.value && A.value.geometry.center());
    }), (T, L2) => unref(o) ? (openBlock(), createElementBlock("TresMesh", {
      key: 0,
      ref_key: "text3DRef",
      ref: A
    }, [
      m.value ? (openBlock(), createElementBlock("TresTextGeometry", {
        key: 0,
        args: [m.value, _.value],
        center: unref(i)
      }, null, 8, Oa)) : createCommentVNode("", true),
      renderSlot(T.$slots, "default")
    ], 512)) : createCommentVNode("", true);
  }
});
function yc(l, e) {
  const t = ref(e), s = new AnimationMixer(t.value), n = shallowReactive({});
  l.forEach((o) => {
    const r = s.clipAction(o, t.value);
    n[o.name] = r;
  });
  const { onLoop: i } = ae();
  return i(({ delta: o }) => {
    s.update(o);
  }), {
    actions: n,
    mixer: s
  };
}
var _c = defineComponent({
  __name: "Levioso",
  props: {
    speed: { default: 1 },
    rotationFactor: { default: 1 },
    floatFactor: { default: 1 },
    range: { default: () => [-0.1, 0.1] }
  },
  setup(l, { expose: e }) {
    const t = l, s = shallowRef();
    e({
      value: s
    });
    const { onLoop: n } = ae(), i = ref(Math.random() * 1e4);
    return n(({ elapsed: o }) => {
      var c, u;
      if (!s.value)
        return;
      const r = i.value + o;
      s.value.rotation.x = Math.cos(r / 4 * t.speed) / 8 * t.rotationFactor, s.value.rotation.y = Math.sin(r / 4 * t.speed) / 8 * t.rotationFactor, s.value.rotation.z = Math.sin(r / 4 * t.speed) / 20 * t.rotationFactor;
      let a = Math.sin(r / 4 * t.speed) / 10;
      a = MathUtils.mapLinear(a, -0.1, 0.1, ((c = t.range) == null ? void 0 : c[0]) ?? -0.1, ((u = t.range) == null ? void 0 : u[1]) ?? 0.1), s.value.position.y = a * t.floatFactor;
    }), (o, r) => (openBlock(), createElementBlock("TresGroup", mergeProps(o.$attrs, {
      ref_key: "groupRef",
      ref: s
    }), [
      renderSlot(o.$slots, "default")
    ], 16));
  }
});
function ji(l) {
  return getCurrentScope() ? (onScopeDispose(l), true) : false;
}
function et(l) {
  return typeof l == "function" ? l() : unref(l);
}
var La = typeof window < "u";
var jt = () => {
};
function Yi(l, e) {
  function t(...s) {
    return new Promise((n, i) => {
      Promise.resolve(l(() => e.apply(this, s), { fn: e, thisArg: this, args: s })).then(n).catch(i);
    });
  }
  return t;
}
function Ra(l, e = {}) {
  let t, s, n = jt;
  const i = (r) => {
    clearTimeout(r), n(), n = jt;
  };
  return (r) => {
    const a = et(l), c = et(e.maxWait);
    return t && i(t), a <= 0 || c !== void 0 && c <= 0 ? (s && (i(s), s = null), Promise.resolve(r())) : new Promise((u, h) => {
      n = e.rejectOnCancel ? h : u, c && !s && (s = setTimeout(() => {
        t && i(t), s = null, u(r());
      }, c)), t = setTimeout(() => {
        s && i(s), s = null, u(r());
      }, a);
    });
  };
}
function Ca(l, e = true, t = true, s = false) {
  let n = 0, i, o = true, r = jt, a;
  const c = () => {
    i && (clearTimeout(i), i = void 0, r(), r = jt);
  };
  return (h) => {
    const d = et(l), f = Date.now() - n, E = () => a = h();
    return c(), d <= 0 ? (n = Date.now(), E()) : (f > d && (t || !o) ? (n = Date.now(), E()) : e && (a = new Promise((v, g) => {
      r = s ? g : v, i = setTimeout(() => {
        n = Date.now(), o = true, v(E()), c();
      }, Math.max(0, d - f));
    })), !t && !i && (i = setTimeout(() => o = true, d)), o = false, a);
  };
}
function Ia(l, e = 200, t = {}) {
  return Yi(
    Ra(e, t),
    l
  );
}
function Da(l, e = 200, t = false, s = true, n = false) {
  return Yi(
    Ca(e, t, s, n),
    l
  );
}
function ka(l, e = true) {
  getCurrentInstance() ? onMounted(l) : e ? l() : nextTick(l);
}
function Fa(l) {
  var e;
  const t = et(l);
  return (e = t == null ? void 0 : t.$el) != null ? e : t;
}
var Yt = La ? window : void 0;
function Fe(...l) {
  let e, t, s, n;
  if (typeof l[0] == "string" || Array.isArray(l[0]) ? ([t, s, n] = l, e = Yt) : [e, t, s, n] = l, !e)
    return jt;
  Array.isArray(t) || (t = [t]), Array.isArray(s) || (s = [s]);
  const i = [], o = () => {
    i.forEach((u) => u()), i.length = 0;
  }, r = (u, h, d, f) => (u.addEventListener(h, d, f), () => u.removeEventListener(h, d, f)), a = watch(
    () => [Fa(e), et(n)],
    ([u, h]) => {
      o(), u && i.push(
        ...t.flatMap((d) => s.map((f) => r(u, d, f, h)))
      );
    },
    { immediate: true, flush: "post" }
  ), c = () => {
    a(), o();
  };
  return ji(c), c;
}
function Ua(l) {
  return typeof l == "function" ? l : typeof l == "string" ? (e) => e.key === l : Array.isArray(l) ? (e) => l.includes(e.key) : () => true;
}
function Ft(...l) {
  let e, t, s = {};
  l.length === 3 ? (e = l[0], t = l[1], s = l[2]) : l.length === 2 ? typeof l[1] == "object" ? (e = true, t = l[0], s = l[1]) : (e = l[0], t = l[1]) : (e = true, t = l[0]);
  const {
    target: n = Yt,
    eventName: i = "keydown",
    passive: o = false,
    dedupe: r = false
  } = s, a = Ua(e);
  return Fe(n, i, (u) => {
    u.repeat && et(r) || a(u) && t(u);
  }, o);
}
function Ba() {
  const l = ref(false);
  return getCurrentInstance() && onMounted(() => {
    l.value = true;
  }), l;
}
function Na(l) {
  const e = Ba();
  return computed(() => (e.value, !!l()));
}
function za(l, e = {}) {
  const { window: t = Yt } = e, s = Na(() => t && "matchMedia" in t && typeof t.matchMedia == "function");
  let n;
  const i = ref(false), o = (c) => {
    i.value = c.matches;
  }, r = () => {
    n && ("removeEventListener" in n ? n.removeEventListener("change", o) : n.removeListener(o));
  }, a = watchEffect(() => {
    s.value && (r(), n = t.matchMedia(et(l)), "addEventListener" in n ? n.addEventListener("change", o) : n.addListener(o), i.value = n.matches);
  });
  return ji(() => {
    a(), r(), n = void 0;
  }), i;
}
var qn = 1;
function Ha(l, e = {}) {
  const {
    throttle: t = 0,
    idle: s = 200,
    onStop: n = jt,
    onScroll: i = jt,
    offset: o = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    },
    eventListenerOptions: r = {
      capture: false,
      passive: true
    },
    behavior: a = "auto",
    window: c = Yt
  } = e, u = ref(0), h = ref(0), d = computed({
    get() {
      return u.value;
    },
    set(b) {
      E(b, void 0);
    }
  }), f = computed({
    get() {
      return h.value;
    },
    set(b) {
      E(void 0, b);
    }
  });
  function E(b, _) {
    var T, L2, B;
    if (!c)
      return;
    const k = et(l);
    k && ((B = k instanceof Document ? c.document.body : k) == null || B.scrollTo({
      top: (T = et(_)) != null ? T : f.value,
      left: (L2 = et(b)) != null ? L2 : d.value,
      behavior: et(a)
    }));
  }
  const v = ref(false), g = reactive({
    left: true,
    right: false,
    top: true,
    bottom: false
  }), x = reactive({
    left: false,
    right: false,
    top: false,
    bottom: false
  }), M = (b) => {
    v.value && (v.value = false, x.left = false, x.right = false, x.top = false, x.bottom = false, n(b));
  }, y = Ia(M, t + s), m = (b) => {
    if (!c)
      return;
    const _ = b === c ? b.document.documentElement : b === c.document ? b.documentElement : b, { display: T, flexDirection: L2 } = getComputedStyle(_), B = _.scrollLeft;
    x.left = B < u.value, x.right = B > u.value;
    const k = Math.abs(B) <= 0 + (o.left || 0), N = Math.abs(B) + _.clientWidth >= _.scrollWidth - (o.right || 0) - qn;
    T === "flex" && L2 === "row-reverse" ? (g.left = N, g.right = k) : (g.left = k, g.right = N), u.value = B;
    let $ = _.scrollTop;
    b === c.document && !$ && ($ = c.document.body.scrollTop), x.top = $ < h.value, x.bottom = $ > h.value;
    const Q = Math.abs($) <= 0 + (o.top || 0), Z = Math.abs($) + _.clientHeight >= _.scrollHeight - (o.bottom || 0) - qn;
    T === "flex" && L2 === "column-reverse" ? (g.top = Z, g.bottom = Q) : (g.top = Q, g.bottom = Z), h.value = $;
  }, A = (b) => {
    if (!c)
      return;
    const _ = b.target === c.document ? b.target.documentElement : b.target;
    m(_), v.value = true, y(b), i(b);
  };
  return Fe(
    l,
    "scroll",
    t ? Da(A, t, true, false) : A,
    r
  ), Fe(
    l,
    "scrollend",
    M,
    r
  ), {
    x: d,
    y: f,
    isScrolling: v,
    arrivedState: g,
    directions: x,
    measure() {
      const b = et(l);
      c && b && m(b);
    }
  };
}
var Va = {
  page: (l) => [l.pageX, l.pageY],
  client: (l) => [l.clientX, l.clientY],
  screen: (l) => [l.screenX, l.screenY],
  movement: (l) => l instanceof Touch ? null : [l.movementX, l.movementY]
};
function Ga(l = {}) {
  const {
    type: e = "page",
    touch: t = true,
    resetOnTouchEnds: s = false,
    initialValue: n = { x: 0, y: 0 },
    window: i = Yt,
    target: o = i,
    eventFilter: r
  } = l, a = ref(n.x), c = ref(n.y), u = ref(null), h = typeof e == "function" ? e : Va[e], d = (x) => {
    const M = h(x);
    M && ([a.value, c.value] = M, u.value = "mouse");
  }, f = (x) => {
    if (x.touches.length > 0) {
      const M = h(x.touches[0]);
      M && ([a.value, c.value] = M, u.value = "touch");
    }
  }, E = () => {
    a.value = n.x, c.value = n.y;
  }, v = r ? (x) => r(() => d(x), {}) : (x) => d(x), g = r ? (x) => r(() => f(x), {}) : (x) => f(x);
  if (o) {
    const x = { passive: true };
    Fe(o, ["mousemove", "dragover"], v, x), t && e !== "movement" && (Fe(o, ["touchstart", "touchmove"], g, x), s && Fe(o, "touchend", E, x));
  }
  return {
    x: a,
    y: c,
    sourceType: u
  };
}
function ja({ window: l = Yt } = {}) {
  if (!l)
    return {
      x: ref(0),
      y: ref(0)
    };
  const e = ref(l.scrollX), t = ref(l.scrollY);
  return Fe(
    l,
    "scroll",
    () => {
      e.value = l.scrollX, t.value = l.scrollY;
    },
    {
      capture: false,
      passive: true
    }
  ), { x: e, y: t };
}
function Xi(l = {}) {
  const {
    window: e = Yt,
    initialWidth: t = Number.POSITIVE_INFINITY,
    initialHeight: s = Number.POSITIVE_INFINITY,
    listenOrientation: n = true,
    includeScrollbar: i = true
  } = l, o = ref(t), r = ref(s), a = () => {
    e && (i ? (o.value = e.innerWidth, r.value = e.innerHeight) : (o.value = e.document.documentElement.clientWidth, r.value = e.document.documentElement.clientHeight));
  };
  if (a(), ka(a), Fe("resize", a, { passive: true }), n) {
    const c = za("(orientation: portrait)");
    watch(c, () => a());
  }
  return { width: o, height: r };
}
var vc = defineComponent({
  __name: "MouseParallax",
  props: {
    disabled: { type: Boolean, default: false },
    factor: { default: 2.5 },
    ease: { default: 0.1 }
  },
  setup(l) {
    const e = l, { camera: t } = nt(), { disabled: s, factor: n, ease: i } = toRefs(e), { x: o, y: r } = Ga(), { width: a, height: c } = Xi(), u = ref(), h = computed(() => (o.value / a.value - 0.5) * n.value), d = computed(() => -(r.value / c.value - 0.5) * n.value), { onLoop: f } = ae();
    return f(({ delta: E }) => {
      s.value || !u.value || (u.value.position.x += (h.value - u.value.position.x) * i.value * E, u.value.position.y += (d.value - u.value.position.y) * i.value * E);
    }), watch(
      () => u.value,
      (E) => E == null ? void 0 : E.add(t.value)
    ), (E, v) => (openBlock(), createElementBlock("TresGroup", {
      ref_key: "cameraGroupRef",
      ref: u
    }, null, 512));
  }
});
var nn = {
  sunset: "venice/venice_sunset_4k.hdr"
};
async function Ya({
  files: l = ["/px.png", "/nx.png", "/py.png", "/ny.png", "/pz.png", "/nz.png"],
  blur: e = 0,
  background: t = false,
  path: s = "/",
  preset: n = void 0
}) {
  const { scene: i } = nt();
  if (n) {
    if (!(n in nn))
      throw new Error(`Preset must be one of: ${Object.keys(nn).join(", ")}`);
    l = nn[n], s = "https://raw.githubusercontent.com/Tresjs/assets/main/textures/hdr/";
  }
  const o = Array.isArray(l), a = await gt(
    o ? CubeTextureLoader : Ma,
    o ? [l] : l,
    (u) => {
      s && u.setPath(s);
    }
  ), c = o ? a[0] : a;
  return c && (c.mapping = o ? CubeReflectionMapping : EquirectangularReflectionMapping, c.colorSpace = SRGBColorSpace), i.value && (i.value.environment = c, t && (i.value.background = c), e && (i.value.backgroundBlurriness = e | 0)), c;
}
var Os = null;
function Xa(l, e) {
  return (t) => {
    e && e(t), l.draco && (Os || (Os = new Sa()), Os.setDecoderPath(l.decoderPath || "https://www.gstatic.com/draco/versioned/decoders/1.4.3/"), t.setDRACOLoader(Os));
  };
}
async function Za(l, e = {
  draco: false
}, t) {
  return await gt(vr, l, Xa(e, t));
}
var Tc = defineComponent({
  __name: "component",
  props: {
    path: {},
    draco: { type: Boolean, default: false },
    decoderPath: { default: "https://www.gstatic.com/draco/versioned/decoders/1.4.1/" }
  },
  async setup(l, { expose: e }) {
    let t, s;
    const n = l, i = ref();
    e({
      value: i
    });
    const { scene: o } = ([t, s] = withAsyncContext(() => Za(n.path, {
      draco: n.draco,
      decoderPath: n.decoderPath
    })), t = await t, s(), t);
    return (r, a) => {
      const c = resolveComponent("primitive");
      return openBlock(), createBlock(c, mergeProps({
        ref_key: "modelRef",
        ref: i,
        object: unref(o)
      }, r.$attrs), null, 16, ["object"]);
    };
  }
});
async function $a(l) {
  return await gt(aa, l);
}
var Ec = defineComponent({
  __name: "component",
  props: {
    path: {}
  },
  async setup(l, { expose: e }) {
    let t, s;
    const n = l, i = ref();
    e({
      value: i
    });
    const o = ([t, s] = withAsyncContext(() => $a(n.path)), t = await t, s(), t);
    return (r, a) => {
      const c = resolveComponent("primitive");
      return openBlock(), createBlock(c, mergeProps({
        ref_key: "modelRef",
        ref: i,
        object: unref(o)
      }, r.$attrs), null, 16, ["object"]);
    };
  }
});
var Ka = ["geometry", "render-order"];
var xc = defineComponent({
  __name: "component",
  props: {
    src: {},
    skipStrokes: { type: Boolean, default: false },
    skipFills: { type: Boolean, default: false },
    fillMaterial: {},
    strokeMaterial: {},
    fillMeshProps: {},
    strokeMeshProps: {},
    depth: { default: "renderOrder" }
  },
  setup(l, { expose: e }) {
    const t = l, {
      src: s,
      skipStrokes: n,
      skipFills: i,
      fillMaterial: o,
      strokeMaterial: r,
      fillMeshProps: a,
      strokeMeshProps: c,
      depth: u
    } = toRefs(t), h = shallowRef(), d = shallowRef([]), f = shallowRef([]);
    e({ value: h }), watchEffect(async () => E(s.value).then((x) => f.value = x.paths)), watch([i, n, o, r, f], g);
    async function E(x) {
      const M = x.startsWith("<svg") ? encodeURI(`data:image/svg+xml;utf8,${x}`) : x;
      return gt(ps, M);
    }
    onUnmounted(v);
    function v() {
      d.value.forEach((x) => x.geometry.dispose());
    }
    function g() {
      var A, b, _;
      v();
      const x = [], [M, y] = (() => {
        const T = { flat: false, renderOrder: false, offsetZ: true }, L2 = { flat: 0, renderOrder: 0, offsetZ: 0.025 }, B = u.value;
        return typeof B == "number" ? [true, B] : [T[B], L2[B]];
      })();
      let m = 0;
      for (const T of f.value) {
        const L2 = ((A = T.userData) == null ? void 0 : A.style) ?? {}, B = Object.assign(
          {
            color: L2.fill,
            opacity: L2.fillOpacity,
            transparent: true,
            side: DoubleSide,
            depthWrite: M
          },
          t.fillMaterial
        );
        if (!i.value && L2.fill !== void 0 && L2.fill !== "none")
          for (const k of ps.createShapes(T)) {
            const N = new ShapeGeometry(k);
            N.scale(1, -1, 1), y && N.translate(0, 0, m++ * y), x.push({
              geometry: N,
              material: B,
              isStroke: false
            });
          }
        if (!n.value && L2.stroke !== void 0 && L2.stroke !== "none") {
          const k = Object.assign(
            {
              color: (b = T.userData) == null ? void 0 : b.style.stroke,
              opacity: (_ = T.userData) == null ? void 0 : _.style.strokeOpacity,
              transparent: true,
              side: DoubleSide,
              depthWrite: M
            },
            t.strokeMaterial
          );
          for (const N of T.subPaths) {
            const $ = N.getPoints().map((Z) => new Vector2(Z.x, -Z.y)), Q = ps.pointsToStroke($, L2 || "none");
            y && Q.translate(0, 0, m++ * y), x.push({
              geometry: Q,
              material: k,
              isStroke: true
            });
          }
        }
      }
      d.value = x;
    }
    return (x, M) => (openBlock(), createElementBlock("TresGroup", {
      ref_key: "svgRef",
      ref: h
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(d.value, ({ geometry: y, material: m, isStroke: A }, b) => (openBlock(), createElementBlock("TresMesh", mergeProps({
        key: `${b}`
      }, A ? unref(c) : unref(a), {
        geometry: y,
        "render-order": unref(u) === "renderOrder" ? b : 0
      }), [
        createBaseVNode("TresMeshBasicMaterial", normalizeProps(guardReactiveProps(m)), null, 16)
      ], 16, Ka))), 128))
    ], 512));
  }
});
var Jn = "[TresJS - Cientos   ] ";
function Rn() {
  function l(s, n) {
    console.error(`${Jn} ${s}`, n || "");
  }
  function e(s) {
    console.warn(`${Jn} ${s}`);
  }
  function t(s, n) {
  }
  return {
    logError: l,
    logWarning: e,
    logMessage: t
  };
}
var on = 0;
function wc() {
  const l = ref(false), e = ref(0), t = ref([]), { logError: s } = Rn();
  return new Promise((n) => {
    DefaultLoadingManager.onStart = () => {
      l.value = false;
    }, DefaultLoadingManager.onLoad = () => {
      l.value = true;
    }, DefaultLoadingManager.onProgress = (i, o, r) => {
      o === r && (on = r, l.value = true, t.value.push(i)), e.value = Math.round((o - on) / (r - on) * 100 || 100, 2);
    }, DefaultLoadingManager.onError = (i) => {
      s("Error loading assets", new Error(i)), l.value = true;
    }, n({
      items: t,
      hasFinishLoading: l,
      progress: e
    });
  });
}
async function bc(l, e) {
  const { logError: t } = Rn();
  if (!l)
    return t("Error no path provided");
  const { unsuspend: s, start: n, crossOrigin: i, muted: o, loop: r, ...a } = {
    unsuspend: "loadedmetadata",
    crossOrigin: "Anonymous",
    muted: true,
    loop: true,
    start: true,
    playsInline: true,
    ...e
  };
  function c() {
    return new Promise((u, h) => {
      const d = Object.assign(document.createElement("video"), {
        src: typeof l == "string" && l || void 0,
        crossOrigin: i,
        loop: r,
        muted: o,
        autoplay: true,
        ...a
      }), f = new VideoTexture(d);
      return d.addEventListener(s, () => u(f)), d.addEventListener("error", () => h()), f;
    });
  }
  try {
    const u = await c();
    return n && u.image && u.image.play(), u;
  } catch {
    t("Error loading resource");
  }
}
var Wa = ["target", "auto-rotate", "auto-rotate-speed", "enable-damping", "damping-factor", "enable-pan", "key-pan-speed", "keys", "max-azimuth-angle", "min-azimuth-angle", "max-polar-angle", "min-polar-angle", "min-distance", "max-distance", "min-zoom", "max-zoom", "touches", "enable-zoom", "zoom-speed", "enable-rotate", "rotate-speed", "args"];
var Ac = defineComponent({
  __name: "OrbitControls",
  props: {
    makeDefault: { type: Boolean, default: false },
    camera: {},
    domElement: {},
    target: { default: () => [0, 0, 0] },
    enableDamping: { type: Boolean, default: false },
    dampingFactor: { default: 0.05 },
    autoRotate: { type: Boolean, default: false },
    autoRotateSpeed: { default: 2 },
    enablePan: { type: Boolean, default: true },
    keyPanSpeed: { default: 7 },
    keys: {},
    maxAzimuthAngle: { default: 1 / 0 },
    minAzimuthAngle: { default: -1 / 0 },
    maxPolarAngle: { default: Math.PI },
    minPolarAngle: { default: 0 },
    minDistance: { default: 0 },
    maxDistance: { default: 1 / 0 },
    minZoom: { default: 0 },
    maxZoom: { default: 1 / 0 },
    touches: { default: () => ({ ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN }) },
    enableZoom: { type: Boolean, default: true },
    zoomSpeed: { default: 1 },
    enableRotate: { type: Boolean, default: true },
    rotateSpeed: { default: 1 }
  },
  emits: ["change", "start", "end"],
  setup(l, { emit: e }) {
    const t = l, {
      makeDefault: s,
      autoRotate: n,
      autoRotateSpeed: i,
      enableDamping: o,
      dampingFactor: r,
      enablePan: a,
      keyPanSpeed: c,
      maxAzimuthAngle: u,
      minAzimuthAngle: h,
      maxPolarAngle: d,
      minPolarAngle: f,
      minDistance: E,
      maxDistance: v,
      minZoom: g,
      maxZoom: x,
      enableZoom: M,
      zoomSpeed: y,
      enableRotate: m,
      touches: A,
      rotateSpeed: b,
      target: _
    } = toRefs(t), { camera: T, renderer: L2, extend: B, controls: k } = nt(), N = ref(null);
    B({ OrbitControls: Fi }), watch(N, (Z) => {
      $(), Z && s.value ? k.value = Z : k.value = null;
    });
    function $() {
      Fe(N.value, "change", () => e("change", N.value)), Fe(N.value, "start", () => e("start", N.value)), Fe(N.value, "end", () => e("end", N.value));
    }
    const { onLoop: Q } = ae();
    return Q(() => {
      N.value && (o.value || n.value) && N.value.update();
    }), onUnmounted(() => {
      N.value && N.value.dispose();
    }), (Z, me) => (Z.camera || unref(T)) && (Z.domElement || unref(L2)) ? (openBlock(), createElementBlock("TresOrbitControls", {
      key: 0,
      ref_key: "controlsRef",
      ref: N,
      target: unref(_),
      "auto-rotate": unref(n),
      "auto-rotate-speed": unref(i),
      "enable-damping": unref(o),
      "damping-factor": unref(r),
      "enable-pan": unref(a),
      "key-pan-speed": unref(c),
      keys: Z.keys,
      "max-azimuth-angle": unref(u),
      "min-azimuth-angle": unref(h),
      "max-polar-angle": unref(d),
      "min-polar-angle": unref(f),
      "min-distance": unref(E),
      "max-distance": unref(v),
      "min-zoom": unref(g),
      "max-zoom": unref(x),
      touches: unref(A),
      "enable-zoom": unref(M),
      "zoom-speed": unref(y),
      "enable-rotate": unref(m),
      "rotate-speed": unref(b),
      args: [Z.camera || unref(T), Z.domElement || unref(L2).domElement]
    }, null, 8, Wa)) : createCommentVNode("", true);
  }
});
var Qa = 5;
var qa = 6;
var Ja = 0.3;
var Mc = defineComponent({
  __name: "KeyboardControls",
  props: {
    forward: { default: () => ["w", "W"] },
    back: { default: () => ["s", "S"] },
    left: { default: () => ["a", "A"] },
    right: { default: () => ["d", "D"] },
    jump: { default: () => [" "] },
    gravity: { default: 9.8 },
    moveSpeed: { default: 0.1 },
    headBobbing: { type: Boolean, default: false },
    is2D: { type: Boolean, default: false }
  },
  setup(l) {
    var B;
    const e = l, { forward: t, back: s, left: n, right: i, jump: o, gravity: r, moveSpeed: a, headBobbing: c, is2D: u } = toRefs(e), { camera: h, controls: d } = nt(), f = ref(0), E = ref(0), v = ref(false), g = ref(false), x = ref(0), M = shallowRef(), y = u.value ? "y" : "z", m = ((B = h.value.position) == null ? void 0 : B.y) || 0;
    Ft(
      t.value,
      () => {
        v.value = true, E.value = a.value;
      },
      { eventName: "keydown" }
    ), Ft(
      s.value,
      () => {
        v.value = true, E.value = -a.value;
      },
      { eventName: "keydown" }
    ), Ft(
      [...t.value, ...s.value],
      () => {
        v.value = false, E.value = 0;
      },
      { eventName: "keyup" }
    ), Ft(
      n.value,
      () => {
        v.value = true, f.value = -a.value;
      },
      { eventName: "keydown" }
    ), Ft(
      i.value,
      () => {
        v.value = true, f.value = a.value;
      },
      { eventName: "keydown" }
    ), Ft(
      [...n.value, ...i.value],
      () => {
        v.value = false, f.value = 0;
      },
      { eventName: "keyup" }
    ), Ft(o.value, () => {
      g.value || (x.value = Date.now()), g.value = true;
    });
    const A = (k) => v.value ? Math.sin(k * Qa) * Ja + m : m, b = () => (Date.now() - x.value) / 1e3 * 3, _ = (k) => m + qa * k - 0.5 * r.value * k ** 2, T = () => {
      if (g.value) {
        const k = _(b());
        return k <= m && (g.value = false), k;
      }
      return 0;
    }, { onLoop: L2 } = ae();
    return L2(({ elapsed: k }) => {
      var N;
      d.value instanceof bn && ((N = d.value) != null && N.isLocked) ? (d.value.moveForward(E.value), d.value.moveRight(f.value), h.value.position && (h.value.position.y = c.value ? A(k) : m, h.value.position.y += T())) : M.value.children.length > 0 && !(d.value instanceof bn) && (M.value.position.x += f.value, M.value.position[y] += u.value ? E.value : -E.value);
    }), (k, N) => (openBlock(), createElementBlock("TresGroup", {
      ref_key: "wrapperRef",
      ref: M
    }, [
      renderSlot(k.$slots, "default")
    ], 512));
  }
});
var el = ["object", "args", "mode", "enabled", "axis", "translation-snap", "rotation-snap", "scale-snap", "space", "size", "show-x", "show-y", "show-z"];
var Sc = defineComponent({
  __name: "TransformControls",
  props: {
    object: {},
    mode: { default: "translate" },
    enabled: { type: Boolean, default: true },
    axis: { default: "XYZ" },
    translationSnap: {},
    rotationSnap: {},
    scaleSnap: {},
    space: { default: "world" },
    size: { default: 1 },
    showX: { type: Boolean, default: true },
    showY: { type: Boolean, default: true },
    showZ: { type: Boolean, default: true }
  },
  emits: ["dragging", "change", "mouseDown", "mouseUp", "objectChange"],
  setup(l, { emit: e }) {
    const t = l, { object: s, mode: n, enabled: i, axis: o, translationSnap: r, rotationSnap: a, scaleSnap: c, space: u, size: h, showX: d, showY: f, showZ: E } = toRefs(t), v = shallowRef(), { controls: g, camera: x, renderer: M, extend: y } = nt();
    y({ TransformControls: lr });
    const m = (b) => {
      g.value && (g.value.enabled = !b.value), e("dragging", b.value);
    };
    function A() {
      Fe(v.value, "change", () => e("change")), Fe(v.value, "dragging-changed", m), Fe(v.value, "mouseDown", () => e("mouseDown")), Fe(v.value, "mouseUp", () => e("mouseUp")), Fe(v.value, "objectChange", () => e("objectChange"));
    }
    return watchEffect(() => {
      v.value && A();
    }), onUnmounted(() => {
      v.value && v.value.dispose();
    }), (b, _) => unref(x) && unref(M) ? (openBlock(), createElementBlock("TresTransformControls", {
      key: 0,
      ref_key: "controlsRef",
      ref: v,
      object: unref(s),
      args: [unref(x), unref(M).domElement],
      mode: unref(n),
      enabled: unref(i),
      axis: unref(o),
      "translation-snap": unref(r),
      "rotation-snap": unref(a),
      "scale-snap": unref(c),
      space: unref(u),
      size: unref(h),
      "show-x": unref(d),
      "show-y": unref(f),
      "show-z": unref(E),
      visible: true
    }, null, 8, el)) : createCommentVNode("", true);
  }
});
var tl = ["args"];
var Pc = defineComponent({
  __name: "PointerLockControls",
  props: {
    makeDefault: { type: Boolean, default: false },
    camera: {},
    domElement: {},
    selector: {}
  },
  emits: ["isLock"],
  setup(l, { expose: e, emit: t }) {
    const s = l, { camera: n, renderer: i, extend: o, controls: r } = nt(), a = ref(null);
    let c;
    o({ PointerLockControls: bn });
    const u = (h) => {
      t("isLock", h);
    };
    return watch(a, (h) => {
      h && s.makeDefault ? r.value = h : r.value = null;
      const d = document.getElementById(s.selector || "");
      c = d || i.value.domElement, Fe(c, "click", () => {
        var f, E, v;
        (f = r.value) == null || f.lock(), (E = r.value) == null || E.addEventListener("lock", () => u(true)), (v = r.value) == null || v.addEventListener("unlock", () => u(false));
      });
    }), onUnmounted(() => {
      var h, d;
      (h = r.value) == null || h.removeEventListener("lock", () => u(true)), (d = r.value) == null || d.removeEventListener("unlock", () => u(false)), a.value && a.value.dispose();
    }), e({
      value: r
    }), (h, d) => (h.camera || unref(n)) && (h.domElement || unref(i)) ? (openBlock(), createElementBlock("TresPointerLockControls", {
      key: 0,
      ref_key: "controlsRef",
      ref: a,
      args: [h.camera || unref(n), h.domElement || unref(i).domElement]
    }, null, 8, tl)) : createCommentVNode("", true);
  }
});
var sl = ["args"];
var Oc = defineComponent({
  __name: "MapControls",
  props: {
    makeDefault: { type: Boolean, default: false },
    camera: {},
    domElement: {}
  },
  setup(l) {
    const e = l, { camera: t, renderer: s, extend: n, controls: i } = nt(), o = ref(null);
    return n({ MapControls: _r }), watch(i, (r) => {
      r && e.makeDefault ? i.value = r : i.value = null;
    }), onUnmounted(() => {
      o.value && o.value.dispose();
    }), (r, a) => (r.camera || unref(t)) && (r.domElement || unref(s)) ? (openBlock(), createElementBlock("TresMapControls", {
      key: 0,
      ref_key: "controlsRef",
      ref: o,
      args: [r.camera || unref(t), r.domElement || unref(s).domElement]
    }, null, 8, sl)) : createCommentVNode("", true);
  }
});
var Lc = defineComponent({
  __name: "ScrollControls",
  props: {
    pages: { default: 4 },
    distance: { default: 4 },
    smoothScroll: { default: 0.1 },
    horizontal: { type: Boolean, default: false },
    htmlScroll: { type: Boolean, default: false }
  },
  emits: ["update:modelValue"],
  setup(l, { emit: e }) {
    const t = l, { logWarning: s } = L();
    t.smoothScroll < 0 && s("SmoothControl must be greater than zero"), t.pages < 0 && s("Pages must be greater than zero");
    const { camera: n, controls: i, renderer: o } = nt(), r = shallowRef(), a = document.createElement("div"), { y: c } = ja(), { x: u, y: h, isScrolling: d } = Ha(a), { height: f, width: E } = Xi();
    let v = 0;
    const g = ref(false), x = ref(0), M = ref(0), y = ref(0), m = t.horizontal ? "x" : "y", A = watch(
      n,
      (_) => {
        if (g.value) {
          A();
          return;
        }
        v = t.horizontal ? (_ == null ? void 0 : _.position.x) || 0 : (_ == null ? void 0 : _.position.y) || 0, g.value = true;
      },
      {
        immediate: true
      }
    );
    watch(
      d,
      (_) => {
        i.value && (i.value.enabled = !_);
      },
      {
        immediate: true
      }
    ), watch(c, (_) => {
      !d.value && !t.htmlScroll || (M.value = _ / f.value / (y.value / f.value - 1), x.value = -1 * M.value, e("update:modelValue", M.value));
    }), watch(h, (_) => {
      M.value = _ / f.value / (y.value / f.value), x.value = -1 * M.value, e("update:modelValue", M.value);
    }), watch(u, (_) => {
      M.value = _ / E.value / (y.value / E.value - 1), x.value = +M.value, e("update:modelValue", M.value);
    }), watch(
      o,
      (_) => {
        var L2, B;
        const T = _ == null ? void 0 : _.domElement;
        if (t.htmlScroll && (_ != null && _.domElement))
          T != null && T.style.width && (T != null && T.style.position) && (T != null && T.style.top) && (T != null && T.style.left) && (T.style.width = "100%", T.style.position = "fixed", T.style.zIndex = " -99999", T.style.top = "0", T.style.left = "0"), y.value = document.body.scrollHeight;
        else {
          const k = document.createElement("div"), N = document.createElement("div");
          a.style[t.horizontal ? "overflowX" : "overflowY"] = "auto", a.style[t.horizontal ? "overflowY" : "overflowX"] = "hidden", a.style.position = "absolute", a.style.width = "100%", a.style.height = " 100%", a.style.top = "0", a.style.left = "0", a.classList.add("scrollContainer"), k.style.position = "sticky", k.style.top = "0px", k.style.left = "0px", k.style.width = "100%", k.style.height = "100%", k.style.overflow = "hidden", a.appendChild(k), N.style.height = t.horizontal ? "100%" : `${f.value * t.pages}px`, N.style.width = t.horizontal ? `${E.value * t.pages}px` : "100vw", N.style.pointerEvents = "none", T.style.position = "fixed", T.style.zIndex = "0", T != null && T.style.width && (T.style.width = "100%"), a.appendChild(N), _.domElement.parentNode.style.position = "relative", (B = (L2 = _ == null ? void 0 : _.domElement) == null ? void 0 : L2.parentNode) == null || B.appendChild(a), y.value = t.horizontal ? E.value * t.pages : f.value * t.pages;
        }
      },
      {
        immediate: true
      }
    );
    const { onLoop: b } = ae();
    return b(() => {
      var _;
      if ((_ = n.value) != null && _.position) {
        const T = (x.value * t.distance - n.value.position[m] + v) * t.smoothScroll;
        n.value.position[m] += T, r.value.children.length > 0 && (r.value.position[m] += T);
      }
    }), (_, T) => (openBlock(), createElementBlock("TresGroup", {
      ref_key: "wrapperRef",
      ref: r
    }, [
      renderSlot(_.$slots, "default")
    ], 512));
  }
});
var oe = {
  LEFT: 1,
  RIGHT: 2,
  MIDDLE: 4
};
var U = Object.freeze({
  NONE: 0,
  ROTATE: 1,
  TRUCK: 2,
  OFFSET: 4,
  DOLLY: 8,
  ZOOM: 16,
  TOUCH_ROTATE: 32,
  TOUCH_TRUCK: 64,
  TOUCH_OFFSET: 128,
  TOUCH_DOLLY: 256,
  TOUCH_ZOOM: 512,
  TOUCH_DOLLY_TRUCK: 1024,
  TOUCH_DOLLY_OFFSET: 2048,
  TOUCH_DOLLY_ROTATE: 4096,
  TOUCH_ZOOM_TRUCK: 8192,
  TOUCH_ZOOM_OFFSET: 16384,
  TOUCH_ZOOM_ROTATE: 32768
});
var Kt = {
  NONE: 0,
  IN: 1,
  OUT: -1
};
function Ut(l) {
  return l.isPerspectiveCamera;
}
function wt(l) {
  return l.isOrthographicCamera;
}
var Wt = Math.PI * 2;
var ei = Math.PI / 2;
var Zi = 1e-5;
var ns = Math.PI / 180;
function ot(l, e, t) {
  return Math.max(e, Math.min(t, l));
}
function Pe(l, e = Zi) {
  return Math.abs(l) < e;
}
function be(l, e, t = Zi) {
  return Pe(l - e, t);
}
function ti(l, e) {
  return Math.round(l / e) * e;
}
function is(l) {
  return isFinite(l) ? l : l < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
}
function os(l) {
  return Math.abs(l) < Number.MAX_VALUE ? l : l * (1 / 0);
}
function Ls(l, e, t, s, n = 1 / 0, i) {
  s = Math.max(1e-4, s);
  const o = 2 / s, r = o * i, a = 1 / (1 + r + 0.48 * r * r + 0.235 * r * r * r);
  let c = l - e;
  const u = e, h = n * s;
  c = ot(c, -h, h), e = l - c;
  const d = (t.value + o * c) * i;
  t.value = (t.value - o * d) * a;
  let f = e + (c + d) * a;
  return u - l > 0 == f > u && (f = u, t.value = (f - u) / i), f;
}
function si(l, e, t, s, n = 1 / 0, i, o) {
  s = Math.max(1e-4, s);
  const r = 2 / s, a = r * i, c = 1 / (1 + a + 0.48 * a * a + 0.235 * a * a * a);
  let u = e.x, h = e.y, d = e.z, f = l.x - u, E = l.y - h, v = l.z - d;
  const g = u, x = h, M = d, y = n * s, m = y * y, A = f * f + E * E + v * v;
  if (A > m) {
    const Z = Math.sqrt(A);
    f = f / Z * y, E = E / Z * y, v = v / Z * y;
  }
  u = l.x - f, h = l.y - E, d = l.z - v;
  const b = (t.x + r * f) * i, _ = (t.y + r * E) * i, T = (t.z + r * v) * i;
  t.x = (t.x - r * b) * c, t.y = (t.y - r * _) * c, t.z = (t.z - r * T) * c, o.x = u + (f + b) * c, o.y = h + (E + _) * c, o.z = d + (v + T) * c;
  const L2 = g - l.x, B = x - l.y, k = M - l.z, N = o.x - g, $ = o.y - x, Q = o.z - M;
  return L2 * N + B * $ + k * Q > 0 && (o.x = g, o.y = x, o.z = M, t.x = (o.x - g) / i, t.y = (o.y - x) / i, t.z = (o.z - M) / i), o;
}
function rn(l, e) {
  e.set(0, 0), l.forEach((t) => {
    e.x += t.clientX, e.y += t.clientY;
  }), e.x /= l.length, e.y /= l.length;
}
function an(l, e) {
  return wt(l) ? (console.warn(`${e} is not supported in OrthographicCamera`), true) : false;
}
var nl = class {
  constructor() {
    this._listeners = {};
  }
  /**
   * Adds the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(e, t) {
    const s = this._listeners;
    s[e] === void 0 && (s[e] = []), s[e].indexOf(t) === -1 && s[e].push(t);
  }
  /**
   * Presence of the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  hasEventListener(e, t) {
    const s = this._listeners;
    return s[e] !== void 0 && s[e].indexOf(t) !== -1;
  }
  /**
   * Removes the specified event listener
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(e, t) {
    const n = this._listeners[e];
    if (n !== void 0) {
      const i = n.indexOf(t);
      i !== -1 && n.splice(i, 1);
    }
  }
  /**
   * Removes all event listeners
   * @param type event name
   * @category Methods
   */
  removeAllEventListeners(e) {
    if (!e) {
      this._listeners = {};
      return;
    }
    Array.isArray(this._listeners[e]) && (this._listeners[e].length = 0);
  }
  /**
   * Fire an event type.
   * @param event DispatcherEvent
   * @category Methods
   */
  dispatchEvent(e) {
    const s = this._listeners[e.type];
    if (s !== void 0) {
      e.target = this;
      const n = s.slice(0);
      for (let i = 0, o = n.length; i < o; i++)
        n[i].call(this, e);
    }
  }
};
var il = "2.7.1";
var Rs = 1 / 8;
var $i = typeof window < "u";
var ol = $i && /Mac/.test(navigator.platform);
var rl = !($i && "PointerEvent" in window);
var ne;
var ni;
var Cs;
var ln;
var Ge;
var ue;
var we;
var Qt;
var rs;
var at;
var lt;
var Bt;
var ii;
var oi;
var We;
var as;
var qt;
var ri;
var cn2;
var ai;
var hn;
var un;
var Is;
var gs = class _gs extends nl {
  /**
       * Injects THREE as the dependency. You can then proceed to use CameraControls.
       *
       * e.g
       * ```javascript
       * CameraControls.install( { THREE: THREE } );
       * ```
       *
       * Note: If you do not wish to use enter three.js to reduce file size(tree-shaking for example), make a subset to install.
       *
       * ```js
       * import {
       * 	Vector2,
       * 	Vector3,
       * 	Vector4,
       * 	Quaternion,
       * 	Matrix4,
       * 	Spherical,
       * 	Box3,
       * 	Sphere,
       * 	Raycaster,
       * 	MathUtils,
       * } from 'three';
       *
       * const subsetOfTHREE = {
       * 	Vector2   : Vector2,
       * 	Vector3   : Vector3,
       * 	Vector4   : Vector4,
       * 	Quaternion: Quaternion,
       * 	Matrix4   : Matrix4,
       * 	Spherical : Spherical,
       * 	Box3      : Box3,
       * 	Sphere    : Sphere,
       * 	Raycaster : Raycaster,
       * };
  
       * CameraControls.install( { THREE: subsetOfTHREE } );
       * ```
       * @category Statics
       */
  static install(e) {
    ne = e.THREE, ni = Object.freeze(new ne.Vector3(0, 0, 0)), Cs = Object.freeze(new ne.Vector3(0, 1, 0)), ln = Object.freeze(new ne.Vector3(0, 0, 1)), Ge = new ne.Vector2(), ue = new ne.Vector3(), we = new ne.Vector3(), Qt = new ne.Vector3(), rs = new ne.Vector3(), at = new ne.Vector3(), lt = new ne.Vector3(), Bt = new ne.Vector3(), ii = new ne.Vector3(), oi = new ne.Vector3(), We = new ne.Spherical(), as = new ne.Spherical(), qt = new ne.Box3(), ri = new ne.Box3(), cn2 = new ne.Sphere(), ai = new ne.Quaternion(), hn = new ne.Quaternion(), un = new ne.Matrix4(), Is = new ne.Raycaster();
  }
  /**
   * list all ACTIONs
   * @category Statics
   */
  static get ACTION() {
    return U;
  }
  /**
   * Creates a `CameraControls` instance.
   *
   * Note:
   * You **must install** three.js before using camera-controls. see [#install](#install)
   * Not doing so will lead to runtime errors (`undefined` references to THREE).
   *
   * e.g.
   * ```
   * CameraControls.install( { THREE } );
   * const cameraControls = new CameraControls( camera, domElement );
   * ```
   *
   * @param camera A `THREE.PerspectiveCamera` or `THREE.OrthographicCamera` to be controlled.
   * @param domElement A `HTMLElement` for the draggable area, usually `renderer.domElement`.
   * @category Constructor
   */
  constructor(e, t) {
    super(), this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.minDistance = Number.EPSILON, this.maxDistance = 1 / 0, this.infinityDolly = false, this.minZoom = 0.01, this.maxZoom = 1 / 0, this.smoothTime = 0.25, this.draggingSmoothTime = 0.125, this.maxSpeed = 1 / 0, this.azimuthRotateSpeed = 1, this.polarRotateSpeed = 1, this.dollySpeed = 1, this.dollyDragInverted = false, this.truckSpeed = 2, this.dollyToCursor = false, this.dragToOffset = false, this.verticalDragToForward = false, this.boundaryFriction = 0, this.restThreshold = 0.01, this.colliderMeshes = [], this.cancel = () => {
    }, this._enabled = true, this._state = U.NONE, this._viewport = null, this._changedDolly = 0, this._changedZoom = 0, this._hasRested = true, this._boundaryEnclosesCamera = false, this._needsUpdate = true, this._updatedLastTime = false, this._elementRect = new DOMRect(), this._isDragging = false, this._activePointers = [], this._lockedPointer = null, this._interactiveArea = new DOMRect(0, 0, 1, 1), this._isUserControllingRotate = false, this._isUserControllingDolly = false, this._isUserControllingTruck = false, this._isUserControllingOffset = false, this._isUserControllingZoom = false, this._lastDollyDirection = Kt.NONE, this._thetaVelocity = { value: 0 }, this._phiVelocity = { value: 0 }, this._radiusVelocity = { value: 0 }, this._targetVelocity = new ne.Vector3(), this._focalOffsetVelocity = new ne.Vector3(), this._zoomVelocity = { value: 0 }, this._truckInternal = (m, A, b) => {
      let _, T;
      if (Ut(this._camera)) {
        const L2 = ue.copy(this._camera.position).sub(this._target), B = this._camera.getEffectiveFOV() * ns, k = L2.length() * Math.tan(B * 0.5);
        _ = this.truckSpeed * m * k / this._elementRect.height, T = this.truckSpeed * A * k / this._elementRect.height;
      } else if (wt(this._camera)) {
        const L2 = this._camera;
        _ = m * (L2.right - L2.left) / L2.zoom / this._elementRect.width, T = A * (L2.top - L2.bottom) / L2.zoom / this._elementRect.height;
      } else
        return;
      this.verticalDragToForward ? (b ? this.setFocalOffset(this._focalOffsetEnd.x + _, this._focalOffsetEnd.y, this._focalOffsetEnd.z, true) : this.truck(_, 0, true), this.forward(-T, true)) : b ? this.setFocalOffset(this._focalOffsetEnd.x + _, this._focalOffsetEnd.y + T, this._focalOffsetEnd.z, true) : this.truck(_, T, true);
    }, this._rotateInternal = (m, A) => {
      const b = Wt * this.azimuthRotateSpeed * m / this._elementRect.height, _ = Wt * this.polarRotateSpeed * A / this._elementRect.height;
      this.rotate(b, _, true);
    }, this._dollyInternal = (m, A, b) => {
      const _ = Math.pow(0.95, -m * this.dollySpeed), T = this._sphericalEnd.radius, L2 = this._sphericalEnd.radius * _, B = ot(L2, this.minDistance, this.maxDistance), k = B - L2;
      this.infinityDolly && this.dollyToCursor ? this._dollyToNoClamp(L2, true) : this.infinityDolly && !this.dollyToCursor ? (this.dollyInFixed(k, true), this._dollyToNoClamp(B, true)) : this._dollyToNoClamp(B, true), this.dollyToCursor && (this._changedDolly += (this.infinityDolly ? L2 : B) - T, this._dollyControlCoord.set(A, b)), this._lastDollyDirection = Math.sign(-m);
    }, this._zoomInternal = (m, A, b) => {
      const _ = Math.pow(0.95, m * this.dollySpeed), T = this._zoom, L2 = this._zoom * _;
      this.zoomTo(L2, true), this.dollyToCursor && (this._changedZoom += L2 - T, this._dollyControlCoord.set(A, b));
    }, typeof ne > "u" && console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information."), this._camera = e, this._yAxisUpSpace = new ne.Quaternion().setFromUnitVectors(this._camera.up, Cs), this._yAxisUpSpaceInverse = this._yAxisUpSpace.clone().invert(), this._state = U.NONE, this._target = new ne.Vector3(), this._targetEnd = this._target.clone(), this._focalOffset = new ne.Vector3(), this._focalOffsetEnd = this._focalOffset.clone(), this._spherical = new ne.Spherical().setFromVector3(ue.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace)), this._sphericalEnd = this._spherical.clone(), this._lastDistance = this._spherical.radius, this._zoom = this._camera.zoom, this._zoomEnd = this._zoom, this._lastZoom = this._zoom, this._nearPlaneCorners = [
      new ne.Vector3(),
      new ne.Vector3(),
      new ne.Vector3(),
      new ne.Vector3()
    ], this._updateNearPlaneCorners(), this._boundary = new ne.Box3(new ne.Vector3(-1 / 0, -1 / 0, -1 / 0), new ne.Vector3(1 / 0, 1 / 0, 1 / 0)), this._cameraUp0 = this._camera.up.clone(), this._target0 = this._target.clone(), this._position0 = this._camera.position.clone(), this._zoom0 = this._zoom, this._focalOffset0 = this._focalOffset.clone(), this._dollyControlCoord = new ne.Vector2(), this.mouseButtons = {
      left: U.ROTATE,
      middle: U.DOLLY,
      right: U.TRUCK,
      wheel: Ut(this._camera) ? U.DOLLY : wt(this._camera) ? U.ZOOM : U.NONE
    }, this.touches = {
      one: U.TOUCH_ROTATE,
      two: Ut(this._camera) ? U.TOUCH_DOLLY_TRUCK : wt(this._camera) ? U.TOUCH_ZOOM_TRUCK : U.NONE,
      three: U.TOUCH_TRUCK
    };
    const s = new ne.Vector2(), n = new ne.Vector2(), i = new ne.Vector2(), o = (m) => {
      if (!this._enabled || !this._domElement)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const _ = this._domElement.getBoundingClientRect(), T = m.clientX / _.width, L2 = m.clientY / _.height;
        if (T < this._interactiveArea.left || T > this._interactiveArea.right || L2 < this._interactiveArea.top || L2 > this._interactiveArea.bottom)
          return;
      }
      const A = m.pointerType !== "mouse" ? null : (m.buttons & oe.LEFT) === oe.LEFT ? oe.LEFT : (m.buttons & oe.MIDDLE) === oe.MIDDLE ? oe.MIDDLE : (m.buttons & oe.RIGHT) === oe.RIGHT ? oe.RIGHT : null;
      if (A !== null) {
        const _ = this._findPointerByMouseButton(A);
        _ && this._disposePointer(_);
      }
      if ((m.buttons & oe.LEFT) === oe.LEFT && this._lockedPointer)
        return;
      const b = {
        pointerId: m.pointerId,
        clientX: m.clientX,
        clientY: m.clientY,
        deltaX: 0,
        deltaY: 0,
        mouseButton: A
      };
      this._activePointers.push(b), this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: false }), this._domElement.ownerDocument.removeEventListener("pointerup", u), this._domElement.ownerDocument.addEventListener("pointermove", a, { passive: false }), this._domElement.ownerDocument.addEventListener("pointerup", u), this._isDragging = true, v(m);
    }, r = (m) => {
      if (!this._enabled || !this._domElement || this._lockedPointer)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const _ = this._domElement.getBoundingClientRect(), T = m.clientX / _.width, L2 = m.clientY / _.height;
        if (T < this._interactiveArea.left || T > this._interactiveArea.right || L2 < this._interactiveArea.top || L2 > this._interactiveArea.bottom)
          return;
      }
      const A = (m.buttons & oe.LEFT) === oe.LEFT ? oe.LEFT : (m.buttons & oe.MIDDLE) === oe.MIDDLE ? oe.MIDDLE : (m.buttons & oe.RIGHT) === oe.RIGHT ? oe.RIGHT : null;
      if (A !== null) {
        const _ = this._findPointerByMouseButton(A);
        _ && this._disposePointer(_);
      }
      const b = {
        pointerId: 1,
        clientX: m.clientX,
        clientY: m.clientY,
        deltaX: 0,
        deltaY: 0,
        mouseButton: (m.buttons & oe.LEFT) === oe.LEFT ? oe.LEFT : (m.buttons & oe.MIDDLE) === oe.LEFT ? oe.MIDDLE : (m.buttons & oe.RIGHT) === oe.LEFT ? oe.RIGHT : null
      };
      this._activePointers.push(b), this._domElement.ownerDocument.removeEventListener("mousemove", c), this._domElement.ownerDocument.removeEventListener("mouseup", h), this._domElement.ownerDocument.addEventListener("mousemove", c), this._domElement.ownerDocument.addEventListener("mouseup", h), this._isDragging = true, v(m);
    }, a = (m) => {
      m.cancelable && m.preventDefault();
      const A = m.pointerId, b = this._lockedPointer || this._findPointerById(A);
      if (b) {
        if (b.clientX = m.clientX, b.clientY = m.clientY, b.deltaX = m.movementX, b.deltaY = m.movementY, this._state = 0, m.pointerType === "touch")
          switch (this._activePointers.length) {
            case 1:
              this._state = this.touches.one;
              break;
            case 2:
              this._state = this.touches.two;
              break;
            case 3:
              this._state = this.touches.three;
              break;
          }
        else
          (!this._isDragging && this._lockedPointer || this._isDragging && (m.buttons & oe.LEFT) === oe.LEFT) && (this._state = this._state | this.mouseButtons.left), this._isDragging && (m.buttons & oe.MIDDLE) === oe.MIDDLE && (this._state = this._state | this.mouseButtons.middle), this._isDragging && (m.buttons & oe.RIGHT) === oe.RIGHT && (this._state = this._state | this.mouseButtons.right);
        g();
      }
    }, c = (m) => {
      const A = this._lockedPointer || this._findPointerById(1);
      A && (A.clientX = m.clientX, A.clientY = m.clientY, A.deltaX = m.movementX, A.deltaY = m.movementY, this._state = 0, (this._lockedPointer || (m.buttons & oe.LEFT) === oe.LEFT) && (this._state = this._state | this.mouseButtons.left), (m.buttons & oe.MIDDLE) === oe.MIDDLE && (this._state = this._state | this.mouseButtons.middle), (m.buttons & oe.RIGHT) === oe.RIGHT && (this._state = this._state | this.mouseButtons.right), g());
    }, u = (m) => {
      const A = this._findPointerById(m.pointerId);
      if (!(A && A === this._lockedPointer)) {
        if (A && this._disposePointer(A), m.pointerType === "touch")
          switch (this._activePointers.length) {
            case 0:
              this._state = U.NONE;
              break;
            case 1:
              this._state = this.touches.one;
              break;
            case 2:
              this._state = this.touches.two;
              break;
            case 3:
              this._state = this.touches.three;
              break;
          }
        else
          this._state = U.NONE;
        x();
      }
    }, h = () => {
      const m = this._findPointerById(1);
      m && m === this._lockedPointer || (m && this._disposePointer(m), this._state = U.NONE, x());
    };
    let d = -1;
    const f = (m) => {
      if (!this._domElement || !this._enabled || this.mouseButtons.wheel === U.NONE)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const L2 = this._domElement.getBoundingClientRect(), B = m.clientX / L2.width, k = m.clientY / L2.height;
        if (B < this._interactiveArea.left || B > this._interactiveArea.right || k < this._interactiveArea.top || k > this._interactiveArea.bottom)
          return;
      }
      if (m.preventDefault(), this.dollyToCursor || this.mouseButtons.wheel === U.ROTATE || this.mouseButtons.wheel === U.TRUCK) {
        const L2 = performance.now();
        d - L2 < 1e3 && this._getClientRect(this._elementRect), d = L2;
      }
      const A = ol ? -1 : -3, b = m.deltaMode === 1 ? m.deltaY / A : m.deltaY / (A * 10), _ = this.dollyToCursor ? (m.clientX - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, T = this.dollyToCursor ? (m.clientY - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
      switch (this.mouseButtons.wheel) {
        case U.ROTATE: {
          this._rotateInternal(m.deltaX, m.deltaY), this._isUserControllingRotate = true;
          break;
        }
        case U.TRUCK: {
          this._truckInternal(m.deltaX, m.deltaY, false), this._isUserControllingTruck = true;
          break;
        }
        case U.OFFSET: {
          this._truckInternal(m.deltaX, m.deltaY, true), this._isUserControllingOffset = true;
          break;
        }
        case U.DOLLY: {
          this._dollyInternal(-b, _, T), this._isUserControllingDolly = true;
          break;
        }
        case U.ZOOM: {
          this._zoomInternal(-b, _, T), this._isUserControllingZoom = true;
          break;
        }
      }
      this.dispatchEvent({ type: "control" });
    }, E = (m) => {
      if (!(!this._domElement || !this._enabled)) {
        if (this.mouseButtons.right === _gs.ACTION.NONE) {
          const A = m instanceof PointerEvent ? m.pointerId : (m instanceof MouseEvent, 0), b = this._findPointerById(A);
          b && this._disposePointer(b), this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: false }), this._domElement.ownerDocument.removeEventListener("pointerup", u), this._domElement.ownerDocument.removeEventListener("mousemove", c), this._domElement.ownerDocument.removeEventListener("mouseup", h);
          return;
        }
        m.preventDefault();
      }
    }, v = (m) => {
      if (!this._enabled)
        return;
      if (rn(this._activePointers, Ge), this._getClientRect(this._elementRect), s.copy(Ge), n.copy(Ge), this._activePointers.length >= 2) {
        const b = Ge.x - this._activePointers[1].clientX, _ = Ge.y - this._activePointers[1].clientY, T = Math.sqrt(b * b + _ * _);
        i.set(0, T);
        const L2 = (this._activePointers[0].clientX + this._activePointers[1].clientX) * 0.5, B = (this._activePointers[0].clientY + this._activePointers[1].clientY) * 0.5;
        n.set(L2, B);
      }
      if (this._state = 0, !m)
        this._lockedPointer && (this._state = this._state | this.mouseButtons.left);
      else if ("pointerType" in m && m.pointerType === "touch")
        switch (this._activePointers.length) {
          case 1:
            this._state = this.touches.one;
            break;
          case 2:
            this._state = this.touches.two;
            break;
          case 3:
            this._state = this.touches.three;
            break;
        }
      else
        !this._lockedPointer && (m.buttons & oe.LEFT) === oe.LEFT && (this._state = this._state | this.mouseButtons.left), (m.buttons & oe.MIDDLE) === oe.MIDDLE && (this._state = this._state | this.mouseButtons.middle), (m.buttons & oe.RIGHT) === oe.RIGHT && (this._state = this._state | this.mouseButtons.right);
      ((this._state & U.ROTATE) === U.ROTATE || (this._state & U.TOUCH_ROTATE) === U.TOUCH_ROTATE || (this._state & U.TOUCH_DOLLY_ROTATE) === U.TOUCH_DOLLY_ROTATE || (this._state & U.TOUCH_ZOOM_ROTATE) === U.TOUCH_ZOOM_ROTATE) && (this._sphericalEnd.theta = this._spherical.theta, this._sphericalEnd.phi = this._spherical.phi, this._thetaVelocity.value = 0, this._phiVelocity.value = 0), ((this._state & U.TRUCK) === U.TRUCK || (this._state & U.TOUCH_TRUCK) === U.TOUCH_TRUCK || (this._state & U.TOUCH_DOLLY_TRUCK) === U.TOUCH_DOLLY_TRUCK || (this._state & U.TOUCH_ZOOM_TRUCK) === U.TOUCH_ZOOM_TRUCK) && (this._targetEnd.copy(this._target), this._targetVelocity.set(0, 0, 0)), ((this._state & U.DOLLY) === U.DOLLY || (this._state & U.TOUCH_DOLLY) === U.TOUCH_DOLLY || (this._state & U.TOUCH_DOLLY_TRUCK) === U.TOUCH_DOLLY_TRUCK || (this._state & U.TOUCH_DOLLY_OFFSET) === U.TOUCH_DOLLY_OFFSET || (this._state & U.TOUCH_DOLLY_ROTATE) === U.TOUCH_DOLLY_ROTATE) && (this._sphericalEnd.radius = this._spherical.radius, this._radiusVelocity.value = 0), ((this._state & U.ZOOM) === U.ZOOM || (this._state & U.TOUCH_ZOOM) === U.TOUCH_ZOOM || (this._state & U.TOUCH_ZOOM_TRUCK) === U.TOUCH_ZOOM_TRUCK || (this._state & U.TOUCH_ZOOM_OFFSET) === U.TOUCH_ZOOM_OFFSET || (this._state & U.TOUCH_ZOOM_ROTATE) === U.TOUCH_ZOOM_ROTATE) && (this._zoomEnd = this._zoom, this._zoomVelocity.value = 0), ((this._state & U.OFFSET) === U.OFFSET || (this._state & U.TOUCH_OFFSET) === U.TOUCH_OFFSET || (this._state & U.TOUCH_DOLLY_OFFSET) === U.TOUCH_DOLLY_OFFSET || (this._state & U.TOUCH_ZOOM_OFFSET) === U.TOUCH_ZOOM_OFFSET) && (this._focalOffsetEnd.copy(this._focalOffset), this._focalOffsetVelocity.set(0, 0, 0)), this.dispatchEvent({ type: "controlstart" });
    }, g = () => {
      if (!this._enabled)
        return;
      rn(this._activePointers, Ge);
      const A = this._domElement && document.pointerLockElement === this._domElement ? this._lockedPointer || this._activePointers[0] : null, b = A ? -A.deltaX : n.x - Ge.x, _ = A ? -A.deltaY : n.y - Ge.y;
      if (n.copy(Ge), ((this._state & U.ROTATE) === U.ROTATE || (this._state & U.TOUCH_ROTATE) === U.TOUCH_ROTATE || (this._state & U.TOUCH_DOLLY_ROTATE) === U.TOUCH_DOLLY_ROTATE || (this._state & U.TOUCH_ZOOM_ROTATE) === U.TOUCH_ZOOM_ROTATE) && (this._rotateInternal(b, _), this._isUserControllingRotate = true), (this._state & U.DOLLY) === U.DOLLY || (this._state & U.ZOOM) === U.ZOOM) {
        const T = this.dollyToCursor ? (s.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, L2 = this.dollyToCursor ? (s.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0, B = this.dollyDragInverted ? -1 : 1;
        (this._state & U.DOLLY) === U.DOLLY ? (this._dollyInternal(B * _ * Rs, T, L2), this._isUserControllingDolly = true) : (this._zoomInternal(B * _ * Rs, T, L2), this._isUserControllingZoom = true);
      }
      if ((this._state & U.TOUCH_DOLLY) === U.TOUCH_DOLLY || (this._state & U.TOUCH_ZOOM) === U.TOUCH_ZOOM || (this._state & U.TOUCH_DOLLY_TRUCK) === U.TOUCH_DOLLY_TRUCK || (this._state & U.TOUCH_ZOOM_TRUCK) === U.TOUCH_ZOOM_TRUCK || (this._state & U.TOUCH_DOLLY_OFFSET) === U.TOUCH_DOLLY_OFFSET || (this._state & U.TOUCH_ZOOM_OFFSET) === U.TOUCH_ZOOM_OFFSET || (this._state & U.TOUCH_DOLLY_ROTATE) === U.TOUCH_DOLLY_ROTATE || (this._state & U.TOUCH_ZOOM_ROTATE) === U.TOUCH_ZOOM_ROTATE) {
        const T = Ge.x - this._activePointers[1].clientX, L2 = Ge.y - this._activePointers[1].clientY, B = Math.sqrt(T * T + L2 * L2), k = i.y - B;
        i.set(0, B);
        const N = this.dollyToCursor ? (n.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, $ = this.dollyToCursor ? (n.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
        (this._state & U.TOUCH_DOLLY) === U.TOUCH_DOLLY || (this._state & U.TOUCH_DOLLY_ROTATE) === U.TOUCH_DOLLY_ROTATE || (this._state & U.TOUCH_DOLLY_TRUCK) === U.TOUCH_DOLLY_TRUCK || (this._state & U.TOUCH_DOLLY_OFFSET) === U.TOUCH_DOLLY_OFFSET ? (this._dollyInternal(k * Rs, N, $), this._isUserControllingDolly = true) : (this._zoomInternal(k * Rs, N, $), this._isUserControllingZoom = true);
      }
      ((this._state & U.TRUCK) === U.TRUCK || (this._state & U.TOUCH_TRUCK) === U.TOUCH_TRUCK || (this._state & U.TOUCH_DOLLY_TRUCK) === U.TOUCH_DOLLY_TRUCK || (this._state & U.TOUCH_ZOOM_TRUCK) === U.TOUCH_ZOOM_TRUCK) && (this._truckInternal(b, _, false), this._isUserControllingTruck = true), ((this._state & U.OFFSET) === U.OFFSET || (this._state & U.TOUCH_OFFSET) === U.TOUCH_OFFSET || (this._state & U.TOUCH_DOLLY_OFFSET) === U.TOUCH_DOLLY_OFFSET || (this._state & U.TOUCH_ZOOM_OFFSET) === U.TOUCH_ZOOM_OFFSET) && (this._truckInternal(b, _, true), this._isUserControllingOffset = true), this.dispatchEvent({ type: "control" });
    }, x = () => {
      rn(this._activePointers, Ge), n.copy(Ge), (this._activePointers.length === 0 || this._activePointers.length === 1 && this._activePointers[0] === this._lockedPointer) && (this._isDragging = false), this._activePointers.length === 0 && this._domElement && (this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: false }), this._domElement.ownerDocument.removeEventListener("mousemove", c), this._domElement.ownerDocument.removeEventListener("pointerup", u), this._domElement.ownerDocument.removeEventListener("mouseup", h), this.dispatchEvent({ type: "controlend" }));
    };
    this.lockPointer = () => {
      !this._enabled || !this._domElement || (this.cancel(), this._lockedPointer = {
        pointerId: -1,
        clientX: 0,
        clientY: 0,
        deltaX: 0,
        deltaY: 0,
        mouseButton: null
      }, this._activePointers.push(this._lockedPointer), this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: false }), this._domElement.ownerDocument.removeEventListener("pointerup", u), this._domElement.requestPointerLock(), this._domElement.ownerDocument.addEventListener("pointerlockchange", M), this._domElement.ownerDocument.addEventListener("pointerlockerror", y), this._domElement.ownerDocument.addEventListener("pointermove", a, { passive: false }), this._domElement.ownerDocument.addEventListener("pointerup", u), v());
    }, this.unlockPointer = () => {
      this._lockedPointer !== null && (this._disposePointer(this._lockedPointer), this._lockedPointer = null), document.exitPointerLock(), this.cancel(), this._domElement && (this._domElement.ownerDocument.removeEventListener("pointerlockchange", M), this._domElement.ownerDocument.removeEventListener("pointerlockerror", y));
    };
    const M = () => {
      this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement || this.unlockPointer();
    }, y = () => {
      this.unlockPointer();
    };
    this._addAllEventListeners = (m) => {
      this._domElement = m, this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none", this._domElement.addEventListener("pointerdown", o), rl && this._domElement.addEventListener("mousedown", r), this._domElement.addEventListener("pointercancel", u), this._domElement.addEventListener("wheel", f, { passive: false }), this._domElement.addEventListener("contextmenu", E);
    }, this._removeAllEventListeners = () => {
      this._domElement && (this._domElement.style.touchAction = "", this._domElement.style.userSelect = "", this._domElement.style.webkitUserSelect = "", this._domElement.removeEventListener("pointerdown", o), this._domElement.removeEventListener("mousedown", r), this._domElement.removeEventListener("pointercancel", u), this._domElement.removeEventListener("wheel", f, { passive: false }), this._domElement.removeEventListener("contextmenu", E), this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: false }), this._domElement.ownerDocument.removeEventListener("mousemove", c), this._domElement.ownerDocument.removeEventListener("pointerup", u), this._domElement.ownerDocument.removeEventListener("mouseup", h), this._domElement.ownerDocument.removeEventListener("pointerlockchange", M), this._domElement.ownerDocument.removeEventListener("pointerlockerror", y));
    }, this.cancel = () => {
      this._state !== U.NONE && (this._state = U.NONE, this._activePointers.length = 0, x());
    }, t && this.connect(t), this.update(0);
  }
  /**
   * The camera to be controlled
   * @category Properties
   */
  get camera() {
    return this._camera;
  }
  set camera(e) {
    this._camera = e, this.updateCameraUp(), this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = true;
  }
  /**
   * Whether or not the controls are enabled.
   * `false` to disable user dragging/touch-move, but all methods works.
   * @category Properties
   */
  get enabled() {
    return this._enabled;
  }
  set enabled(e) {
    this._enabled = e, this._domElement && (e ? (this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none") : (this.cancel(), this._domElement.style.touchAction = "", this._domElement.style.userSelect = "", this._domElement.style.webkitUserSelect = ""));
  }
  /**
   * Returns `true` if the controls are active updating.
   * readonly value.
   * @category Properties
   */
  get active() {
    return !this._hasRested;
  }
  /**
   * Getter for the current `ACTION`.
   * readonly value.
   * @category Properties
   */
  get currentAction() {
    return this._state;
  }
  /**
   * get/set Current distance.
   * @category Properties
   */
  get distance() {
    return this._spherical.radius;
  }
  set distance(e) {
    this._spherical.radius === e && this._sphericalEnd.radius === e || (this._spherical.radius = e, this._sphericalEnd.radius = e, this._needsUpdate = true);
  }
  // horizontal angle
  /**
   * get/set the azimuth angle (horizontal) in radians.
   * Every 360 degrees turn is added to `.azimuthAngle` value, which is accumulative.
   * @category Properties
   */
  get azimuthAngle() {
    return this._spherical.theta;
  }
  set azimuthAngle(e) {
    this._spherical.theta === e && this._sphericalEnd.theta === e || (this._spherical.theta = e, this._sphericalEnd.theta = e, this._needsUpdate = true);
  }
  // vertical angle
  /**
   * get/set the polar angle (vertical) in radians.
   * @category Properties
   */
  get polarAngle() {
    return this._spherical.phi;
  }
  set polarAngle(e) {
    this._spherical.phi === e && this._sphericalEnd.phi === e || (this._spherical.phi = e, this._sphericalEnd.phi = e, this._needsUpdate = true);
  }
  /**
   * Whether camera position should be enclosed in the boundary or not.
   * @category Properties
   */
  get boundaryEnclosesCamera() {
    return this._boundaryEnclosesCamera;
  }
  set boundaryEnclosesCamera(e) {
    this._boundaryEnclosesCamera = e, this._needsUpdate = true;
  }
  /**
   * Set drag-start, touches and wheel enable area in the domElement.
   * each values are between `0` and `1` inclusive, where `0` is left/top and `1` is right/bottom of the screen.
   * e.g. `{ x: 0, y: 0, width: 1, height: 1 }` for entire area.
   * @category Properties
   */
  set interactiveArea(e) {
    this._interactiveArea.width = ot(e.width, 0, 1), this._interactiveArea.height = ot(e.height, 0, 1), this._interactiveArea.x = ot(e.x, 0, 1 - this._interactiveArea.width), this._interactiveArea.y = ot(e.x, 0, 1 - this._interactiveArea.height);
  }
  /**
   * Adds the specified event listener.
   * Applicable event types (which is `K`) are:
   * | Event name          | Timing |
   * | ------------------- | ------ |
   * | `'controlstart'`    | When the user starts to control the camera via mouse / touches.  |
   * | `'control'`         | When the user controls the camera (dragging). |
   * | `'controlend'`      | When the user ends to control the camera.  |
   * | `'transitionstart'` | When any kind of transition starts, either user control or using a method with `enableTransition = true` |
   * | `'update'`          | When the camera position is updated. |
   * | `'wake'`            | When the camera starts moving. |
   * | `'rest'`            | When the camera movement is below `.restThreshold` . |
   * | `'sleep'`           | When the camera end moving. |
   *
   * 1. `mouseButtons.wheel` (Mouse wheel control) does not emit `'controlstart'` and `'controlend'`. `mouseButtons.wheel` uses scroll-event internally, and scroll-event happens intermittently. That means "start" and "end" cannot be detected.
   * 2. Due to damping, `sleep` will usually fire a few seconds after the camera _appears_ to have stopped moving. If you want to do something (e.g. enable UI, perform another transition) at the point when the camera has stopped, you probably want the `rest` event. This can be fine tuned using the `.restThreshold` parameter. See the [Rest and Sleep Example](https://yomotsu.github.io/camera-controls/examples/rest-and-sleep.html).
   *
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(e, t) {
    super.addEventListener(e, t);
  }
  /**
   * Removes the specified event listener
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(e, t) {
    super.removeEventListener(e, t);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical).
   * Every value is added to the current value.
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotate(e, t, s = false) {
    return this.rotateTo(this._sphericalEnd.theta + e, this._sphericalEnd.phi + t, s);
  }
  /**
   * Rotate azimuthal angle(horizontal) to the given angle and keep the same polar angle(vertical) target.
   *
   * e.g.
   * ```
   * cameraControls.rotateAzimuthTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotateAzimuthTo(e, t = false) {
    return this.rotateTo(e, this._sphericalEnd.phi, t);
  }
  /**
   * Rotate polar angle(vertical) to the given angle and keep the same azimuthal angle(horizontal) target.
   *
   * e.g.
   * ```
   * cameraControls.rotatePolarTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotatePolarTo(e, t = false) {
    return this.rotateTo(this._sphericalEnd.theta, e, t);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical) to the given angle.
   * Camera view will rotate over the orbit pivot absolutely:
   *
   * azimuthAngle
   * ```
   *       0
   *         \
   * 90 -----+----- -90
   *           \
   *           180
   * ```
   * | direction | angle                  |
   * | --------- | ---------------------- |
   * | front     | 0                     |
   * | left      | 90 (`Math.PI / 2`)    |
   * | right     | -90 (`- Math.PI / 2`) |
   * | back      | 180 (`Math.PI`)       |
   *
   * polarAngle
   * ```
   *     180
   *      |
   *      90
   *      |
   *      0
   * ```
   * | direction            | angle                  |
   * | -------------------- | ---------------------- |
   * | top/sky              | 180 (`Math.PI`)       |
   * | horizontal from view | 90 (`Math.PI / 2`)    |
   * | bottom/floor         | 0                     |
   *
   * @param azimuthAngle Azimuth rotate angle to. In radian.
   * @param polarAngle Polar rotate angle to. In radian.
   * @param enableTransition  Whether to move smoothly or immediately
   * @category Methods
   */
  rotateTo(e, t, s = false) {
    this._isUserControllingRotate = false;
    const n = ot(e, this.minAzimuthAngle, this.maxAzimuthAngle), i = ot(t, this.minPolarAngle, this.maxPolarAngle);
    this._sphericalEnd.theta = n, this._sphericalEnd.phi = i, this._sphericalEnd.makeSafe(), this._needsUpdate = true, s || (this._spherical.theta = this._sphericalEnd.theta, this._spherical.phi = this._sphericalEnd.phi);
    const o = !s || be(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && be(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold);
    return this._createOnRestPromise(o);
  }
  /**
   * Dolly in/out camera position.
   * @param distance Distance of dollyIn. Negative number for dollyOut.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dolly(e, t = false) {
    return this.dollyTo(this._sphericalEnd.radius - e, t);
  }
  /**
   * Dolly in/out camera position to given distance.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyTo(e, t = false) {
    return this._isUserControllingDolly = false, this._lastDollyDirection = Kt.NONE, this._changedDolly = 0, this._dollyToNoClamp(ot(e, this.minDistance, this.maxDistance), t);
  }
  _dollyToNoClamp(e, t = false) {
    const s = this._sphericalEnd.radius;
    if (this.colliderMeshes.length >= 1) {
      const o = this._collisionTest(), r = be(o, this._spherical.radius);
      if (!(s > e) && r)
        return Promise.resolve();
      this._sphericalEnd.radius = Math.min(e, o);
    } else
      this._sphericalEnd.radius = e;
    this._needsUpdate = true, t || (this._spherical.radius = this._sphericalEnd.radius);
    const i = !t || be(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(i);
  }
  /**
   * Dolly in, but does not change the distance between the target and the camera, and moves the target position instead.
   * Specify a negative value for dolly out.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyInFixed(e, t = false) {
    this._targetEnd.add(this._getCameraDirection(rs).multiplyScalar(e)), t || this._target.copy(this._targetEnd);
    const s = !t || be(this._target.x, this._targetEnd.x, this.restThreshold) && be(this._target.y, this._targetEnd.y, this.restThreshold) && be(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(s);
  }
  /**
   * Zoom in/out camera. The value is added to camera zoom.
   * Limits set with `.minZoom` and `.maxZoom`
   * @param zoomStep zoom scale
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  zoom(e, t = false) {
    return this.zoomTo(this._zoomEnd + e, t);
  }
  /**
   * Zoom in/out camera to given scale. The value overwrites camera zoom.
   * Limits set with .minZoom and .maxZoom
   * @param zoom
   * @param enableTransition
   * @category Methods
   */
  zoomTo(e, t = false) {
    this._isUserControllingZoom = false, this._zoomEnd = ot(e, this.minZoom, this.maxZoom), this._needsUpdate = true, t || (this._zoom = this._zoomEnd);
    const s = !t || be(this._zoom, this._zoomEnd, this.restThreshold);
    return this._changedZoom = 0, this._createOnRestPromise(s);
  }
  /**
   * @deprecated `pan()` has been renamed to `truck()`
   * @category Methods
   */
  pan(e, t, s = false) {
    return console.warn("`pan` has been renamed to `truck`"), this.truck(e, t, s);
  }
  /**
   * Truck and pedestal camera using current azimuthal angle
   * @param x Horizontal translate amount
   * @param y Vertical translate amount
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  truck(e, t, s = false) {
    this._camera.updateMatrix(), at.setFromMatrixColumn(this._camera.matrix, 0), lt.setFromMatrixColumn(this._camera.matrix, 1), at.multiplyScalar(e), lt.multiplyScalar(-t);
    const n = ue.copy(at).add(lt), i = we.copy(this._targetEnd).add(n);
    return this.moveTo(i.x, i.y, i.z, s);
  }
  /**
   * Move forward / backward.
   * @param distance Amount to move forward / backward. Negative value to move backward
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  forward(e, t = false) {
    ue.setFromMatrixColumn(this._camera.matrix, 0), ue.crossVectors(this._camera.up, ue), ue.multiplyScalar(e);
    const s = we.copy(this._targetEnd).add(ue);
    return this.moveTo(s.x, s.y, s.z, t);
  }
  /**
   * Move up / down.
   * @param height Amount to move up / down. Negative value to move down
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  elevate(e, t = false) {
    return ue.copy(this._camera.up).multiplyScalar(e), this.moveTo(this._targetEnd.x + ue.x, this._targetEnd.y + ue.y, this._targetEnd.z + ue.z, t);
  }
  /**
   * Move target position to given point.
   * @param x x coord to move center position
   * @param y y coord to move center position
   * @param z z coord to move center position
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  moveTo(e, t, s, n = false) {
    this._isUserControllingTruck = false;
    const i = ue.set(e, t, s).sub(this._targetEnd);
    this._encloseToBoundary(this._targetEnd, i, this.boundaryFriction), this._needsUpdate = true, n || this._target.copy(this._targetEnd);
    const o = !n || be(this._target.x, this._targetEnd.x, this.restThreshold) && be(this._target.y, this._targetEnd.y, this.restThreshold) && be(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(o);
  }
  /**
   * Look in the given point direction.
   * @param x point x.
   * @param y point y.
   * @param z point z.
   * @param enableTransition Whether to move smoothly or immediately.
   * @returns Transition end promise
   * @category Methods
   */
  lookInDirectionOf(e, t, s, n = false) {
    const r = ue.set(e, t, s).sub(this._targetEnd).normalize().multiplyScalar(-this._sphericalEnd.radius);
    return this.setPosition(r.x, r.y, r.z, n);
  }
  /**
   * Fit the viewport to the box or the bounding box of the object, using the nearest axis. paddings are in unit.
   * set `cover: true` to fill enter screen.
   * e.g.
   * ```
   * cameraControls.fitToBox( myMesh );
   * ```
   * @param box3OrObject Axis aligned bounding box to fit the view.
   * @param enableTransition Whether to move smoothly or immediately.
   * @param options | `<object>` { cover: boolean, paddingTop: number, paddingLeft: number, paddingBottom: number, paddingRight: number }
   * @returns Transition end promise
   * @category Methods
   */
  fitToBox(e, t, { cover: s = false, paddingLeft: n = 0, paddingRight: i = 0, paddingBottom: o = 0, paddingTop: r = 0 } = {}) {
    const a = [], c = e.isBox3 ? qt.copy(e) : qt.setFromObject(e);
    c.isEmpty() && (console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting"), Promise.resolve());
    const u = ti(this._sphericalEnd.theta, ei), h = ti(this._sphericalEnd.phi, ei);
    a.push(this.rotateTo(u, h, t));
    const d = ue.setFromSpherical(this._sphericalEnd).normalize(), f = ai.setFromUnitVectors(d, ln), E = be(Math.abs(d.y), 1);
    E && f.multiply(hn.setFromAxisAngle(Cs, u)), f.multiply(this._yAxisUpSpaceInverse);
    const v = ri.makeEmpty();
    we.copy(c.min).applyQuaternion(f), v.expandByPoint(we), we.copy(c.min).setX(c.max.x).applyQuaternion(f), v.expandByPoint(we), we.copy(c.min).setY(c.max.y).applyQuaternion(f), v.expandByPoint(we), we.copy(c.max).setZ(c.min.z).applyQuaternion(f), v.expandByPoint(we), we.copy(c.min).setZ(c.max.z).applyQuaternion(f), v.expandByPoint(we), we.copy(c.max).setY(c.min.y).applyQuaternion(f), v.expandByPoint(we), we.copy(c.max).setX(c.min.x).applyQuaternion(f), v.expandByPoint(we), we.copy(c.max).applyQuaternion(f), v.expandByPoint(we), v.min.x -= n, v.min.y -= o, v.max.x += i, v.max.y += r, f.setFromUnitVectors(ln, d), E && f.premultiply(hn.invert()), f.premultiply(this._yAxisUpSpace);
    const g = v.getSize(ue), x = v.getCenter(we).applyQuaternion(f);
    if (Ut(this._camera)) {
      const M = this.getDistanceToFitBox(g.x, g.y, g.z, s);
      a.push(this.moveTo(x.x, x.y, x.z, t)), a.push(this.dollyTo(M, t)), a.push(this.setFocalOffset(0, 0, 0, t));
    } else if (wt(this._camera)) {
      const M = this._camera, y = M.right - M.left, m = M.top - M.bottom, A = s ? Math.max(y / g.x, m / g.y) : Math.min(y / g.x, m / g.y);
      a.push(this.moveTo(x.x, x.y, x.z, t)), a.push(this.zoomTo(A, t)), a.push(this.setFocalOffset(0, 0, 0, t));
    }
    return Promise.all(a);
  }
  /**
   * Fit the viewport to the sphere or the bounding sphere of the object.
   * @param sphereOrMesh
   * @param enableTransition
   * @category Methods
   */
  fitToSphere(e, t) {
    const s = [], i = e instanceof ne.Sphere ? cn2.copy(e) : _gs.createBoundingSphere(e, cn2);
    if (s.push(this.moveTo(i.center.x, i.center.y, i.center.z, t)), Ut(this._camera)) {
      const o = this.getDistanceToFitSphere(i.radius);
      s.push(this.dollyTo(o, t));
    } else if (wt(this._camera)) {
      const o = this._camera.right - this._camera.left, r = this._camera.top - this._camera.bottom, a = 2 * i.radius, c = Math.min(o / a, r / a);
      s.push(this.zoomTo(c, t));
    }
    return s.push(this.setFocalOffset(0, 0, 0, t)), Promise.all(s);
  }
  /**
   * Look at the `target` from the `position`.
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setLookAt(e, t, s, n, i, o, r = false) {
    this._isUserControllingRotate = false, this._isUserControllingDolly = false, this._isUserControllingTruck = false, this._lastDollyDirection = Kt.NONE, this._changedDolly = 0;
    const a = we.set(n, i, o), c = ue.set(e, t, s);
    this._targetEnd.copy(a), this._sphericalEnd.setFromVector3(c.sub(a).applyQuaternion(this._yAxisUpSpace)), this.normalizeRotations(), this._needsUpdate = true, r || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
    const u = !r || be(this._target.x, this._targetEnd.x, this.restThreshold) && be(this._target.y, this._targetEnd.y, this.restThreshold) && be(this._target.z, this._targetEnd.z, this.restThreshold) && be(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && be(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && be(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(u);
  }
  /**
   * Similar to setLookAt, but it interpolates between two states.
   * @param positionAX
   * @param positionAY
   * @param positionAZ
   * @param targetAX
   * @param targetAY
   * @param targetAZ
   * @param positionBX
   * @param positionBY
   * @param positionBZ
   * @param targetBX
   * @param targetBY
   * @param targetBZ
   * @param t
   * @param enableTransition
   * @category Methods
   */
  lerpLookAt(e, t, s, n, i, o, r, a, c, u, h, d, f, E = false) {
    this._isUserControllingRotate = false, this._isUserControllingDolly = false, this._isUserControllingTruck = false, this._lastDollyDirection = Kt.NONE, this._changedDolly = 0;
    const v = ue.set(n, i, o), g = we.set(e, t, s);
    We.setFromVector3(g.sub(v).applyQuaternion(this._yAxisUpSpace));
    const x = Qt.set(u, h, d), M = we.set(r, a, c);
    as.setFromVector3(M.sub(x).applyQuaternion(this._yAxisUpSpace)), this._targetEnd.copy(v.lerp(x, f));
    const y = as.theta - We.theta, m = as.phi - We.phi, A = as.radius - We.radius;
    this._sphericalEnd.set(We.radius + A * f, We.phi + m * f, We.theta + y * f), this.normalizeRotations(), this._needsUpdate = true, E || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
    const b = !E || be(this._target.x, this._targetEnd.x, this.restThreshold) && be(this._target.y, this._targetEnd.y, this.restThreshold) && be(this._target.z, this._targetEnd.z, this.restThreshold) && be(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && be(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && be(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(b);
  }
  /**
   * Set angle and distance by given position.
   * An alias of `setLookAt()`, without target change. Thus keep gazing at the current target
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param enableTransition
   * @category Methods
   */
  setPosition(e, t, s, n = false) {
    return this.setLookAt(e, t, s, this._targetEnd.x, this._targetEnd.y, this._targetEnd.z, n);
  }
  /**
   * Set the target position where gaze at.
   * An alias of `setLookAt()`, without position change. Thus keep the same position.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setTarget(e, t, s, n = false) {
    const i = this.getPosition(ue), o = this.setLookAt(i.x, i.y, i.z, e, t, s, n);
    return this._sphericalEnd.phi = ot(this._sphericalEnd.phi, this.minPolarAngle, this.maxPolarAngle), o;
  }
  /**
   * Set focal offset using the screen parallel coordinates. z doesn't affect in Orthographic as with Dolly.
   * @param x
   * @param y
   * @param z
   * @param enableTransition
   * @category Methods
   */
  setFocalOffset(e, t, s, n = false) {
    this._isUserControllingOffset = false, this._focalOffsetEnd.set(e, t, s), this._needsUpdate = true, n || this._focalOffset.copy(this._focalOffsetEnd);
    const i = !n || be(this._focalOffset.x, this._focalOffsetEnd.x, this.restThreshold) && be(this._focalOffset.y, this._focalOffsetEnd.y, this.restThreshold) && be(this._focalOffset.z, this._focalOffsetEnd.z, this.restThreshold);
    return this._createOnRestPromise(i);
  }
  /**
   * Set orbit point without moving the camera.
   * SHOULD NOT RUN DURING ANIMATIONS. `setOrbitPoint()` will immediately fix the positions.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @category Methods
   */
  setOrbitPoint(e, t, s) {
    this._camera.updateMatrixWorld(), at.setFromMatrixColumn(this._camera.matrixWorldInverse, 0), lt.setFromMatrixColumn(this._camera.matrixWorldInverse, 1), Bt.setFromMatrixColumn(this._camera.matrixWorldInverse, 2);
    const n = ue.set(e, t, s), i = n.distanceTo(this._camera.position), o = n.sub(this._camera.position);
    at.multiplyScalar(o.x), lt.multiplyScalar(o.y), Bt.multiplyScalar(o.z), ue.copy(at).add(lt).add(Bt), ue.z = ue.z + i, this.dollyTo(i, false), this.setFocalOffset(-ue.x, ue.y, -ue.z, false), this.moveTo(e, t, s, false);
  }
  /**
   * Set the boundary box that encloses the target of the camera. box3 is in THREE.Box3
   * @param box3
   * @category Methods
   */
  setBoundary(e) {
    if (!e) {
      this._boundary.min.set(-1 / 0, -1 / 0, -1 / 0), this._boundary.max.set(1 / 0, 1 / 0, 1 / 0), this._needsUpdate = true;
      return;
    }
    this._boundary.copy(e), this._boundary.clampPoint(this._targetEnd, this._targetEnd), this._needsUpdate = true;
  }
  /**
   * Set (or unset) the current viewport.
   * Set this when you want to use renderer viewport and .dollyToCursor feature at the same time.
   * @param viewportOrX
   * @param y
   * @param width
   * @param height
   * @category Methods
   */
  setViewport(e, t, s, n) {
    if (e === null) {
      this._viewport = null;
      return;
    }
    this._viewport = this._viewport || new ne.Vector4(), typeof e == "number" ? this._viewport.set(e, t, s, n) : this._viewport.copy(e);
  }
  /**
   * Calculate the distance to fit the box.
   * @param width box width
   * @param height box height
   * @param depth box depth
   * @returns distance
   * @category Methods
   */
  getDistanceToFitBox(e, t, s, n = false) {
    if (an(this._camera, "getDistanceToFitBox"))
      return this._spherical.radius;
    const i = e / t, o = this._camera.getEffectiveFOV() * ns, r = this._camera.aspect;
    return ((n ? i > r : i < r) ? t : e / r) * 0.5 / Math.tan(o * 0.5) + s * 0.5;
  }
  /**
   * Calculate the distance to fit the sphere.
   * @param radius sphere radius
   * @returns distance
   * @category Methods
   */
  getDistanceToFitSphere(e) {
    if (an(this._camera, "getDistanceToFitSphere"))
      return this._spherical.radius;
    const t = this._camera.getEffectiveFOV() * ns, s = Math.atan(Math.tan(t * 0.5) * this._camera.aspect) * 2, n = 1 < this._camera.aspect ? t : s;
    return e / Math.sin(n * 0.5);
  }
  /**
   * Returns the orbit center position, where the camera looking at.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getTarget(e, t = true) {
    return (e && e.isVector3 ? e : new ne.Vector3()).copy(t ? this._targetEnd : this._target);
  }
  /**
   * Returns the camera position.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getPosition(e, t = true) {
    return (e && e.isVector3 ? e : new ne.Vector3()).setFromSpherical(t ? this._sphericalEnd : this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(t ? this._targetEnd : this._target);
  }
  /**
   * Returns the spherical coordinates of the orbit.
   * @param out The receiving Spherical instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getSpherical(e, t = true) {
    return (e && e instanceof ne.Spherical ? e : new ne.Spherical()).copy(t ? this._sphericalEnd : this._spherical);
  }
  /**
   * Returns the focal offset, which is how much the camera appears to be translated in screen parallel coordinates.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getFocalOffset(e, t = true) {
    return (e && e.isVector3 ? e : new ne.Vector3()).copy(t ? this._focalOffsetEnd : this._focalOffset);
  }
  /**
   * Normalize camera azimuth angle rotation between 0 and 360 degrees.
   * @category Methods
   */
  normalizeRotations() {
    this._sphericalEnd.theta = this._sphericalEnd.theta % Wt, this._sphericalEnd.theta < 0 && (this._sphericalEnd.theta += Wt), this._spherical.theta += Wt * Math.round((this._sphericalEnd.theta - this._spherical.theta) / Wt);
  }
  /**
   * Reset all rotation and position to defaults.
   * @param enableTransition
   * @category Methods
   */
  reset(e = false) {
    if (!be(this._camera.up.x, this._cameraUp0.x) || !be(this._camera.up.y, this._cameraUp0.y) || !be(this._camera.up.z, this._cameraUp0.z)) {
      this._camera.up.copy(this._cameraUp0);
      const s = this.getPosition(ue);
      this.updateCameraUp(), this.setPosition(s.x, s.y, s.z);
    }
    const t = [
      this.setLookAt(this._position0.x, this._position0.y, this._position0.z, this._target0.x, this._target0.y, this._target0.z, e),
      this.setFocalOffset(this._focalOffset0.x, this._focalOffset0.y, this._focalOffset0.z, e),
      this.zoomTo(this._zoom0, e)
    ];
    return Promise.all(t);
  }
  /**
   * Set current camera position as the default position.
   * @category Methods
   */
  saveState() {
    this._cameraUp0.copy(this._camera.up), this.getTarget(this._target0), this.getPosition(this._position0), this._zoom0 = this._zoom, this._focalOffset0.copy(this._focalOffset);
  }
  /**
   * Sync camera-up direction.
   * When camera-up vector is changed, `.updateCameraUp()` must be called.
   * @category Methods
   */
  updateCameraUp() {
    this._yAxisUpSpace.setFromUnitVectors(this._camera.up, Cs), this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).invert();
  }
  /**
   * Apply current camera-up direction to the camera.
   * The orbit system will be re-initialized with the current position.
   * @category Methods
   */
  applyCameraUp() {
    const e = ue.subVectors(this._target, this._camera.position).normalize(), t = we.crossVectors(e, this._camera.up);
    this._camera.up.crossVectors(t, e).normalize(), this._camera.updateMatrixWorld();
    const s = this.getPosition(ue);
    this.updateCameraUp(), this.setPosition(s.x, s.y, s.z);
  }
  /**
   * Update camera position and directions.
   * This should be called in your tick loop every time, and returns true if re-rendering is needed.
   * @param delta
   * @returns updated
   * @category Methods
   */
  update(e) {
    const t = this._sphericalEnd.theta - this._spherical.theta, s = this._sphericalEnd.phi - this._spherical.phi, n = this._sphericalEnd.radius - this._spherical.radius, i = ii.subVectors(this._targetEnd, this._target), o = oi.subVectors(this._focalOffsetEnd, this._focalOffset), r = this._zoomEnd - this._zoom;
    if (Pe(t))
      this._thetaVelocity.value = 0, this._spherical.theta = this._sphericalEnd.theta;
    else {
      const h = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.theta = Ls(this._spherical.theta, this._sphericalEnd.theta, this._thetaVelocity, h, 1 / 0, e), this._needsUpdate = true;
    }
    if (Pe(s))
      this._phiVelocity.value = 0, this._spherical.phi = this._sphericalEnd.phi;
    else {
      const h = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.phi = Ls(this._spherical.phi, this._sphericalEnd.phi, this._phiVelocity, h, 1 / 0, e), this._needsUpdate = true;
    }
    if (Pe(n))
      this._radiusVelocity.value = 0, this._spherical.radius = this._sphericalEnd.radius;
    else {
      const h = this._isUserControllingDolly ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.radius = Ls(this._spherical.radius, this._sphericalEnd.radius, this._radiusVelocity, h, this.maxSpeed, e), this._needsUpdate = true;
    }
    if (Pe(i.x) && Pe(i.y) && Pe(i.z))
      this._targetVelocity.set(0, 0, 0), this._target.copy(this._targetEnd);
    else {
      const h = this._isUserControllingTruck ? this.draggingSmoothTime : this.smoothTime;
      si(this._target, this._targetEnd, this._targetVelocity, h, this.maxSpeed, e, this._target), this._needsUpdate = true;
    }
    if (Pe(o.x) && Pe(o.y) && Pe(o.z))
      this._focalOffsetVelocity.set(0, 0, 0), this._focalOffset.copy(this._focalOffsetEnd);
    else {
      const h = this._isUserControllingOffset ? this.draggingSmoothTime : this.smoothTime;
      si(this._focalOffset, this._focalOffsetEnd, this._focalOffsetVelocity, h, this.maxSpeed, e, this._focalOffset), this._needsUpdate = true;
    }
    if (Pe(r))
      this._zoomVelocity.value = 0, this._zoom = this._zoomEnd;
    else {
      const h = this._isUserControllingZoom ? this.draggingSmoothTime : this.smoothTime;
      this._zoom = Ls(this._zoom, this._zoomEnd, this._zoomVelocity, h, 1 / 0, e);
    }
    if (this.dollyToCursor) {
      if (Ut(this._camera) && this._changedDolly !== 0) {
        const h = this._spherical.radius - this._lastDistance, d = this._camera, f = this._getCameraDirection(rs), E = ue.copy(f).cross(d.up).normalize();
        E.lengthSq() === 0 && (E.x = 1);
        const v = we.crossVectors(E, f), g = this._sphericalEnd.radius * Math.tan(d.getEffectiveFOV() * ns * 0.5), M = (this._sphericalEnd.radius - h - this._sphericalEnd.radius) / this._sphericalEnd.radius, y = Qt.copy(this._targetEnd).add(E.multiplyScalar(this._dollyControlCoord.x * g * d.aspect)).add(v.multiplyScalar(this._dollyControlCoord.y * g)), m = ue.copy(this._targetEnd).lerp(y, M), A = this._lastDollyDirection === Kt.IN && this._spherical.radius <= this.minDistance, b = this._lastDollyDirection === Kt.OUT && this.maxDistance <= this._spherical.radius;
        if (this.infinityDolly && (A || b)) {
          this._sphericalEnd.radius -= h, this._spherical.radius -= h;
          const T = we.copy(f).multiplyScalar(-h);
          m.add(T);
        }
        this._boundary.clampPoint(m, m);
        const _ = we.subVectors(m, this._targetEnd);
        this._targetEnd.copy(m), this._target.add(_), this._changedDolly -= h, Pe(this._changedDolly) && (this._changedDolly = 0);
      } else if (wt(this._camera) && this._changedZoom !== 0) {
        const h = this._zoom - this._lastZoom, d = this._camera, f = ue.set(this._dollyControlCoord.x, this._dollyControlCoord.y, (d.near + d.far) / (d.near - d.far)).unproject(d), E = we.set(0, 0, -1).applyQuaternion(d.quaternion), v = Qt.copy(f).add(E.multiplyScalar(-f.dot(d.up))), x = -(this._zoom - h - this._zoom) / this._zoom, M = this._getCameraDirection(rs), y = this._targetEnd.dot(M), m = ue.copy(this._targetEnd).lerp(v, x), A = m.dot(M), b = M.multiplyScalar(A - y);
        m.sub(b), this._boundary.clampPoint(m, m);
        const _ = we.subVectors(m, this._targetEnd);
        this._targetEnd.copy(m), this._target.add(_), this._changedZoom -= h, Pe(this._changedZoom) && (this._changedZoom = 0);
      }
    }
    this._camera.zoom !== this._zoom && (this._camera.zoom = this._zoom, this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = true);
    const a = this._collisionTest();
    this._spherical.radius = Math.min(this._spherical.radius, a), this._spherical.makeSafe(), this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target), this._camera.lookAt(this._target), (!Pe(this._focalOffset.x) || !Pe(this._focalOffset.y) || !Pe(this._focalOffset.z)) && (this._camera.updateMatrixWorld(), at.setFromMatrixColumn(this._camera.matrix, 0), lt.setFromMatrixColumn(this._camera.matrix, 1), Bt.setFromMatrixColumn(this._camera.matrix, 2), at.multiplyScalar(this._focalOffset.x), lt.multiplyScalar(-this._focalOffset.y), Bt.multiplyScalar(this._focalOffset.z), ue.copy(at).add(lt).add(Bt), this._camera.position.add(ue)), this._boundaryEnclosesCamera && this._encloseToBoundary(this._camera.position.copy(this._target), ue.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse), 1);
    const u = this._needsUpdate;
    return u && !this._updatedLastTime ? (this._hasRested = false, this.dispatchEvent({ type: "wake" }), this.dispatchEvent({ type: "update" })) : u ? (this.dispatchEvent({ type: "update" }), Pe(t, this.restThreshold) && Pe(s, this.restThreshold) && Pe(n, this.restThreshold) && Pe(i.x, this.restThreshold) && Pe(i.y, this.restThreshold) && Pe(i.z, this.restThreshold) && Pe(o.x, this.restThreshold) && Pe(o.y, this.restThreshold) && Pe(o.z, this.restThreshold) && Pe(r, this.restThreshold) && !this._hasRested && (this._hasRested = true, this.dispatchEvent({ type: "rest" }))) : !u && this._updatedLastTime && this.dispatchEvent({ type: "sleep" }), this._lastDistance = this._spherical.radius, this._lastZoom = this._zoom, this._updatedLastTime = u, this._needsUpdate = false, u;
  }
  /**
   * Get all state in JSON string
   * @category Methods
   */
  toJSON() {
    return JSON.stringify({
      enabled: this._enabled,
      minDistance: this.minDistance,
      maxDistance: is(this.maxDistance),
      minZoom: this.minZoom,
      maxZoom: is(this.maxZoom),
      minPolarAngle: this.minPolarAngle,
      maxPolarAngle: is(this.maxPolarAngle),
      minAzimuthAngle: is(this.minAzimuthAngle),
      maxAzimuthAngle: is(this.maxAzimuthAngle),
      smoothTime: this.smoothTime,
      draggingSmoothTime: this.draggingSmoothTime,
      dollySpeed: this.dollySpeed,
      truckSpeed: this.truckSpeed,
      dollyToCursor: this.dollyToCursor,
      verticalDragToForward: this.verticalDragToForward,
      target: this._targetEnd.toArray(),
      position: ue.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),
      zoom: this._zoomEnd,
      focalOffset: this._focalOffsetEnd.toArray(),
      target0: this._target0.toArray(),
      position0: this._position0.toArray(),
      zoom0: this._zoom0,
      focalOffset0: this._focalOffset0.toArray()
    });
  }
  /**
   * Reproduce the control state with JSON. enableTransition is where anim or not in a boolean.
   * @param json
   * @param enableTransition
   * @category Methods
   */
  fromJSON(e, t = false) {
    const s = JSON.parse(e);
    this.enabled = s.enabled, this.minDistance = s.minDistance, this.maxDistance = os(s.maxDistance), this.minZoom = s.minZoom, this.maxZoom = os(s.maxZoom), this.minPolarAngle = s.minPolarAngle, this.maxPolarAngle = os(s.maxPolarAngle), this.minAzimuthAngle = os(s.minAzimuthAngle), this.maxAzimuthAngle = os(s.maxAzimuthAngle), this.smoothTime = s.smoothTime, this.draggingSmoothTime = s.draggingSmoothTime, this.dollySpeed = s.dollySpeed, this.truckSpeed = s.truckSpeed, this.dollyToCursor = s.dollyToCursor, this.verticalDragToForward = s.verticalDragToForward, this._target0.fromArray(s.target0), this._position0.fromArray(s.position0), this._zoom0 = s.zoom0, this._focalOffset0.fromArray(s.focalOffset0), this.moveTo(s.target[0], s.target[1], s.target[2], t), We.setFromVector3(ue.fromArray(s.position).sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace)), this.rotateTo(We.theta, We.phi, t), this.dollyTo(We.radius, t), this.zoomTo(s.zoom, t), this.setFocalOffset(s.focalOffset[0], s.focalOffset[1], s.focalOffset[2], t), this._needsUpdate = true;
  }
  /**
   * Attach all internal event handlers to enable drag control.
   * @category Methods
   */
  connect(e) {
    if (this._domElement) {
      console.warn("camera-controls is already connected.");
      return;
    }
    e.setAttribute("data-camera-controls-version", il), this._addAllEventListeners(e);
  }
  /**
   * Detach all internal event handlers to disable drag control.
   */
  disconnect() {
    this.cancel(), this._removeAllEventListeners(), this._domElement && (this._domElement.removeAttribute("data-camera-controls-version"), this._domElement = void 0);
  }
  /**
   * Dispose the cameraControls instance itself, remove all eventListeners.
   * @category Methods
   */
  dispose() {
    this.removeAllEventListeners(), this.disconnect();
  }
  // it's okay to expose public though
  _getTargetDirection(e) {
    return e.setFromSpherical(this._spherical).divideScalar(this._spherical.radius).applyQuaternion(this._yAxisUpSpaceInverse);
  }
  // it's okay to expose public though
  _getCameraDirection(e) {
    return this._getTargetDirection(e).negate();
  }
  _findPointerById(e) {
    return this._activePointers.find((t) => t.pointerId === e);
  }
  _findPointerByMouseButton(e) {
    return this._activePointers.find((t) => t.mouseButton === e);
  }
  _disposePointer(e) {
    this._activePointers.splice(this._activePointers.indexOf(e), 1);
  }
  _encloseToBoundary(e, t, s) {
    const n = t.lengthSq();
    if (n === 0)
      return e;
    const i = we.copy(t).add(e), r = this._boundary.clampPoint(i, Qt).sub(i), a = r.lengthSq();
    if (a === 0)
      return e.add(t);
    if (a === n)
      return e;
    if (s === 0)
      return e.add(t).add(r);
    {
      const c = 1 + s * a / t.dot(r);
      return e.add(we.copy(t).multiplyScalar(c)).add(r.multiplyScalar(1 - s));
    }
  }
  _updateNearPlaneCorners() {
    if (Ut(this._camera)) {
      const e = this._camera, t = e.near, s = e.getEffectiveFOV() * ns, n = Math.tan(s * 0.5) * t, i = n * e.aspect;
      this._nearPlaneCorners[0].set(-i, -n, 0), this._nearPlaneCorners[1].set(i, -n, 0), this._nearPlaneCorners[2].set(i, n, 0), this._nearPlaneCorners[3].set(-i, n, 0);
    } else if (wt(this._camera)) {
      const e = this._camera, t = 1 / e.zoom, s = e.left * t, n = e.right * t, i = e.top * t, o = e.bottom * t;
      this._nearPlaneCorners[0].set(s, i, 0), this._nearPlaneCorners[1].set(n, i, 0), this._nearPlaneCorners[2].set(n, o, 0), this._nearPlaneCorners[3].set(s, o, 0);
    }
  }
  // lateUpdate
  _collisionTest() {
    let e = 1 / 0;
    if (!(this.colliderMeshes.length >= 1) || an(this._camera, "_collisionTest"))
      return e;
    const s = this._getTargetDirection(rs);
    un.lookAt(ni, s, this._camera.up);
    for (let n = 0; n < 4; n++) {
      const i = we.copy(this._nearPlaneCorners[n]);
      i.applyMatrix4(un);
      const o = Qt.addVectors(this._target, i);
      Is.set(o, s), Is.far = this._spherical.radius + 1;
      const r = Is.intersectObjects(this.colliderMeshes);
      r.length !== 0 && r[0].distance < e && (e = r[0].distance);
    }
    return e;
  }
  /**
   * Get its client rect and package into given `DOMRect` .
   */
  _getClientRect(e) {
    if (!this._domElement)
      return;
    const t = this._domElement.getBoundingClientRect();
    return e.x = t.left, e.y = t.top, this._viewport ? (e.x += this._viewport.x, e.y += t.height - this._viewport.w - this._viewport.y, e.width = this._viewport.z, e.height = this._viewport.w) : (e.width = t.width, e.height = t.height), e;
  }
  _createOnRestPromise(e) {
    return e ? Promise.resolve() : (this._hasRested = false, this.dispatchEvent({ type: "transitionstart" }), new Promise((t) => {
      const s = () => {
        this.removeEventListener("rest", s), t();
      };
      this.addEventListener("rest", s);
    }));
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _addAllEventListeners(e) {
  }
  _removeAllEventListeners() {
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  get dampingFactor() {
    return console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead."), 0;
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  set dampingFactor(e) {
    console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.");
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  get draggingDampingFactor() {
    return console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead."), 0;
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  set draggingDampingFactor(e) {
    console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.");
  }
  static createBoundingSphere(e, t = new ne.Sphere()) {
    const s = t, n = s.center;
    qt.makeEmpty(), e.traverseVisible((o) => {
      o.isMesh && qt.expandByObject(o);
    }), qt.getCenter(n);
    let i = 0;
    return e.traverseVisible((o) => {
      if (!o.isMesh)
        return;
      const r = o, a = r.geometry.clone();
      a.applyMatrix4(r.matrixWorld);
      const u = a.attributes.position;
      for (let h = 0, d = u.count; h < d; h++)
        ue.fromBufferAttribute(u, h), i = Math.max(i, n.distanceToSquared(ue));
    }), s.radius = Math.sqrt(i), s;
  }
};
var al = ["min-polar-angle", "max-polar-angle", "min-azimuth-angle", "max-azimuth-angle", "distance", "min-distance", "max-distance", "infinity-dolly", "min-zoom", "max-zoom", "smooth-time", "dragging-smooth-time", "max-speed", "azimuth-rotate-speed", "polar-rotate-speed", "dolly-speed", "dolly-drag-inverted", "truck-speed", "dolly-to-cursor", "drag-to-offset", "vertical-drag-to-forward", "boundary-friction", "rest-threshold", "collider-meshes", "args"];
var Rc = defineComponent({
  __name: "CameraControls",
  props: {
    makeDefault: { type: Boolean, default: false },
    camera: {},
    domElement: {},
    minPolarAngle: { default: 0 },
    maxPolarAngle: { default: Math.PI },
    minAzimuthAngle: { default: -1 / 0 },
    maxAzimuthAngle: { default: 1 / 0 },
    distance: { default: 8 },
    minDistance: { default: Number.EPSILON },
    maxDistance: { default: 1 / 0 },
    infinityDolly: { type: Boolean, default: false },
    minZoom: { default: 0.01 },
    maxZoom: { default: 1 / 0 },
    smoothTime: { default: 0.25 },
    draggingSmoothTime: { default: 0.125 },
    maxSpeed: { default: 1 / 0 },
    azimuthRotateSpeed: { default: 1 },
    polarRotateSpeed: { default: 1 },
    dollySpeed: { default: 1 },
    dollyDragInverted: { type: Boolean, default: false },
    truckSpeed: { default: 2 },
    dollyToCursor: { type: Boolean, default: false },
    dragToOffset: { type: Boolean, default: false },
    verticalDragToForward: { type: Boolean, default: false },
    boundaryFriction: { default: 0 },
    restThreshold: { default: 0.01 },
    colliderMeshes: { default: () => [] },
    mouseButtons: {},
    touches: {}
  },
  emits: ["change", "start", "end"],
  setup(l, { expose: e, emit: t }) {
    const s = l, {
      makeDefault: n,
      minPolarAngle: i,
      maxPolarAngle: o,
      minAzimuthAngle: r,
      maxAzimuthAngle: a,
      distance: c,
      minDistance: u,
      maxDistance: h,
      infinityDolly: d,
      minZoom: f,
      maxZoom: E,
      smoothTime: v,
      draggingSmoothTime: g,
      maxSpeed: x,
      azimuthRotateSpeed: M,
      polarRotateSpeed: y,
      dollySpeed: m,
      dollyDragInverted: A,
      truckSpeed: b,
      dollyToCursor: _,
      dragToOffset: T,
      verticalDragToForward: L2,
      boundaryFriction: B,
      restThreshold: k,
      colliderMeshes: N
    } = toRefs(s), $ = {
      Box3,
      MathUtils: {
        clamp: MathUtils.clamp
      },
      Matrix4,
      Quaternion,
      Raycaster,
      Sphere,
      Spherical,
      Vector2,
      Vector3,
      Vector4
    };
    gs.install({ THREE: $ });
    const { camera: Q, renderer: Z, extend: me, controls: X } = nt(), z = ref(null);
    me({ CameraControls: gs }), watchEffect(() => {
      ce(), z.value && n.value ? X.value = z.value : X.value = null;
    });
    function ce() {
      Fe(z.value, "update", () => t("change", z.value)), Fe(z.value, "controlend", () => t("end", z.value)), Fe(z.value, "controlstart", () => t("start", z.value));
    }
    const { onLoop: se } = ae();
    return se(({ delta: ae2 }) => {
      var I, O;
      (I = z.value) != null && I.enabled && ((O = z.value) == null || O.update(ae2));
    }), onUnmounted(() => {
      z.value && z.value.disconnect();
    }), e({
      value: z
    }), (ae2, I) => (ae2.camera || unref(Q)) && (ae2.domElement || unref(Z)) ? (openBlock(), createElementBlock("TresCameraControls", {
      key: 0,
      ref_key: "controlsRef",
      ref: z,
      "min-polar-angle": unref(i),
      "max-polar-angle": unref(o),
      "min-azimuth-angle": unref(r),
      "max-azimuth-angle": unref(a),
      distance: unref(c),
      "min-distance": unref(u),
      "max-distance": unref(h),
      "infinity-dolly": unref(d),
      "min-zoom": unref(f),
      "max-zoom": unref(E),
      "smooth-time": unref(v),
      "dragging-smooth-time": unref(g),
      "max-speed": unref(x),
      "azimuth-rotate-speed": unref(M),
      "polar-rotate-speed": unref(y),
      "dolly-speed": unref(m),
      "dolly-drag-inverted": unref(A),
      "truck-speed": unref(b),
      "dolly-to-cursor": unref(_),
      "drag-to-offset": unref(T),
      "vertical-drag-to-forward": unref(L2),
      "boundary-friction": unref(B),
      "rest-threshold": unref(k),
      "collider-meshes": unref(N),
      args: [ae2.camera || unref(Q), ae2.domElement || unref(Z).domElement]
    }, null, 8, al)) : createCommentVNode("", true);
  }
});
var ll = class extends MeshStandardMaterial {
  constructor(t = {}) {
    super(t);
    Ie(this, "_time");
    Ie(this, "_factor");
    this.setValues(t), this._time = { value: 0 }, this._factor = { value: 1 };
  }
  onBeforeCompile(t) {
    t.uniforms || (t.uniforms = {}), t.uniforms.time = this._time, t.uniforms.factor = this._factor, t.vertexShader = `
        uniform float time;
        uniform float factor;
        ${t.vertexShader}
      `, t.vertexShader = t.vertexShader.replace(
      "#include <begin_vertex>",
      `float theta = sin( time + position.y ) / 2.0 * factor;
          float c = cos( theta );
          float s = sin( theta );
          mat3 m = mat3( c, 0, s, 0, 1, 0, -s, 0, c );
          vec3 transformed = vec3( position ) * m;
          vNormal = vNormal * m;`
    );
  }
  get time() {
    return this._time.value;
  }
  set time(t) {
    this._time.value = t;
  }
  get factor() {
    return this._factor.value;
  }
  set factor(t) {
    this._factor.value = t;
  }
};
var cl = ["factor"];
var Cc = defineComponent({
  __name: "index",
  props: {
    speed: { default: 1 },
    factor: { default: 1 }
  },
  setup(l) {
    const e = l, t = shallowRef(), { extend: s } = nt();
    s({ MeshWobbleMaterial: ll });
    const { onLoop: n } = ae();
    return n(({ elapsed: i }) => {
      t.value && (t.value.time = i * (e == null ? void 0 : e.speed));
    }), (i, o) => (openBlock(), createElementBlock("TresMeshWobbleMaterial", mergeProps({
      ref_key: "materialRef",
      ref: t,
      factor: i.factor
    }, i.$attrs), null, 16, cl));
  }
});
function zt(l, e, t) {
  return Math.max(e, Math.min(t, l));
}
function hl(l, e) {
  return (l % e + e) % e;
}
function pn(l, e, t) {
  return (1 - t) * l + t * e;
}
var Cn = class _Cn {
  constructor(e = 0, t = 0) {
    _Cn.prototype.isVector2 = true, this.x = e, this.y = t;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return this.x = e, this.y = t, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x, s = this.y, n = e.elements;
    return this.x = n[0] * t + n[3] * s + n[6], this.y = n[1] * t + n[4] * s + n[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this;
  }
  clampLength(e, t) {
    const s = this.length();
    return this.divideScalar(s || 1).multiplyScalar(Math.max(e, Math.min(t, s)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0)
      return Math.PI / 2;
    const s = this.dot(e) / t;
    return Math.acos(zt(s, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, s = this.y - e.y;
    return t * t + s * s;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
  }
  lerpVectors(e, t, s) {
    return this.x = e.x + (t.x - e.x) * s, this.y = e.y + (t.y - e.y) * s, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this;
  }
  rotateAround(e, t) {
    const s = Math.cos(t), n = Math.sin(t), i = this.x - e.x, o = this.y - e.y;
    return this.x = i * s - o * n + e.x, this.y = i * n + o * s + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
};
var mt = "srgb";
var In = "srgb-linear";
var Ki = "display-p3";
var Ts = class _Ts {
  constructor(e, t, s, n, i, o, r, a, c) {
    _Ts.prototype.isMatrix3 = true, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, s, n, i, o, r, a, c);
  }
  set(e, t, s, n, i, o, r, a, c) {
    const u = this.elements;
    return u[0] = e, u[1] = n, u[2] = r, u[3] = t, u[4] = i, u[5] = a, u[6] = s, u[7] = o, u[8] = c, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  copy(e) {
    const t = this.elements, s = e.elements;
    return t[0] = s[0], t[1] = s[1], t[2] = s[2], t[3] = s[3], t[4] = s[4], t[5] = s[5], t[6] = s[6], t[7] = s[7], t[8] = s[8], this;
  }
  extractBasis(e, t, s) {
    return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), s.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[4],
      t[8],
      t[1],
      t[5],
      t[9],
      t[2],
      t[6],
      t[10]
    ), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const s = e.elements, n = t.elements, i = this.elements, o = s[0], r = s[3], a = s[6], c = s[1], u = s[4], h = s[7], d = s[2], f = s[5], E = s[8], v = n[0], g = n[3], x = n[6], M = n[1], y = n[4], m = n[7], A = n[2], b = n[5], _ = n[8];
    return i[0] = o * v + r * M + a * A, i[3] = o * g + r * y + a * b, i[6] = o * x + r * m + a * _, i[1] = c * v + u * M + h * A, i[4] = c * g + u * y + h * b, i[7] = c * x + u * m + h * _, i[2] = d * v + f * M + E * A, i[5] = d * g + f * y + E * b, i[8] = d * x + f * m + E * _, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], s = e[1], n = e[2], i = e[3], o = e[4], r = e[5], a = e[6], c = e[7], u = e[8];
    return t * o * u - t * r * c - s * i * u + s * r * a + n * i * c - n * o * a;
  }
  invert() {
    const e = this.elements, t = e[0], s = e[1], n = e[2], i = e[3], o = e[4], r = e[5], a = e[6], c = e[7], u = e[8], h = u * o - r * c, d = r * a - u * i, f = c * i - o * a, E = t * h + s * d + n * f;
    if (E === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const v = 1 / E;
    return e[0] = h * v, e[1] = (n * c - u * s) * v, e[2] = (r * s - n * o) * v, e[3] = d * v, e[4] = (u * t - n * a) * v, e[5] = (n * i - r * t) * v, e[6] = f * v, e[7] = (s * a - c * t) * v, e[8] = (o * t - s * i) * v, this;
  }
  transpose() {
    let e;
    const t = this.elements;
    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
  }
  setUvTransform(e, t, s, n, i, o, r) {
    const a = Math.cos(i), c = Math.sin(i);
    return this.set(
      s * a,
      s * c,
      -s * (a * o + c * r) + o + e,
      -n * c,
      n * a,
      -n * (-c * o + a * r) + r + t,
      0,
      0,
      1
    ), this;
  }
  //
  scale(e, t) {
    return this.premultiply(dn.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(dn.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(dn.makeTranslation(e, t)), this;
  }
  // for 2D Transforms
  makeTranslation(e, t) {
    return e.isVector2 ? this.set(
      1,
      0,
      e.x,
      0,
      1,
      e.y,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      e,
      0,
      1,
      t,
      0,
      0,
      1
    ), this;
  }
  makeRotation(e) {
    const t = Math.cos(e), s = Math.sin(e);
    return this.set(
      t,
      -s,
      0,
      s,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, t) {
    return this.set(
      e,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  //
  equals(e) {
    const t = this.elements, s = e.elements;
    for (let n = 0; n < 9; n++)
      if (t[n] !== s[n])
        return false;
    return true;
  }
  fromArray(e, t = 0) {
    for (let s = 0; s < 9; s++)
      this.elements[s] = e[s + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const s = this.elements;
    return e[t] = s[0], e[t + 1] = s[1], e[t + 2] = s[2], e[t + 3] = s[3], e[t + 4] = s[4], e[t + 5] = s[5], e[t + 6] = s[6], e[t + 7] = s[7], e[t + 8] = s[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
};
var dn = new Ts();
function fn(l) {
  return l < 0.04045 ? l * 0.0773993808 : Math.pow(l * 0.9478672986 + 0.0521327014, 2.4);
}
function mn(l) {
  return l < 31308e-7 ? l * 12.92 : 1.055 * Math.pow(l, 0.41666) - 0.055;
}
var ul = new Ts().fromArray([
  0.8224621,
  0.0331941,
  0.0170827,
  0.177538,
  0.9668058,
  0.0723974,
  -1e-7,
  1e-7,
  0.9105199
]);
var pl = new Ts().fromArray([
  1.2249401,
  -0.0420569,
  -0.0196376,
  -0.2249404,
  1.0420571,
  -0.0786361,
  1e-7,
  0,
  1.0982735
]);
function dl(l) {
  return l.convertSRGBToLinear().applyMatrix3(pl);
}
function fl(l) {
  return l.applyMatrix3(ul).convertLinearToSRGB();
}
var ml = {
  [In]: (l) => l,
  [mt]: (l) => l.convertSRGBToLinear(),
  [Ki]: dl
};
var gl = {
  [In]: (l) => l,
  [mt]: (l) => l.convertLinearToSRGB(),
  [Ki]: fl
};
var nt2 = {
  enabled: true,
  get legacyMode() {
    return console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."), !this.enabled;
  },
  set legacyMode(l) {
    console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."), this.enabled = !l;
  },
  get workingColorSpace() {
    return In;
  },
  set workingColorSpace(l) {
    console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
  },
  convert: function(l, e, t) {
    if (this.enabled === false || e === t || !e || !t)
      return l;
    const s = ml[e], n = gl[t];
    if (s === void 0 || n === void 0)
      throw new Error(`Unsupported color space conversion, "${e}" to "${t}".`);
    return n(s(l));
  },
  fromWorkingColorSpace: function(l, e) {
    return this.convert(l, this.workingColorSpace, e);
  },
  toWorkingColorSpace: function(l, e) {
    return this.convert(l, e, this.workingColorSpace);
  }
};
var Wi = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
var it = { h: 0, s: 0, l: 0 };
var Ds = { h: 0, s: 0, l: 0 };
function gn(l, e, t) {
  return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? l + (e - l) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? l + (e - l) * 6 * (2 / 3 - t) : l;
}
var Bs = class {
  constructor(e, t, s) {
    return this.isColor = true, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, s);
  }
  set(e, t, s) {
    if (t === void 0 && s === void 0) {
      const n = e;
      n && n.isColor ? this.copy(n) : typeof n == "number" ? this.setHex(n) : typeof n == "string" && this.setStyle(n);
    } else
      this.setRGB(e, t, s);
    return this;
  }
  setScalar(e) {
    return this.r = e, this.g = e, this.b = e, this;
  }
  setHex(e, t = mt) {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, nt2.toWorkingColorSpace(this, t), this;
  }
  setRGB(e, t, s, n = nt2.workingColorSpace) {
    return this.r = e, this.g = t, this.b = s, nt2.toWorkingColorSpace(this, n), this;
  }
  setHSL(e, t, s, n = nt2.workingColorSpace) {
    if (e = hl(e, 1), t = zt(t, 0, 1), s = zt(s, 0, 1), t === 0)
      this.r = this.g = this.b = s;
    else {
      const i = s <= 0.5 ? s * (1 + t) : s + t - s * t, o = 2 * s - i;
      this.r = gn(o, i, e + 1 / 3), this.g = gn(o, i, e), this.b = gn(o, i, e - 1 / 3);
    }
    return nt2.toWorkingColorSpace(this, n), this;
  }
  setStyle(e, t = mt) {
    function s(i) {
      i !== void 0 && parseFloat(i) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
    }
    let n;
    if (n = /^(\w+)\(([^\)]*)\)/.exec(e)) {
      let i;
      const o = n[1], r = n[2];
      switch (o) {
        case "rgb":
        case "rgba":
          if (i = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r))
            return s(i[4]), this.setRGB(
              Math.min(255, parseInt(i[1], 10)) / 255,
              Math.min(255, parseInt(i[2], 10)) / 255,
              Math.min(255, parseInt(i[3], 10)) / 255,
              t
            );
          if (i = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r))
            return s(i[4]), this.setRGB(
              Math.min(100, parseInt(i[1], 10)) / 100,
              Math.min(100, parseInt(i[2], 10)) / 100,
              Math.min(100, parseInt(i[3], 10)) / 100,
              t
            );
          break;
        case "hsl":
        case "hsla":
          if (i = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r))
            return s(i[4]), this.setHSL(
              parseFloat(i[1]) / 360,
              parseFloat(i[2]) / 100,
              parseFloat(i[3]) / 100,
              t
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if (n = /^\#([A-Fa-f\d]+)$/.exec(e)) {
      const i = n[1], o = i.length;
      if (o === 3)
        return this.setRGB(
          parseInt(i.charAt(0), 16) / 15,
          parseInt(i.charAt(1), 16) / 15,
          parseInt(i.charAt(2), 16) / 15,
          t
        );
      if (o === 6)
        return this.setHex(parseInt(i, 16), t);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0)
      return this.setColorName(e, t);
    return this;
  }
  setColorName(e, t = mt) {
    const s = Wi[e.toLowerCase()];
    return s !== void 0 ? this.setHex(s, t) : console.warn("THREE.Color: Unknown color " + e), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  copySRGBToLinear(e) {
    return this.r = fn(e.r), this.g = fn(e.g), this.b = fn(e.b), this;
  }
  copyLinearToSRGB(e) {
    return this.r = mn(e.r), this.g = mn(e.g), this.b = mn(e.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = mt) {
    return nt2.fromWorkingColorSpace(Ve.copy(this), e), Math.round(zt(Ve.r * 255, 0, 255)) * 65536 + Math.round(zt(Ve.g * 255, 0, 255)) * 256 + Math.round(zt(Ve.b * 255, 0, 255));
  }
  getHexString(e = mt) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = nt2.workingColorSpace) {
    nt2.fromWorkingColorSpace(Ve.copy(this), t);
    const s = Ve.r, n = Ve.g, i = Ve.b, o = Math.max(s, n, i), r = Math.min(s, n, i);
    let a, c;
    const u = (r + o) / 2;
    if (r === o)
      a = 0, c = 0;
    else {
      const h = o - r;
      switch (c = u <= 0.5 ? h / (o + r) : h / (2 - o - r), o) {
        case s:
          a = (n - i) / h + (n < i ? 6 : 0);
          break;
        case n:
          a = (i - s) / h + 2;
          break;
        case i:
          a = (s - n) / h + 4;
          break;
      }
      a /= 6;
    }
    return e.h = a, e.s = c, e.l = u, e;
  }
  getRGB(e, t = nt2.workingColorSpace) {
    return nt2.fromWorkingColorSpace(Ve.copy(this), t), e.r = Ve.r, e.g = Ve.g, e.b = Ve.b, e;
  }
  getStyle(e = mt) {
    nt2.fromWorkingColorSpace(Ve.copy(this), e);
    const t = Ve.r, s = Ve.g, n = Ve.b;
    return e !== mt ? `color(${e} ${t.toFixed(3)} ${s.toFixed(3)} ${n.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(s * 255)},${Math.round(n * 255)})`;
  }
  offsetHSL(e, t, s) {
    return this.getHSL(it), it.h += e, it.s += t, it.l += s, this.setHSL(it.h, it.s, it.l), this;
  }
  add(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  }
  addColors(e, t) {
    return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
  }
  addScalar(e) {
    return this.r += e, this.g += e, this.b += e, this;
  }
  sub(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  }
  multiply(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  }
  multiplyScalar(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  lerp(e, t) {
    return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
  }
  lerpColors(e, t, s) {
    return this.r = e.r + (t.r - e.r) * s, this.g = e.g + (t.g - e.g) * s, this.b = e.b + (t.b - e.b) * s, this;
  }
  lerpHSL(e, t) {
    this.getHSL(it), e.getHSL(Ds);
    const s = pn(it.h, Ds.h, t), n = pn(it.s, Ds.s, t), i = pn(it.l, Ds.l, t);
    return this.setHSL(s, n, i), this;
  }
  setFromVector3(e) {
    return this.r = e.x, this.g = e.y, this.b = e.z, this;
  }
  applyMatrix3(e) {
    const t = this.r, s = this.g, n = this.b, i = e.elements;
    return this.r = i[0] * t + i[3] * s + i[6] * n, this.g = i[1] * t + i[4] * s + i[7] * n, this.b = i[2] * t + i[5] * s + i[8] * n, this;
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
  }
  fromBufferAttribute(e, t) {
    return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
};
var Ve = new Bs();
Bs.NAMES = Wi;
var yl = class extends MeshStandardMaterial {
  constructor(t = {}) {
    super();
    Ie(this, "isMeshPhysicalMaterial");
    Ie(this, "clearcoatMap");
    Ie(this, "clearcoatRoughness");
    Ie(this, "clearcoatRoughnessMap");
    Ie(this, "clearcoatNormalScale");
    Ie(this, "clearcoatNormalMap");
    Ie(this, "ior");
    Ie(this, "transmissionMap");
    Ie(this, "thickness");
    Ie(this, "thicknessMap");
    Ie(this, "attenuationDistance");
    Ie(this, "attenuationColor");
    Ie(this, "specularIntensity");
    Ie(this, "specularIntensityMap");
    Ie(this, "specularColor");
    Ie(this, "specularColorMap");
    Ie(this, "_clearcoat");
    Ie(this, "_transmission");
    this.isMeshPhysicalMaterial = true, this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Cn(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
      get() {
        return zt(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      },
      set(s) {
        this.ior = (1 + 0.4 * s) / (1 - 0.4 * s);
      }
    }), this.roughness = 0, this.transmissionMap = null, this.thickness = 0.5, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new Bs(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Bs(1, 1, 1), this.specularColorMap = null, this._clearcoat = 0.5, this._transmission = 1, this.setValues(t);
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(t) {
    this._clearcoat > 0 != t > 0 && this.version++, this._clearcoat = t;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(t) {
    this._transmission > 0 != t > 0 && this.version++, this._transmission = t;
  }
  copy(t) {
    return super.copy(t), this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.ior = t.ior, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this.thickness = t.thickness, this.thicknessMap = t.thicknessMap, this.attenuationDistance = t.attenuationDistance, this.attenuationColor.copy(t.attenuationColor), this.specularIntensity = t.specularIntensity, this.specularIntensityMap = t.specularIntensityMap, this.specularColor.copy(t.specularColor), this.specularColorMap = t.specularColorMap, this;
  }
};
var _l = yl;
var Ic = defineComponent({
  __name: "index",
  setup(l, { expose: e }) {
    const t = shallowRef(), { extend: s } = nt();
    return s({ MeshGlassMaterial: _l }), e({ MeshGlassMaterialClass: t }), (n, i) => (openBlock(), createElementBlock("TresMeshGlassMaterial", {
      ref_key: "MeshGlassMaterialClass",
      ref: t
    }, null, 512));
  }
});
var vl = ["args"];
var Tl = ["color"];
var Dc = defineComponent({
  __name: "Box",
  props: {
    args: { default: () => [1, 1, 1] },
    color: { default: "#ffffff" }
  },
  setup(l, { expose: e }) {
    const t = l, { args: s, color: n } = toRefs(t), i = shallowRef();
    return e({
      value: i
    }), (o, r) => (openBlock(), createElementBlock("TresMesh", mergeProps({
      ref_key: "boxRef",
      ref: i
    }, o.$attrs), [
      createBaseVNode("TresBoxGeometry", { args: unref(s) }, null, 8, vl),
      renderSlot(o.$slots, "default", {}, () => [
        createBaseVNode("TresMeshBasicMaterial", { color: unref(n) }, null, 8, Tl)
      ])
    ], 16));
  }
});
var El = ["args"];
var xl = ["color"];
var kc = defineComponent({
  __name: "Circle",
  props: {
    args: { default: () => [1, 32, 0, Math.PI * 2] },
    color: { default: "#ffffff" }
  },
  setup(l, { expose: e }) {
    const t = l, { args: s, color: n } = toRefs(t), i = shallowRef();
    return e({
      value: i
    }), (o, r) => (openBlock(), createElementBlock("TresMesh", mergeProps({
      ref_key: "circleRef",
      ref: i
    }, o.$attrs), [
      createBaseVNode("TresCircleGeometry", { args: unref(s) }, null, 8, El),
      renderSlot(o.$slots, "default", {}, () => [
        createBaseVNode("TresMeshBasicMaterial", { color: unref(n) }, null, 8, xl)
      ])
    ], 16));
  }
});
var wl = ["args"];
var bl = ["color"];
var Fc = defineComponent({
  __name: "Cone",
  props: {
    args: { default: () => [1, 1, 12, 12, false, 0, Math.PI * 2] },
    color: { default: "#ffffff" }
  },
  setup(l, { expose: e }) {
    const t = l, { args: s, color: n } = toRefs(t), i = shallowRef();
    return e({
      value: i
    }), (o, r) => (openBlock(), createElementBlock("TresMesh", mergeProps({
      ref_key: "coneRef",
      ref: i
    }, o.$attrs), [
      createBaseVNode("TresConeGeometry", { args: unref(s) }, null, 8, wl),
      renderSlot(o.$slots, "default", {}, () => [
        createBaseVNode("TresMeshBasicMaterial", { color: unref(n) }, null, 8, bl)
      ])
    ], 16));
  }
});
var Al = ["args"];
var Ml = ["color"];
var Uc = defineComponent({
  __name: "Dodecahedron",
  props: {
    args: { default: () => [1, 0] },
    color: { default: "#ffffff" }
  },
  setup(l, { expose: e }) {
    const t = l, { args: s, color: n } = toRefs(t), i = shallowRef();
    return e({
      value: i
    }), (o, r) => (openBlock(), createElementBlock("TresMesh", mergeProps({
      ref_key: "dodecahedronRef",
      ref: i
    }, o.$attrs), [
      createBaseVNode("TresDodecahedronGeometry", { args: unref(s) }, null, 8, Al),
      renderSlot(o.$slots, "default", {}, () => [
        createBaseVNode("TresMeshBasicMaterial", { color: unref(n) }, null, 8, Ml)
      ])
    ], 16));
  }
});
var Sl = ["args"];
var Pl = ["color"];
var Bc = defineComponent({
  __name: "Icosahedron",
  props: {
    args: { default: () => [1, 0] },
    color: { default: "#ffffff" }
  },
  setup(l, { expose: e }) {
    const t = l, { args: s, color: n } = toRefs(t), i = shallowRef();
    return e({
      value: i
    }), (o, r) => (openBlock(), createElementBlock("TresMesh", mergeProps({
      ref_key: "icosahedronRef",
      ref: i
    }, o.$attrs), [
      createBaseVNode("TresIcosahedronGeometry", { args: unref(s) }, null, 8, Sl),
      renderSlot(o.$slots, "default", {}, () => [
        createBaseVNode("TresMeshBasicMaterial", { color: unref(n) }, null, 8, Pl)
      ])
    ], 16));
  }
});
var Ol = ["args"];
var Ll = ["color"];
var Nc = defineComponent({
  __name: "Octahedron",
  props: {
    args: { default: () => [1, 0] },
    color: { default: "#ffffff" }
  },
  setup(l, { expose: e }) {
    const t = l, { args: s, color: n } = toRefs(t), i = shallowRef();
    return e({
      value: i
    }), (o, r) => (openBlock(), createElementBlock("TresMesh", mergeProps({
      ref_key: "octahedronRef",
      ref: i
    }, o.$attrs), [
      createBaseVNode("TresOctahedronGeometry", { args: unref(s) }, null, 8, Ol),
      renderSlot(o.$slots, "default", {}, () => [
        createBaseVNode("TresMeshBasicMaterial", { color: unref(n) }, null, 8, Ll)
      ])
    ], 16));
  }
});
var Rl = ["rotation"];
var Cl = ["args"];
var Il = ["color"];
var zc = defineComponent({
  __name: "Plane",
  props: {
    args: { default: () => [1, 1] },
    color: { default: "#ffffff" }
  },
  setup(l, { expose: e }) {
    const t = l, { args: s, color: n } = toRefs(t), i = shallowRef();
    return e({
      value: i
    }), (o, r) => (openBlock(), createElementBlock("TresMesh", mergeProps({
      ref_key: "planeRef",
      ref: i,
      rotation: [-Math.PI / 2, 0, 0]
    }, o.$attrs), [
      createBaseVNode("TresPlaneGeometry", { args: unref(s) }, null, 8, Cl),
      renderSlot(o.$slots, "default", {}, () => [
        createBaseVNode("TresMeshBasicMaterial", { color: unref(n) }, null, 8, Il)
      ])
    ], 16, Rl));
  }
});
var Dl = ["args"];
var kl = ["color"];
var Hc = defineComponent({
  __name: "Ring",
  props: {
    args: { default: () => [0.5, 1, 32] },
    color: { default: "#ffffff" }
  },
  setup(l, { expose: e }) {
    const t = l, { args: s, color: n } = toRefs(t), i = shallowRef();
    return e({
      value: i
    }), (o, r) => (openBlock(), createElementBlock("TresMesh", mergeProps({
      ref_key: "ringRef",
      ref: i
    }, o.$attrs), [
      createBaseVNode("TresRingGeometry", { args: unref(s) }, null, 8, Dl),
      renderSlot(o.$slots, "default", {}, () => [
        createBaseVNode("TresMeshBasicMaterial", { color: unref(n) }, null, 8, kl)
      ])
    ], 16));
  }
});
var Fl = ["args"];
var Ul = ["color"];
var Vc = defineComponent({
  __name: "Sphere",
  props: {
    args: { default: () => [2, 32, 16] },
    color: { default: "#ffffff" }
  },
  setup(l, { expose: e }) {
    const t = l, { args: s, color: n } = toRefs(t), i = shallowRef();
    return e({
      value: i
    }), (o, r) => (openBlock(), createElementBlock("TresMesh", mergeProps({
      ref_key: "sphereRef",
      ref: i
    }, o.$attrs), [
      createBaseVNode("TresSphereGeometry", { args: unref(s) }, null, 8, Fl),
      renderSlot(o.$slots, "default", {}, () => [
        createBaseVNode("TresMeshBasicMaterial", { color: unref(n) }, null, 8, Ul)
      ])
    ], 16));
  }
});
var Bl = ["rotation"];
var Nl = ["args"];
var zl = ["color"];
var Gc = defineComponent({
  __name: "Tetrahedron",
  props: {
    args: { default: () => [1, 0] },
    color: { default: "#ffffff" }
  },
  setup(l, { expose: e }) {
    const t = l, { args: s, color: n } = toRefs(t), i = shallowRef();
    return e({
      value: i
    }), (o, r) => (openBlock(), createElementBlock("TresMesh", mergeProps({
      ref_key: "tetrahedronRef",
      ref: i,
      rotation: [-Math.PI / 2, 0, 0]
    }, o.$attrs), [
      createBaseVNode("TresTetrahedronGeometry", { args: unref(s) }, null, 8, Nl),
      renderSlot(o.$slots, "default", {}, () => [
        createBaseVNode("TresMeshBasicMaterial", { color: unref(n) }, null, 8, zl)
      ])
    ], 16, Bl));
  }
});
var Hl = ["args"];
var Vl = ["color"];
var jc = defineComponent({
  __name: "Torus",
  props: {
    args: { default: () => [1, 1, 16, 80] },
    color: { default: "#ffffff" }
  },
  setup(l, { expose: e }) {
    const t = l, { args: s, color: n } = toRefs(t), i = shallowRef();
    return e({
      value: i
    }), (o, r) => (openBlock(), createElementBlock("TresMesh", mergeProps({
      ref_key: "torusRef",
      ref: i
    }, o.$attrs), [
      createBaseVNode("TresTorusGeometry", { args: unref(s) }, null, 8, Hl),
      renderSlot(o.$slots, "default", {}, () => [
        createBaseVNode("TresMeshBasicMaterial", { color: unref(n) }, null, 8, Vl)
      ])
    ], 16));
  }
});
var Gl = ["args"];
var jl = ["color"];
var Yc = defineComponent({
  __name: "TorusKnot",
  props: {
    args: { default: () => [1, 0.4, 64, 8] },
    color: { default: "#ffffff" }
  },
  setup(l, { expose: e }) {
    const t = l, { args: s, color: n } = toRefs(t), i = shallowRef();
    return e({
      value: i
    }), (o, r) => (openBlock(), createElementBlock("TresMesh", mergeProps({
      ref_key: "torusKnotRef",
      ref: i
    }, o.$attrs), [
      createBaseVNode("TresTorusKnotGeometry", { args: unref(s) }, null, 8, Gl),
      renderSlot(o.$slots, "default", {}, () => [
        createBaseVNode("TresMeshBasicMaterial", { color: unref(n) }, null, 8, jl)
      ])
    ], 16));
  }
});
var Yl = ["args"];
var Xl = ["color"];
var Xc = defineComponent({
  __name: "Tube",
  props: {
    args: { default: () => [
      new QuadraticBezierCurve3(new Vector3(-1, 0, 0), new Vector3(0, 1, 0), new Vector3(1, 0, 0)),
      20,
      0.2,
      8,
      false
    ] },
    color: { default: "#ffffff" }
  },
  setup(l, { expose: e }) {
    const t = l, { args: s, color: n } = toRefs(t), i = shallowRef();
    return e({
      value: i
    }), (o, r) => (openBlock(), createElementBlock("TresMesh", mergeProps({
      ref_key: "tubeRef",
      ref: i
    }, o.$attrs), [
      createBaseVNode("TresTubeGeometry", { args: unref(s) }, null, 8, Yl),
      renderSlot(o.$slots, "default", {}, () => [
        createBaseVNode("TresMeshBasicMaterial", { color: unref(n) }, null, 8, Xl)
      ])
    ], 16));
  }
});
var Zc = defineComponent({
  name: "Environment",
  props: ["background", "blur", "files", "encoding", "path", "preset"],
  async setup(l, { expose: e }) {
    let t = null;
    return e({ getTexture: () => t }), t = await Ya(l), () => {
    };
  }
});
var Zl = ["receive-shadow", "rotation"];
var $l = ["args"];
var Kl = createBaseVNode("TresMeshStandardMaterial", {
  color: 8421504,
  side: 2
}, null, -1);
var $c = defineComponent({
  __name: "Backdrop",
  props: {
    floor: { default: 0.25 },
    segments: { default: 20 },
    receiveShadow: { type: Boolean, default: false }
  },
  setup(l) {
    const e = l, t = (r) => r === 0 ? 0 : 2 ** (10 * r - 10), { floor: s, segments: n, receiveShadow: i } = toRefs(e), o = ref(null);
    return watch(
      () => [n.value, s.value, o.value],
      ([r, a, c]) => {
        if (!c || r === null)
          return;
        let u = 0;
        const h = r / r / 2, d = c.attributes.position;
        for (let f = 0; f < r + 1; f++)
          for (let E = 0; E < r + 1; E++)
            d.setXYZ(
              u++,
              f / r - h + (f === 0 ? -a : 0),
              E / r - h,
              t(f / r)
            );
        d.needsUpdate = true, c.computeVertexNormals();
      }
    ), (r, a) => (openBlock(), createElementBlock("TresGroup", normalizeProps(guardReactiveProps(r.$attrs)), [
      createBaseVNode("TresMesh", {
        "receive-shadow": unref(i),
        rotation: [-Math.PI / 2, 0, Math.PI / 2]
      }, [
        createBaseVNode("TresPlaneGeometry", {
          ref_key: "planeRef",
          ref: o,
          args: [1, 1, unref(n), unref(n)]
        }, null, 8, $l),
        renderSlot(r.$slots, "default", {}, () => [
          Kl
        ])
      ], 8, Zl)
    ], 16));
  }
});
var Wl = ["geometry"];
var Ql = ["map", "opacity", "depth-write"];
var ql = ["args"];
var Jl = ["rotation", "args"];
var Kc = defineComponent({
  __name: "ContactShadows",
  props: {
    opacity: { default: 1 },
    width: { default: 1 },
    height: { default: 1 },
    blur: { default: 1 },
    far: { default: 10 },
    smooth: { type: Boolean, default: true },
    resolution: { default: 512 },
    frames: { default: 1 / 0 },
    scale: { default: 10 },
    color: { default: "#000000" },
    depthWrite: { type: Boolean, default: false },
    helper: { type: Boolean, default: false }
  },
  setup(l, { expose: e }) {
    const t = l, s = shallowRef(), n = shallowRef();
    e(s);
    let i, o, r, a, c;
    const { renderer: u, scene: h } = nt(), d = computed(() => t.width * (Array.isArray(t.scale) ? t.scale[0] : t.scale || 1)), f = computed(() => t.height * (Array.isArray(t.scale) ? t.scale[1] : t.scale || 1));
    watchEffect(() => {
      i && i.dispose(), o && o.dispose(), r && r.dispose(), a && a.geometry.dispose(), i = new WebGLRenderTarget(t.resolution, t.resolution), o = new WebGLRenderTarget(t.resolution, t.resolution), o.texture.generateMipmaps = i.texture.generateMipmaps = false, n.value = new OrthographicCamera(
        -d.value / 2,
        d.value / 2,
        f.value / 2,
        -f.value / 2,
        0,
        t.far
      ), r = new PlaneGeometry(d.value, f.value).rotateX(Math.PI / 2), a = new Mesh(r), a.visible = false;
    }), watchEffect(() => {
      t.color && (c && c.dispose(), c = new MeshDepthMaterial(), c.depthTest = c.depthWrite = false, c.onBeforeCompile = (A) => {
        A.uniforms = {
          ...A.uniforms,
          ucolor: { value: t.color ? new Color(t.color) : new Color() }
        }, A.fragmentShader = A.fragmentShader.replace(
          "void main() {",
          //
          `uniform vec3 ucolor;
             void main() {
            `
        ), A.fragmentShader = A.fragmentShader.replace(
          "vec4( vec3( 1.0 - fragCoordZ ), opacity );",
          // Colorize the shadow, multiply by the falloff so that the center can remain darker
          "vec4( ucolor * fragCoordZ * 2.0, ( 1.0 - fragCoordZ ) * 1.0 );"
        );
      });
    });
    const E = new ShaderMaterial(qr), v = new ShaderMaterial(Jr);
    v.depthTest = E.depthTest = false;
    function g(A) {
      !u.value || !n.value || (a.visible = true, a.material = E, E.uniforms.tDiffuse.value = i.texture, E.uniforms.h.value = A / 256, u.value.setRenderTarget(o), u.value.render(a, n.value), a.material = v, v.uniforms.tDiffuse.value = o.texture, v.uniforms.v.value = A / 256, u.value.setRenderTarget(i), u.value.render(a, n.value), a.visible = false);
    }
    const { onLoop: x } = ae();
    let M = 0, y, m;
    return x(() => {
      !n.value || h.value === void 0 || u.value === void 0 || (t.frames === 1 / 0 || M < t.frames) && (M++, y = h.value.background, m = h.value.overrideMaterial, s.value.visible = false, h.value.background = null, h.value.overrideMaterial = c, u.value.setRenderTarget(i), u.value.render(h.value, n.value), g(t.blur), t.smooth && g(t.blur * 0.4), u.value.setRenderTarget(null), s.value.visible = true, h.value.background = y, h.value.overrideMaterial = m);
    }), (A, b) => {
      const _ = resolveComponent("primitive");
      return openBlock(), createElementBlock("TresGroup", mergeProps({
        ref_key: "groupRef",
        ref: s
      }, A.$attrs), [
        createBaseVNode("TresMesh", {
          scale: [1, -1, 1],
          geometry: unref(r)
        }, [
          createBaseVNode("TresMeshBasicMaterial", {
            map: unref(i).texture,
            opacity: A.opacity,
            "depth-write": A.depthWrite,
            transparent: true
          }, null, 8, Ql)
        ], 8, Wl),
        createVNode(_, { object: unref(a) }, null, 8, ["object"]),
        n.value && A.helper ? (openBlock(), createElementBlock("TresCameraHelper", {
          key: 0,
          args: [n.value]
        }, null, 8, ql)) : createCommentVNode("", true),
        createBaseVNode("TresOrthographicCamera", {
          ref_key: "shadowCamera",
          ref: n,
          position: [0, 0, 0],
          rotation: [Math.PI / 2, 0, 0],
          args: [-d.value / 2, d.value / 2, f.value / 2, -f.value / 2, 0, A.far]
        }, null, 8, Jl)
      ], 16);
    };
  }
});
var ec = ["position", "a-scale"];
var tc = ["size", "size-attenuation", "transparent", "alpha-test", "alpha-map"];
var Wc = defineComponent({
  __name: "Stars",
  props: {
    size: { default: 0.1 },
    sizeAttenuation: { type: Boolean, default: true },
    transparent: { type: Boolean, default: true },
    alphaTest: { default: 0.01 },
    count: { default: 5e3 },
    depth: { default: 50 },
    radius: { default: 100 },
    alphaMap: { default: null }
  },
  setup(l, { expose: e }) {
    const t = l, s = ref(), n = ref(), { radius: i, depth: o, count: r, size: a, sizeAttenuation: c, transparent: u, alphaMap: h, alphaTest: d } = toRefs(t), f = () => {
      let v = i.value + o.value;
      const g = computed(() => o.value / r.value), x = [], M = Array.from(
        { length: r.value },
        () => (0.5 + 0.5 * Math.random()) * 4
      ), y = (m) => new Vector3().setFromSpherical(new Spherical(m, Math.acos(1 - Math.random() * 2), Math.random() * 2 * Math.PI)).toArray();
      for (let m = 0; m < r.value; m++)
        v -= g.value * Math.random(), x.push(...y(v));
      s.value = new Float32Array(x), n.value = new Float32Array(M);
    };
    watchEffect(() => {
      f();
    });
    const E = shallowRef();
    return e({
      value: E
    }), (v, g) => (openBlock(), createElementBlock("TresPoints", {
      ref_key: "starsRef",
      ref: E
    }, [
      createBaseVNode("TresBufferGeometry", {
        position: [s.value, 3],
        "a-scale": [n.value, 1]
      }, null, 8, ec),
      createBaseVNode("TresPointsMaterial", {
        size: unref(a),
        "size-attenuation": unref(c),
        transparent: unref(u),
        "alpha-test": unref(d),
        "alpha-map": unref(h)
      }, null, 8, tc)
    ], 512));
  }
});
var sc = ["size", "color", "alpha-map", "map", "opacity", "alpha-test", "depth-write", "transparent", "size-attenuation"];
var nc = ["position", "velocity"];
var Qc = defineComponent({
  __name: "Precipitation",
  props: {
    size: { default: 0.1 },
    area: { default: () => [10, 10, 20] },
    color: { default: 16777215 },
    map: {},
    alphaMap: {},
    alphaTest: { default: 0.01 },
    opacity: { default: 0.8 },
    count: { default: 5e3 },
    speed: { default: 0.1 },
    randomness: { default: 0.5 },
    depthWrite: { type: Boolean, default: false },
    transparent: { type: Boolean, default: true },
    sizeAttenuation: { type: Boolean, default: true }
  },
  setup(l) {
    const e = l, {
      size: t,
      area: s,
      color: n,
      alphaMap: i,
      map: o,
      opacity: r,
      alphaTest: a,
      depthWrite: c,
      transparent: u,
      sizeAttenuation: h,
      count: d,
      speed: f,
      randomness: E
    } = toRefs(e), v = shallowRef();
    let g = [], x = [];
    const M = () => {
      g = new Float32Array(d.value * 3);
      for (let A = 0; A < d.value; A++) {
        const b = A * 3;
        g[b] = (Math.random() - 0.5) * s.value[0], g[b + 1] = (Math.random() - 0.5) * s.value[1], g[b + 2] = (Math.random() - 0.5) * s.value[2];
      }
    }, y = () => {
      x = new Float32Array(d.value * 2);
      for (let A = 0; A < d.value * 2; A += 2)
        x[A] = (Math.random() - 0.5) / 5 * f.value * E.value, x[A + 1] = Math.random() / 5 * f.value + 0.01;
    };
    y(), M(), watchEffect(() => {
      y(), M();
    });
    const { onLoop: m } = ae();
    return m(() => {
      var A, b;
      if ((A = v.value) != null && A.attributes.position.array && ((b = v.value) != null && b.attributes.position.count)) {
        const _ = v.value.attributes.position.array;
        for (let T = 0; T < v.value.attributes.position.count; T++) {
          const L2 = x[T * 2], B = x[T * 2 + 1];
          _[T * 3] += L2, _[T * 3 + 1] -= B, (_[T * 3] <= -s.value[0] / 2 || _[T * 3] >= s.value[0] / 2) && (_[T * 3] = _[T * 3] * -1), (_[T * 3 + 1] <= -s.value[1] / 2 || _[T * 3 + 1] >= s.value[1] / 2) && (_[T * 3 + 1] = _[T * 3 + 1] * -1);
        }
        v.value.attributes.position.needsUpdate = true;
      }
    }), (A, b) => (openBlock(), createElementBlock("TresPoints", null, [
      createBaseVNode("TresPointsMaterial", {
        size: unref(t),
        color: unref(n),
        "alpha-map": unref(i),
        map: unref(o),
        opacity: unref(r),
        "alpha-test": unref(a),
        "depth-write": unref(c),
        transparent: unref(u),
        "size-attenuation": unref(h)
      }, null, 8, sc),
      createBaseVNode("TresBufferGeometry", {
        ref_key: "geometryRef",
        ref: v,
        position: [unref(g), 3],
        velocity: [unref(x)]
      }, null, 8, nc)
    ]));
  }
});
var ic = ["position"];
var oc = ["position"];
var rc = ["scale"];
var ac = ["map", "depth-test", "color-space", "color", "opacity"];
var qc = defineComponent({
  __name: "Smoke",
  props: {
    color: { default: "#ffffff" },
    opacity: { default: 0.5 },
    speed: { default: 0.4 },
    width: { default: 10 },
    depth: { default: 1.5 },
    segments: { default: 20 },
    texture: { default: "https://raw.githubusercontent.com/Tresjs/assets/main/textures/clouds/defaultCloud.png" },
    depthTest: { type: Boolean, default: true }
  },
  async setup(l, { expose: e }) {
    let t, s;
    const n = l, { width: i, depth: o, segments: r, texture: a, color: c, depthTest: u, opacity: h, speed: d } = toRefs(n), f = shallowRef(), E = shallowRef();
    e({
      value: f
    });
    const v = [...new Array(r)].map((b, _) => ({
      x: i.value / 2 - Math.random() * i.value,
      y: i.value / 2 - Math.random() * i.value,
      scale: 0.4 + Math.sin((_ + 1) / r.value * Math.PI) * ((0.2 + Math.random()) * 10),
      density: Math.max(0.2, Math.random()),
      rotation: Math.max(2e-3, 5e-3 * Math.random()) * d.value
    })), g = (b, _) => b / 6 * _ * h.value, { map: x } = ([t, s] = withAsyncContext(() => dt({ map: a.value })), t = await t, s(), t), { renderer: M, camera: y } = nt(), m = computed(() => {
      var b;
      return (b = M.value) == null ? void 0 : b.outputColorSpace;
    }), { onLoop: A } = ae();
    return A(() => {
      var b, _;
      f.value && y.value && E.value && ((b = E.value) == null || b.children.forEach((T, L2) => {
        T.rotation.z += v[L2].rotation;
      }), f.value.lookAt((_ = y.value) == null ? void 0 : _.position));
    }), (b, _) => (openBlock(), createElementBlock("TresGroup", mergeProps({
      ref_key: "smokeRef",
      ref: f
    }, b.$attrs), [
      createBaseVNode("TresGroup", {
        ref_key: "groupRef",
        ref: E,
        position: [0, 0, unref(r) / 2 * unref(o)]
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(unref(v), ({ scale: T, x: L2, y: B, density: k }, N) => (openBlock(), createElementBlock("TresMesh", {
          key: `${N}`,
          position: [L2, B, -N * unref(o)]
        }, [
          createBaseVNode("TresPlaneGeometry", {
            scale: [T, T, T],
            rotation: [0, 0, 0]
          }, null, 8, rc),
          createBaseVNode("TresMeshStandardMaterial", {
            map: unref(x),
            "depth-test": unref(u),
            "color-space": m.value,
            color: unref(c),
            "depth-write": false,
            transparent: "",
            opacity: g(T, k)
          }, null, 8, ac)
        ], 8, oc))), 128))
      ], 8, ic)
    ], 16));
  }
});
var ft;
var Jc = (l = "body") => {
  ft || (ft = new Pane({
    container: document.querySelector(l)
  }), ft.element.style.position = "absolute", ft.element.style.top = "1rem", ft.element.style.right = "1rem", ft.element.style.zIndex = "9999");
  const { logWarning: e } = Rn();
  e("useTweakPane is going to be deprecated soon and will no longer be part of this package, please start migrating to @tresjs/leches package https://github.com/Tresjs/leches or v-tweakpane https://github.com/vinayakkulkarni/v-tweakpane instead.");
  function t() {
    ft && ft.dispose();
  }
  return onMounted(() => {
    const { resume: s } = ae();
    s();
  }), onUnmounted(() => {
    t();
  }), { pane: ft, disposeTweakPane: t };
};
var Qi = { exports: {} };
(function(l, e) {
  (function(t, s) {
    l.exports = s();
  })(ba, function() {
    var t = function() {
      function s(f) {
        return o.appendChild(f.dom), f;
      }
      function n(f) {
        for (var E = 0; E < o.children.length; E++)
          o.children[E].style.display = E === f ? "block" : "none";
        i = f;
      }
      var i = 0, o = document.createElement("div");
      o.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000", o.addEventListener("click", function(f) {
        f.preventDefault(), n(++i % o.children.length);
      }, false);
      var r = (performance || Date).now(), a = r, c = 0, u = s(new t.Panel("FPS", "#0ff", "#002")), h = s(new t.Panel("MS", "#0f0", "#020"));
      if (self.performance && self.performance.memory)
        var d = s(new t.Panel("MB", "#f08", "#201"));
      return n(0), { REVISION: 16, dom: o, addPanel: s, showPanel: n, begin: function() {
        r = (performance || Date).now();
      }, end: function() {
        c++;
        var f = (performance || Date).now();
        if (h.update(f - r, 200), f > a + 1e3 && (u.update(1e3 * c / (f - a), 100), a = f, c = 0, d)) {
          var E = performance.memory;
          d.update(E.usedJSHeapSize / 1048576, E.jsHeapSizeLimit / 1048576);
        }
        return f;
      }, update: function() {
        r = this.end();
      }, domElement: o, setMode: n };
    };
    return t.Panel = function(s, n, i) {
      var o = 1 / 0, r = 0, a = Math.round, c = a(window.devicePixelRatio || 1), u = 80 * c, h = 48 * c, d = 3 * c, f = 2 * c, E = 3 * c, v = 15 * c, g = 74 * c, x = 30 * c, M = document.createElement("canvas");
      M.width = u, M.height = h, M.style.cssText = "width:80px;height:48px";
      var y = M.getContext("2d");
      return y.font = "bold " + 9 * c + "px Helvetica,Arial,sans-serif", y.textBaseline = "top", y.fillStyle = i, y.fillRect(0, 0, u, h), y.fillStyle = n, y.fillText(s, d, f), y.fillRect(E, v, g, x), y.fillStyle = i, y.globalAlpha = 0.9, y.fillRect(E, v, g, x), { dom: M, update: function(m, A) {
        o = Math.min(o, m), r = Math.max(r, m), y.fillStyle = i, y.globalAlpha = 1, y.fillRect(0, 0, u, v), y.fillStyle = n, y.fillText(a(m) + " " + s + " (" + a(o) + "-" + a(r) + ")", d, f), y.drawImage(M, E + c, v, g - c, x, E, v, g - c, x), y.fillRect(E + g - c, v, c, x), y.fillStyle = i, y.globalAlpha = 0.9, y.fillRect(E + g - c, v, c, a((1 - m / A) * x));
      } };
    }, t;
  });
})(Qi);
var lc = Qi.exports;
var cc = Aa(lc);
var eh = (l = 0) => {
  const e = new cc();
  if (e) {
    const t = document.body;
    e.showPanel(l), t == null || t.appendChild(e.dom), onMounted(() => {
      const { onBeforeLoop: s, onAfterLoop: n, resume: i } = ae();
      i(), s(() => e.begin()), n(() => e.end());
    }), onUnmounted(() => {
      t == null || t.removeChild(e.dom);
    });
  }
  return null;
};
export {
  $c as Backdrop,
  Dc as Box,
  Rc as CameraControls,
  kc as Circle,
  Fc as Cone,
  Kc as ContactShadows,
  Uc as Dodecahedron,
  Zc as Environment,
  Ec as FBXModel,
  Tc as GLTFModel,
  Bc as Icosahedron,
  Mc as KeyboardControls,
  _c as Levioso,
  Oc as MapControls,
  Ic as MeshGlassMaterial,
  Cc as MeshWobbleMaterial,
  vc as MouseParallax,
  Nc as Octahedron,
  Ac as OrbitControls,
  zc as Plane,
  Pc as PointerLockControls,
  Qc as Precipitation,
  Hc as Ring,
  xc as SVG,
  Lc as ScrollControls,
  qc as Smoke,
  Vc as Sphere,
  Wc as Stars,
  Gc as Tetrahedron,
  gc as Text3D,
  jc as Torus,
  Yc as TorusKnot,
  Sc as TransformControls,
  Xc as Tube,
  eh as stats,
  yc as useAnimations,
  Ya as useEnvironment,
  $a as useFBX,
  Za as useGLTF,
  wc as useProgress,
  Jc as useTweakPane,
  bc as useVideoTexture
};
/*! Bundled license information:

tweakpane/dist/tweakpane.js:
  (*! Tweakpane 4.0.1 (c) 2016 cocopon, licensed under the MIT license. *)

@tresjs/cientos/dist/trescientos.js:
  (*!
   * camera-controls
   * https://github.com/yomotsu/camera-controls
   * (c) 2017 @yomotsu
   * Released under the MIT License.
   *)
*/
//# sourceMappingURL=@tresjs_cientos.js.map
